<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-09-27T15:11:40.077Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[怎样才能开开心心的呢？]]></title>
        <id>https://mengxiaoxu.github.io//post/o9IjztOrR</id>
        <link href="https://mengxiaoxu.github.io//post/o9IjztOrR">
        </link>
        <updated>2019-09-08T13:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。</p>
<p>说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。</p>
<p>媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。</p>
<p>包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”</p>
<p>像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。</p>
<p>我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。</p>
<p>很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。</p>
<p>这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。</p>
<p>于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。</p>
<p>当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。</p>
<p>当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。</p>
<p>举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。</p>
<p>我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。</p>
<p>另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。</p>
<p>周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？</p>
<p>凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量提升与作用域]]></title>
        <id>https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu</id>
        <link href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu">
        </link>
        <updated>2019-08-08T14:29:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="https://www.crifan.com/lhs_rhs_meaning/">lhs rhs是啥意思</a><br>
《Javasript 高级程序设计（第三版）》<br>
《你不知道的 JavaScript（上卷）》</p>
</blockquote>
<p>几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为<strong>作用域</strong>。</p>
<h3 id="编译原理">编译原理</h3>
<p>我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。</p>
<p>传统语言在执行之前会经历三个步骤：<strong>分词/词法分析、解析/语法分析、代码生成</strong>，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。</p>
<p>我们需要先了解三个名词。<strong>引擎</strong>：从头到尾负责整个 js 程序的编译及执行过程；<strong>编译器</strong>：负责词法分析及代码生成；<strong>作用域</strong>：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
<p><code>var a = 2;</code>，我们以这段程序为例，它首先声明了变量<code>a</code>，然后将<code>2</code>赋值给变量<code>a</code>。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。</p>
<p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>
<h3 id="变量提升">变量提升</h3>
<p>用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码</p>
<pre><code class="language-javascript">console.log(a);
var a = 2;
</code></pre>
<p>上述代码在<code>a</code>声明之前访问了变量<code>a</code>，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是<code>undefined</code>。</p>
<p>回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，<strong>包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理</strong>。所以我们前面列出来的代码实际上会变成下面这个样子。</p>
<pre><code class="language-javascript">var a;
console.log(a);
a = 2;
</code></pre>
<p>这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。</p>
<pre><code class="language-javascript">foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}
</code></pre>
<p>这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。</p>
<pre><code class="language-javascript">function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};
</code></pre>
<p>可以看到，虽然<code>var foo</code>出现在<code>function foo()</code>之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。</p>
<h3 id="lhs-和-rhs-查询">LHS 和 RHS 查询</h3>
<p>LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是<strong>赋值操作符的左侧和右侧</strong>。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。</p>
<p>RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。</p>
<p><code>console.info(a);</code>我们深入研究一下这句代码。这里对<code>a</code>的引用是 RHS 引用，因为这里<code>a</code>并没有赋予任何值，相应的需要查找并取得<code>a</code>的值，这样才能传递给<code>console.info()</code>。</p>
<p><code>a = 2;</code>对<code>a</code>的引用则是一个 LHS 引用，因为实际上我们并关心<code>a</code>当前的值是什么，只是想为<code>= 2</code>这个赋值操作找到一个目标。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a);
}
foo(2);
</code></pre>
<p>为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行<code>foo()</code>函数的调用需要对<code>foo</code>进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给<code>foo()</code>函数时，2 会被分配给参数<code>a</code>，为了给参数<code>a</code>（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了<code>a = 2</code>的语句。</p>
<p>前文已经说过了<code>console.info(a);</code>会对<code>a</code>进行一次 RHS 查询，需要注意的是<code>console.info()</code>本身也需要一个引用才能执行，因此会对<code>console</code>对象进行 RHS 查询，并检查得到的值中是否有一个<code>log</code>方法。</p>
<h3 id="为什么区分-lhs-和-rhs">为什么区分 LHS 和 RHS</h3>
<p>我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);
</code></pre>
<p>第一次对<code>b</code>进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。</p>
<p>引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<blockquote>
<p>需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。</p>
</blockquote>
<p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。</p>
<h3 id="作用域链">作用域链</h3>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是<code>window</code>对象，因此所有的全局变量和函数都是作为<code>window</code>对象的属性和方法创建的。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。</p>
<p>当代码在环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function changeColor() {
    var anotherColor = &quot;red&quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();
</code></pre>
<p>下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。</p>
<pre><code class="language-text">window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor
</code></pre>
<p>作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function getColor() {
    var color = &quot;red&quot;;
    return color;
}

console.info(getColor()); // &quot;red&quot;
</code></pre>
<p>在<code>getColor()</code>中沿着作用域链在局部环境中已经找到了<code>color</code>，所以搜索就停止了，也就是说任何位于局部变量<code>color</code>的声明之后的代码，如果不使用<code>window.color</code>都无法访问全局<code>color</code>变量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[惰性载入函数]]></title>
        <id>https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu</id>
        <link href="https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu">
        </link>
        <updated>2019-08-06T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考资料：<br>
《JavaScript 高级程序设计（第三版）》<br>
<a href="https://github.com/mqyqingfeng/Blog/issues/44">JavaScript专题之惰性函数</a><br>
<a href="https://xiaohuochai.site/JS/ECMA/types/LazyFunction.html">深入理解javascript函数进阶之惰性函数</a></p>
</blockquote>
<p>因为不同厂商的浏览器相互之间存在一些行为上的差异，很多 js 代码包含了大量的<code>if</code>语句，将执行引导到正确的分支代码中去，比如下面的例子。</p>
<pre><code class="language-javascript">function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != 'undefined') {
        if (typeof arguments.callee.activeXString != 'string') {
            var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
            var i, len;
            for (i = 0, len = versions.length; i &lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (e) {
                    // skip
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error('No XHR object available.');
    }
}
</code></pre>
<p>我们可以发现，在浏览器每次调用<code>createXHR()</code>的时候，它都要对浏览器所支持的能力仔细检查，但是很明显当第一次检查之后，我们就应该知道浏览器是否支持我们所需要的能力，因此除第一次之外的检查都是多余的。即使只有一个<code>if</code>语句也肯定要比没有<code>if</code>语句慢，所以<code>if</code>语句不必每次都执行，那么代码可以运行的更快一些，<strong>惰性载入</strong>就是用来解决这种问题的技巧。</p>
<h3 id="函数重写">函数重写</h3>
<p>要理解惰性载入函数的原理，我们有必要先理解一下函数重写技术，由于一个函数可以返回另一个函数，因此可以在函数内部用新的函数来覆盖旧的函数。</p>
<pre><code class="language-javascript">function sayHi() {
    console.info('Hi');
    sayHi = function() {
        console.info('Hello');
    }
}
</code></pre>
<p>我们第一次调用<code>sayHi()</code>函数时，控制台会打印出<code>Hi</code>，全局变量<code>sayHi</code>被重新定义，被赋予了新的函数，从第二次开始之后的调用都会打印出<code>Hello</code>。惰性载入函数的本质就是函数重写，惰性载入的意思就是函数执行的分支只会发生一次。</p>
<h3 id="惰性载入">惰性载入</h3>
<p>我们来看一个例子（例子来源于<a href="https://github.com/mqyqingfeng">冴羽</a>所写的<a href="https://github.com/mqyqingfeng/Blog/issues/44">JavaScript专题之惰性函数</a>）。现在需要写一个<code>foo</code>函数，这个函数返回首次调用时的<code>Date</code>对象，注意是首次。</p>
<h5 id="方案一">方案一</h5>
<pre><code class="language-javascript">var t;
function foo() {
    if (t) return t;
    t = new Date()
    return t;
}
// 此方案存在两个问题，一是污染了全局变量
// 二是每次调用都需要进行一次判断
</code></pre>
<h5 id="方案二">方案二</h5>
<pre><code class="language-javascript">var foo = (function() {
    var t;
    return function() {
        if (t) return t;
        t = new Date();
        return t;
    }
})();
// 使用闭包来避免污染全局变量，
// 但是还是没有解决每次调用都需要进行一次判断的问题
</code></pre>
<h5 id="方案三">方案三</h5>
<pre><code class="language-javascript">function foo() {
    if (foo.t) return foo.t;
    foo.t = new Date();
    return foo.t;
}
// 函数也是一种对象，利用这个特性也可以解决
// 和方案二一样，还差一个问题没有解决
</code></pre>
<h5 id="方案四">方案四</h5>
<pre><code class="language-javascript">var foo = function() {
    var t = new Date();
    foo = function() {
        return t;
    };
    return foo();
};
// 利用惰性载入技巧，即重写函数
</code></pre>
<p>惰性载入函数有两种实现方式，第一种是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一种按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行分支了。</p>
<p>第二种实现方式是在声明函数时就指定适当的函数。这样第一次调用时就不会损失性能了，而是在代码首次加载时会损失一点性能，即是利用闭包写一个自执行的函数。</p>
<h3 id="改进-createxhr">改进 createXHR</h3>
<p>有了上面的基础，我们就可以将<code>createXHR()</code>改进为下列形式，这样就不用每次调用都进行判断了。</p>
<pre><code class="language-javascript">// 第一种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        createXHR = function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != 'undefined') {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != 'string') {
                var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
                var i, len;
                for (i = 0, len = versions.length; i &lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error('No XHR object available.');
        }
    }
}

// 第二种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        return function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != 'undefined') {
        return function() {
            if (typeof arguments.callee.activeXString != 'string') {
                var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
                var i, len;
                for (i = 0, len = versions.length; i &lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error('No XHR object available.');
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[非设计师需要知道的四个设计原则]]></title>
        <id>https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze</id>
        <link href="https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">
        </link>
        <updated>2019-06-22T14:33:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>作者：Anna 4erepawko Mészáros，UI/UX 设计师。<br>
关注作者：<a href="https://medium.com/@4erepawko"> Medium</a>、<a href="https://twitter.com/4erepawko">Twitter</a></p>
</blockquote>
<p>这篇文章是写给无力邀请专业设计师的所有内容创作者的，以及设计师异常忙碌的团队的非设计师们。如果您按照这些简单的步骤进行操作，我保证您的设计会变得更好。</p>
<p>这些 Tips 来源于我对身边非设计朋友的多年观察，家人与同事在日常生活中也需要设计他们的东西。比如简历、作品集，Facebook 和 Instagram 上帖子要使用的图片，YouTube 视频的缩略图等。</p>
<p>所有这些人都向我寻求帮助与建议，希望能让他们的东西看起来更好。我坚信「授人以鱼不如授人以渔」，所以我试图提供更有价值的建议，以便他们在未来也能解决类似的问题。</p>
<p>随着时间的推移，我意识到我一直在给所有人提供相同的建议，虽然每次所使用的措辞不同，但我所有的建议都可以提炼为以下四个原则。</p>
<p>这些 Tips 会帮您创造出美丽动人的设计吗？答案是不会！它们只会帮您创造出色、清晰且易于理解的设计。是每个人都可以轻松理解和互动吗？那当然，所以不多说废话，下面我就向您逐一展示。</p>
<h3 id="对比">对比</h3>
<p>确保所有元素之间有足够的对比度。为什么？因为那些略有差异但是又不够不同东西，创造了一种恐怖谷。人类的眼睛会排斥它们，对它们感到厌恶、难以理解。我们不希望它们出现在我们的设计中，难道不是吗？</p>
<blockquote>
<p>恐怖谷理论，是一个关于人类对机器人和非人类物体的感觉的假设。如果一个非人类实体不够拟人，那么它身上的人类特征会很容易辨认；而当它足够拟人时，他身上的非人类特征则会变得很容易辨认。因此会在人类观察者眼中产生一种古怪的感觉，想想您看到病患者或者尸体时的感觉。</p>
</blockquote>
<p>因此您设计的元素要么完全相同，要么具有显著差异。</p>
<p>您可以从下面四个方面来突出对比：</p>
<p><em><strong>1、颜色：浅色上使用暗色，反之亦然</strong></em></p>
<p><strong>示例：</strong> 切勿在浅蓝色上使用浅灰色或浅粉红色等灰色组合，它们会造成阅读/互动上的极大困难。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569508466579.jpg" alt=""></figure>
<p><em><strong>2、大小：相邻元素要么大小完全相同，要么大小区别很大</strong></em></p>
<p><strong>示例：</strong> 不要将 32pt 和 36pt 的文本放在一起；18pt 和 36pt 放在一起会显得更加协调。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569508508617.jpg" alt=""></figure>
<p><em><strong>3、粗细：与大小一样，相邻元素的粗细要么完全相同，要么有明显的区别</strong></em></p>
<p><strong>示例：</strong> 不要将相同字体的粗体与黑体放在一起，因为它们看起来太相似了；将黑体与细体放在一起会显得很协调。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569508538231.jpg" alt=""></figure>
<p><em><strong>4、风格：不要将一个斜体类型放在另一个斜体类型旁边，或者在一个衬线字体旁边放置另一个衬线字体。应该组合不同的东西。</strong></em></p>
<p><strong>示例：</strong> 不要将 Times New Roman 与 Georgia 放在一起，它们看起来太相似了，应该组合完全不同的风格。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569508569075.jpg" alt=""></figure>
<h3 id="一致性">一致性</h3>
<p>确保相似的元素以相似的方式出现。为什么呢？首先，通过确保确保事物一致性，您可以让用户将注意力集中在设计的重要方面，而不是被随时变化的元素分散注意力。</p>
<p>其次，一致性也增加了用户对您的信任，使事物看起来实际上是设计的，而不是简单快速拼凑出来的。</p>
<p>一旦你选择了具体的风格，就要毫不犹豫的坚持下去，这里所说的风格包括字体、颜色、阴影、栅格、对齐、装饰风格等等。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569508599900.jpg" alt=""></figure>
<p>当您处理许多相邻的不同部分时（比如 YouTube 的视频缩略图或是中型文章的封面），您应该为所有部分选择一种整体风格，并坚持使用。</p>
<h3 id="奥卡姆剃刀-减少视觉噪音">奥卡姆剃刀 减少视觉噪音</h3>
<p>在您的设计中，使用的元素越少越好。为什么呢？因为人类的大脑很难在输入过载的情况下处理信息并作出决策。您应该使用尽可能少的装饰元素（字体、颜色、阴影、图标等等）。</p>
<p>将奥卡姆剃刀应用于所有内容。如果只需要两个元素就能满足需求，那么就不要使用 3 个元素；如果 10 个元素实现所需的功能，那么就不要用 20 个元素。</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569508627847.jpg" alt=""></figure>
<p>如果您不喜欢古老的英国哲学家风格，更喜欢您在 Netflix（一家美国流媒体提供商）上看到的东西。请将<a href="https://zh.wikipedia.org/wiki/%E6%80%A6%E7%84%B6%E5%BF%83%E5%8A%A8%E7%9A%84%E4%BA%BA%E7%94%9F%E6%95%B4%E7%90%86%E9%AD%94%E6%B3%95">怦然心动的人生整理魔法</a>应用到您的设计中。</p>
<blockquote>
<p>《怦然心动的人生整理魔法》是美国流媒体提供商Netflix于2019年1月1日首播的一档真人实境秀节目。节目由日本“整理咨询顾问” 近藤麻理惠主创。她在每集节目中拜访一个家庭，帮助他们整理自己的房间。<br>
近藤麻理惠认为整理房间时应当将物品分为五类：衣物、书籍、纸张文件、杂物和情感纪念品；在整理时拿起每件物品，如果能使自己“怦然心动”则留下，如果不能则要感谢物品的贡献然后与其告别。</p>
</blockquote>
<h3 id="间距">间距</h3>
<p>元素的位置会发送关于其含义的元级别消息。为什么这很重要？因为了解如何放置元素以及在它们周围预留了多少空间有助于降低设计的复杂性，因此会使人更加愉悦，并且更容易交互。</p>
<p>在您的设计中使用间距来传达下面 3 个方面的信息：</p>
<p><em><strong>1、接近度 = 相关性</strong></em></p>
<p>与其它元素相比，彼此更接近的事物被认为它们有更强的相关性。这是最重要的，因为我觉得它常常容易被忽视。</p>
<p>它可以以很多不同的方式应用，比如行与行之间应该有一定的间距，而不是一行中每个单词之间的间距那么小；同样不同段落之间的空间也比段落内的行空间要大。</p>
<p><img src="https://mengxiaoxu.github.io//post-images/1569508662741.jpg" alt=""><br>
元素之间的间距应该小于元素与组合边缘之间的间距。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569508700468.jpg" alt=""></figure>
<p>标签和支撑信息应该位于其相关元素附近。</p>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1569508720176.jpg" alt=""></figure>
<p><em><strong>2、留白</strong></em></p>
<p>结合奥卡姆剃刀，给您的设计尽可能留白，去整理它们，使它们的意义更加明显。</p>
<p>如果把太多元素放在有限的空间里，就像同时听三首不同的哥，很难理解别人在说什么。</p>
<figure data-type="image" tabindex="9"><img src="https://mengxiaoxu.github.io//post-images/1569508742018.jpg" alt=""></figure>
<p><em><strong>3、重要性与顺序</strong></em></p>
<p>这是一个很普通的常识，但是我还是要在这里提到它。</p>
<p>最重要的事情放在第一位，使它们占据最大的空间，用一系列的事物来传达秩序。</p>
<h3 id="结束语">结束语</h3>
<p>恭喜您！如果您按照这些 Tips 进行设计，那么按照行业标准，它可能看起来非常好。</p>
<p><strong>For everything else, there is always a designer.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅析浏览器缓存机制]]></title>
        <id>https://mengxiaoxu.github.io//post/qCt13nLLT</id>
        <link href="https://mengxiaoxu.github.io//post/qCt13nLLT">
        </link>
        <updated>2019-04-26T12:29:29.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。</p>
<h4 id="http-报文">HTTP 报文</h4>
<p>HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。</p>
<h4 id="缓存概述">缓存概述</h4>
<p>浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569414647062.png" alt=""></figure>
<p>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有<strong>强制缓存</strong>和<strong>协商缓存</strong>两类，也有人把协商缓存叫对比缓存。</p>
<h4 id="强制缓存">强制缓存</h4>
<p>我们先自己想一下，使用缓存是不是会有下面几种情况出现。</p>
<ul>
<li>
<p>存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；</p>
</li>
<li>
<p>存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；</p>
</li>
<li>
<p>不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。</p>
</li>
</ul>
<p>控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，并且<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<h6 id="expires">Expires</h6>
<p><code>Expires</code>是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于<code>Expires</code>值，就直接使用缓存数据。到了 HTTP/1.1，<code>Expires</code>已经被<code>Cache-Control</code>替代了。</p>
<p><code>Expires</code>被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。</p>
<h6 id="cache-control">Cache-Control</h6>
<p><code>Cache-Control</code>是 HTTP/1.1 中最重要的规则，主要取值为：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与<code>private</code>一样。</td>
</tr>
<tr>
<td><code>private</code></td>
<td>所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认值。</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存内容将在 xxx 秒后失效</td>
</tr>
</tbody>
</table>
<p>我们可以看看下面这个例子，可以从截图中看到<code>Expires</code>是一个绝对值，而<code>Cache-Control</code>是一个相对值，此处为<code>max-age=3600</code>，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，<code>Cache-Control</code>相比于<code>Expires</code>是更好的选择，所以同时存在时只有<code>Cache-Control</code>生效。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569414685538.png" alt=""></figure>
<h4 id="协商缓存">协商缓存</h4>
<p>协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569414775602.png" alt=""></figure>
<p>上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，所以同时存在时只有<code>Etag / If-None-Match</code>生效。</p>
<h6 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h6>
<p>你可以往上翻一翻，看一下那张响应报文截图，其中有一个<code>Last-Modified</code>字段，它的值是该资源文件在服务器最后被修改的时间。</p>
<p><code>If-Modified-Since</code>则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值。服务器收到该请求后，发现该请求头有<code>If-Modified-Since</code>字段，则会将<code>If-Modified-Since</code>与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569414811322.png" alt=""></figure>
<h6 id="etag-if-none-match">Etag / If-None-Match</h6>
<p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。</p>
<p><code>If-None-Match</code>则是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569414845179.png" alt=""></figure>
<h4 id="disk-cache-与-memory-cache">disk cache 与 memory cache</h4>
<p>我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569414871028.png" alt=""></figure>
<p>猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。</p>
<p>内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。</p>
<p>浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。</p>
<h4 id="总结">总结</h4>
<p>到这里偷懒一下子了，找到人家画的一张图，看图就行了。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569414915648.png" alt=""></figure>
<blockquote>
<p>参考内容：<br>
<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a><br>
<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 进阶及常用命令]]></title>
        <id>https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling</id>
        <link href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling">
        </link>
        <updated>2019-04-18T14:43:54.000Z</updated>
        <content type="html"><![CDATA[<p>如果你只是想查看 Git 常用命令可以选择直接到文章底部「Git 常用命令」阅读，文章大部分内容是 Git 进阶知识，均是自己的读书笔记，如果还想在此基础上再上一层楼，那可以直接看 <a href="https://git-scm.com/book/zh/v2">Pro Git book</a>。</p>
<h4 id="git-历史">Git 历史</h4>
<p>版本控制器是一种记录一个或若干文件内容变化，以便将来查阅特定版本的修订情况。也就是说，版本控制器记录了一个可供考证的历史数据，通过该数据可以知道文件是怎么一步一步发展到今天这个样子的。</p>
<p>最初 Linux 项目使用 BitKeeper 来管理和维护代码，但是到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。那 Linux 开源社区的解决方案就是自己搞一个版本控制器，所以就有了 Git。</p>
<p>简单说就是 Linus 被逼的去开发了这一款叫做 Git 的版本控制器，因为 Linus 本身就是内核专家与文件专家，所以 Git 也就自然而然具备了非凡的存储能力与性能。</p>
<h4 id="安装">安装</h4>
<p>关于如何安装 git 可以查看 <a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Pro Git book</a>，安装完成后需要进行一些必要的配置，比如用户信息、文本编辑器、差异分析工具等等，我们可以通过<code>git config --list</code>来查看配置信息。比如我们要配置用户和邮箱，就可以像下面这样输入命令。</p>
<pre><code class="language-shell">$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
</code></pre>
<h4 id="git-原理">Git 原理</h4>
<p>Git 和大多数版本控制器有一个重要的区别，就是它<strong>直接记录快照，而非差异比较</strong>，其它大部分系统以文件变更列表的方式存储信息，而 Git 则存储每个文件与初始版本的差异。换句话说，只要你的文件有改动，那么 Git 就会将该文件复制一份，正因为 Git 的这个特性，所以 Git 仓库很容易就变得非常大；为了高效，如果文件没有修改，那么 Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p>
<p>Git 有三个区，分别为：仓库、工作目录、暂存区。基本的 Git 流程为：1）在工作目录中修改文件；2）暂存文件，将文件的快照放入暂存区域；3）提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。那么相应的 Git 就有三种状态：已提交（committed）、已修改（modified）和已暂存（staged），你的文件可能处于其中之一。</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9hcmVhcy5wbmc?x-oss-process=image/format,png" alt="image"></figure>
<h4 id="git-基础">Git 基础</h4>
<p>工作目录中的文件不外乎处于两种状态：已跟踪或未跟踪。已跟踪是指那些纳入了版本控制的文件，在上一次快照中有它们的记录；工作目录中除了已跟踪文件以外的所有文件都属于未跟踪文件，们既不存在于上次快照的记录中，也没有放入暂存区。</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9saWZlY3ljbGUucG5n?x-oss-process=image/format,png" alt="image"></figure>
<h6 id="查看文件状态">查看文件状态</h6>
<p>如果需要查看哪些文件处于什么状态，可以使用<code>git status</code>命令，这个命令显示的信息十分详细，如果你喜欢简洁一点的信息，那么可以在其后添加一个<code>-s</code>，其报告格式类似于下面这样。</p>
<pre><code class="language-shell">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre>
<p><code>??</code>表示新添加的未跟踪文件；修改过的文件前面有<code>M</code>标记，右边的表示还没有放入暂存区，左边的表示已经放入暂存区了。当然你可能不希望每个文件都出现在未跟踪列表中，比如编译过程临时创建的文件、日志文件等等，所以可以通过创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式，它支持标准的<code>glob</code>模式匹配（shell 所使用的简化了的正则表达式），在 <a href="https://github.com/github/gitignore">gitignore</a> 中有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表。</p>
<p><code>git status</code>对于具体修改显示的过于模糊，如果想查看具体修改了什么地方，可以使用<code>git diff</code>命令，比如<code>git diff README.md</code>。需要注意的是<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动，如果需要查看已经暂存起来的变化，则要加上<code>--staged</code>或者<code>--cached</code>，比如<code>git diff --cached README.md</code>。</p>
<h6 id="删除文件">删除文件</h6>
<p>当然我们不可避免的需要删除某个文件，如果你仅仅是简单的从工作目录中手工删除文件，那它并没有真正的从 Git 中删除，Git 会将这次删除识别为一次改动。更好的方式是使用<code>git rm</code>命令来完成删除文件的工作，比如<code>git rm README.md</code>就会从已跟踪文件中删除，并且连带从工作目录中删除指定文件。</p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。这时就需要使用<code>--cached</code>选项了，比如<code>git rm --cached README</code>。</p>
<h6 id="查看历史">查看历史</h6>
<p>我们或许因为某种原因需要回顾一下提交历史，这时<code>git log</code>就派上用场了，默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code>提供的选项很多，更详细的内容可以查看 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">Git 基础 - 查看提交历史</a>。除了不带选项的命令，我个人更常用的命令还有另外两个，分别为：<code>git log --pretty=oneline</code>它将每个提交放在一行显示，在查看的提交数很大时非常有用；<code>git log --graph</code>或者<code>git log --pretty=oneline --graph</code>用于显示 ASCII 图形表示的分支合并历史。</p>
<h6 id="撤销操作">撤销操作</h6>
<p>在任何一个阶段我们都可能有想要撤销的操作，我们只需要掌握几个基本的撤销操作就能够应对日常的工作了。</p>
<p>第一种情况：取消上一次提交。有时候当我们提交完之后才发现漏掉了几个文件没有添加，或者是提交信息写错了，此时可以使用带<code>--amend</code>选项的提交命令尝试重新提交，即<code>git commit --amend</code>。这个命令会将暂存区的文件全部提交，如果自上次提交以来你还没一做任何修改（比如，在上次提交后马上执行了此命令），那么快照将会保持不变，而所修改的只是提交信息。</p>
<p>第二种情况：取消暂存的文件。假设你修改了两个文件并且想要将它们作为两次独立提交，但是却不小心输入了<code>git add *</code>暂存了它们两个，如何取消其中一个暂存呢？其实在运行<code>git status</code>时已经给出提示了。</p>
<pre><code class="language-shell">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md
</code></pre>
<p>所以如果我们想要取消<code>CONTRIBUTING.md</code>的暂存，那么就可以用<code>git reset HEAD CONTRIBUTING.md</code>命令来完成。</p>
<p>第三种情况：撤销对文件的修改。有时候我们可能并不想保留对某个（若干）文件的修改，<code>git status</code>也给出了详细的提示，告诉我们如何将文件还原成上次提交时的样子，即<code>git checkout -- &lt;file&gt;</code>，比如输入命令<code>git checkout -- CONTRIBUTING.md</code>，就会将<code>CONTRIBUTING.md</code>重置到上一次提交时的样子。</p>
<p>需要注意的是<code>git checkout -- &lt;file&gt;</code>是一个比较危险的命令，因为它仅仅是拷贝了另一个文件来覆盖当前文件，所以你对那个文件的所有修改都会消失，而且不可恢复。</p>
<h6 id="远程仓库">远程仓库</h6>
<p>前面我们都是在讲本地操作，远程仓库的使用是必不可少的技能。可以使用<code>git remote</code>命令查看每一个远程服务器的简写，对于已经克隆的仓库，它至少会包含一个<code>origin</code>，这是 Git 给克隆仓库服务器取的默认名字，它和其它服务器并没有什么区别，只是很少人会去修改这个默认名字而已。</p>
<p>如果想要给一个远程仓库重新取一个简写名，那么可以运行<code>git remote rename</code>来完成，比如<code>git remote rename pb paul</code>就是将<code>pb</code>重命名为<code>paul</code>。值得注意的是这样同样也会修改你的远程分支名字，那些过去引用<code>pb/master</code>的现在全引用<code>paul/master</code>。</p>
<p>当想要将自己的成果分享给他人时，就需要将其推送到上游，使用<code>git push [remote-name] [branch-name]</code>即可，比如你想要将<code>master</code>分支推送到<code>origin</code>服务器时，就可以运行<code>git push origin master</code>。</p>
<p>除了分享自己的成果，我们也需要获取他人的成果，即从仓库拉取自己没有的信息，比如<code>git fetch origin</code>，需要注意的是<code>git fetch</code>命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作，所以你还需要<code>git merge</code>来合并分支，实际上有一个<code>git pull</code>命令可以帮我们把这两个步骤都做了，你可以简单的将<code>git pull</code>理解为<code>git fetch</code>后面紧接着一个<code>git merge</code>。</p>
<h4 id="分支管理">分支管理</h4>
<p>Git 的分支模型是它的必杀技特性，它处理分支的方式是难以置信的轻量，创建分支几乎是在一瞬间完成，而且在不同分支间的切换也非常的便捷，要理解 Git 的分支，我们必须要再次回顾 Git 是如何保存数据的。</p>
<p>下图是我们的一个工作流，可以看到所谓的分支实际上就是一个可以移动的指针而已，<code>master</code>、<code>v1.0</code>都仅仅是一个指针，而创建分支、切换分支等操作也都只是对指针的操作，因此就不奇怪为什么 Git 这么快了。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9icmFuY2gtYW5kLWhpc3RvcnkucG5n?x-oss-process=image/format,png" alt="image"></p>
<p>那么 Git 又是如何知道当前在哪一个分支上呢？它仅仅是用了一个名为<code>HEAD</code>的特殊指针，你可以将<code>HEAD</code>想象为当前分支的别名，<code>HEAD</code>指向哪个分支，就表示当前处于哪个分支。</p>
<h6 id="分支创建与切换">分支创建与切换</h6>
<p>我们可以使用<code>git branch [branch-name]</code>来创建一个新的分支，比如<code>git branch testing</code>；如果使用不带选项的<code>git branch</code>，那么它会列出当前所有的分支，这里需要注意的是<code>master</code>分支也不是特殊分支，它是运行<code>git init</code>时自动创建的默认分支，因为大家都懒得去改它，所以它就好像变得特殊了一样。</p>
<p><code>git branch [branch-name]</code>只是创建了一个新分支，并不会切换到这个分支上面去，分支的切换说白了就是移动<code>HEAD</code>指针，我们只需要使用<code>git checkout testing</code>就可以切换到<code>testing</code>分支上去了。</p>
<p>当然我们可以使用<code>git checkout -b [branch-name]</code>来创建一个分支并同时切换到这个分支，把这个命令与<code>git commit -a -m</code>来对比，你就会发现它们的类似之处。</p>
<h6 id="分支的合并与删除">分支的合并与删除</h6>
<p>当我们零时在一个新分支上解决了问题后，需要将其合并到<code>master</code>分支，只需要切换到<code>master</code>再运行<code>git merge</code>命令即可，Git 会自动找到这两个分支的共同祖先，然后做一个简单的三方合并。</p>
<p>当然理想情况下是直接合并成功，但是不免会遇到合并冲突的情况，一旦遇到冲突了，Git 会像下面这样来标记冲突内容，你需要做的是选择由<code>=======</code>分割的令部分的其中一个或者自行合并，当<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行被完全删除了，你需要对每个文件使用<code>git add</code>将其标记为冲突已解决。</p>
<pre><code class="language-html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id=&quot;footer&quot;&gt;
 please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; testing:index.html
</code></pre>
<p>当合并完分支后，之前的分支一般就不会再要了，这时你可以运行<code>git branch -d [branch-name]</code>来删除指定分支，比如使用<code>git branch -d testing</code>来删除<code>testing</code>分支。</p>
<h6 id="远程分支">远程分支</h6>
<p>远程分支以<code>(remote)/(branch)</code>的形式来命名。如下图所示，如果你克隆一个仓库下来，那么这个仓库除了会有一个本地的分支指针，还会有一个远程分支指针。如果你在本地的<code>master</code>分支做了一些工作，但是你并没有与<code>origin</code>服务器连接，那么你的<code>origin/master</code>指针就不会移动。</p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9yZW1vdGUtYnJhbmNoZXMtMS5wbmc?x-oss-process=image/format,png" alt="image"></figure>
<p>在这之前我们已经讲过通过推送分享自己的成果，在运行<code>git push origin master</code>命令时，Git 会自动的将<code>master</code>分支名字展开为<code>refs/heads/master:refs/heads/master</code>，即意味着<strong>推送本地的<code>master</code>分支来更新远程仓库上的<code>master</code>分支</strong>，所以你也可以运行<code>git push origin master:testing</code>来做类似的事，如果远程仓库没有<code>testing</code>分支，那它会自己创建一个新的<code>testing</code>分支。</p>
<p>我们肯定需要创建一个跟踪远程仓库的其它分支，最简单的就是运行<code>git checkout -b [new-branch] [remote-name]/[branch]</code>，该命令会以远端<code>[branch]</code>分支的内容来创建本地的<code>[new-branch]</code>分支，Git 也对该命令做了一个简化，<code>git checkout --track [remote-name]/[branch]</code>，该命令就会在本地创建一个<code>[branch]</code>分支用于跟踪远端的<code>[branch]</code>分支。</p>
<p>当然，我们还需要了解一个删除远程分支的命令<code>git push origin --delete [branch]</code>，需要注意的是这个命令基本上只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h4 id="git-常用命令">Git 常用命令</h4>
<p>挑了一些比较重要 Git 命令，我把个人常用的命令使用代码块标记出来了。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>将一个目录转变成一个 Git 仓库</td>
</tr>
<tr>
<td>git clone</td>
<td>从远程克隆一个仓库到本地，它是<a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">多个命令的组合</a>，</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>将内容从工作目录添加到暂存区</td>
</tr>
<tr>
<td><code>git commit</code></td>
<td>将暂存区文件在数据库中创建一个快照，然后将分支指针移到其上</td>
</tr>
<tr>
<td><code>git commit -a -m [msg]</code></td>
<td><code>git add``和</code>git commit```的组合</td>
</tr>
<tr>
<td>git status</td>
<td>展示工作区及暂存区域中不同状态的文件</td>
</tr>
<tr>
<td><code>git status -s</code></td>
<td>比<code>git status</code>展示的内容更加简洁</td>
</tr>
<tr>
<td><code>git diff</code></td>
<td>对比工作目录文件和暂存区快照之间的差异</td>
</tr>
<tr>
<td>git diff --cached</td>
<td>对比已暂存的差异</td>
</tr>
<tr>
<td><code>git reset</code></td>
<td>根据你传递给动作的参数来执行撤销操作</td>
</tr>
<tr>
<td><code>git rm</code></td>
<td>从工作区，或者暂存区移除文件</td>
</tr>
<tr>
<td>git clean</td>
<td>从工作区中移除不想要的文件的命令</td>
</tr>
<tr>
<td><code>git checkout</code></td>
<td>切换分支，或者检出内容到工作目录</td>
</tr>
<tr>
<td>git branch</td>
<td>列出你所有的分支、创建新分支、删除分支及重命名分支</td>
</tr>
<tr>
<td><code>git checkout -b [branch]</code></td>
<td>创建新分支并切换到该分支</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>展示历史记录</td>
</tr>
<tr>
<td><code>git log --pretty=oneline</code></td>
<td>简洁版历史记录</td>
</tr>
<tr>
<td><code>git merge</code></td>
<td>合并一个或者多个分支到已检出的分支中</td>
</tr>
<tr>
<td><code>git stash</code></td>
<td>临时地保存一些还没有提交的工作</td>
</tr>
<tr>
<td><code>git pull</code></td>
<td>git fetch 和 git merge 命令的组合体</td>
</tr>
<tr>
<td><code>git push</code></td>
<td>将本地工作内容推送到远程仓库</td>
</tr>
<tr>
<td><code>git push origin local_branch:remote_branch</code></td>
<td>比<code>git push</code>更加详细的推送</td>
</tr>
<tr>
<td><code>git checkout --track [remote-name]/[branch]</code></td>
<td>在本地创建一个分支用于跟踪远程同名分支</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考内容：<a href="https://git-scm.com/book/zh/v2">Pro Git book</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bootstrap-table 合并相同单元格]]></title>
        <id>https://mengxiaoxu.github.io//post/MqqlYHD78</id>
        <link href="https://mengxiaoxu.github.io//post/MqqlYHD78">
        </link>
        <updated>2019-01-26T12:22:05.000Z</updated>
        <content type="html"><![CDATA[<p>Bootstrap-table 官方提供了合并单元格方法 <a href="https://bootstrap-table.com/docs/api/methods/#mergecells">mergeCells</a>，它根据四个参数可以合并任意个单元格，我们要做的只是告诉它怎么合并。</p>
<p>要合并同一列相同的单元格，无非两种办法，一种是一边遍历一边合并，遍历完了再合并。这里采用第二种办法，这里不需要遍历所有数据，因为用户只能看到当前页的数据，所以只遍历当前页的数据更省时间。</p>
<p>下面是我实现的获取合并信息算法，最终返回的是一个哈希表，比如下面的这个表格，如果要对「性别」这一列进行合并，很明显前面两个“男”需要合并成一个单元格，再去看下 Bootstrap-table 提供的 API，它需要的是从哪个单元格开始，合并多少个单元格，也就是它需要的是两个数值类型的参数。</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>男</td>
<td>23</td>
</tr>
<tr>
<td>李四</td>
<td>男</td>
<td>19</td>
</tr>
<tr>
<td>王二</td>
<td>女</td>
<td>20</td>
</tr>
<tr>
<td>麻子</td>
<td>男</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>所以我把哈希表设置为，键存的是索引，值存的是从这个索引开始后面连续有多少个和它一样的单元格，那么上述表格性别这一列所得到的合并信息哈希表就为：</p>
<pre><code>{
    0: 2,
    2: 1,
    3: 1
}
</code></pre>
<p>下面算法很简单，使用两个指针遍历指定的列，如果两个指针所指向的数据相同，那么就将键所对应的值进行加一操作，整个方法只会对该列数据遍历一边，所以时间复杂度为 O(n)。</p>
<pre><code class="language-typescript">let getMergeMap = function (data, index: number) {
    let preMergeMap = {};
    // 第 0 项为表头，索引从 2 开始为了防止数组越界
    for (let i = 2; i &lt; data.length; i++) {
        let preText = $(data[i-1]).find('td')[index].innerText;
        let curText = $(data[i]).find('td')[index].innerText;
        let key = i - 2;
        preMergeMap[key] = 1;
        while ((preText == curText) &amp;&amp; (i &lt; data.length-1)) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
            i++;
            preText = $(data[i - 1]).find('td')[index].innerText;
            curText = $(data[i]).find('td')[index].innerText;
        }
        // while循环跳出后，数组最后一项没有判断
        if (preText == curText) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
        }
    }
    return preMergeMap;
}
</code></pre>
<p>上述算法得到了单列数据的合并信息，下一步就是按照这个信息进行相同单元格的合并了，因此封装了下面的方法按照指定哈希表进行合并。</p>
<pre><code class="language-typescript">let mergeCells = function (preMergeMap: Object, target, fieldName: string) {
    for (let prop in preMergeMap) {
        let count = preMergeMap[prop];
        target.bootstrapTable('mergeCells', { index: parseInt(prop), field: fieldName, rowspan: count });
    }
}
</code></pre>
<p>到目前为止，我们实现的都只是对单列数据进行合并，要实现对多列数据进行合并，那么只需要对所有列都进行相同的操作即可。</p>
<pre><code class="language-typescript">export let mergeCellsByFields = function (data: Object[], target, fields) {
    for (let i = 0; i &lt; fields.length; i++) {
        let field = fields[i];
        // 保证 field 与 i 是相对应的
        let preMergeMap = getMergeMap(data, i);
        let table = target.bootstrapTable();
        mergeCells(preMergeMap, table, field);
    }
}
</code></pre>
<p>因为我在程序中做了一点处理，保证了<code>fields</code>中每个值得索引与对应表头的索引是一样的，因此不需要额外传入索引信息。简单来说就是我所实现的表格会根据<code>fields</code>的顺序，实现列之间的动态排序。你需要注意的是这一点很可能和你不一样。</p>
<p>到现在已经能够合并所有的列了，查看 Bootstrap-table 的配置信息发现，它有个属性是 <a href="https://bootstrap-table.com/docs/api/events/#onpostbody">onPostBody</a> 它会在 table body 加载完成是触发，所以把这个属性配置成我们的合并单元格方法即可。</p>
<pre><code class="language-typescript">// groups 为要合并的哪些列
onPostBody: function () {
    mergeCellsByFields($('#table' + ' tr'), $('#table'), groups);
}
</code></pre>
<p>再说一点不太相关的，我实现的是让用户可以自己选可以合并多少列，即用了一个可多选的下拉列表框供用户选择，根据用户选择的数量去合并，所以传入了一个<code>groups</code>参数。</p>
<p>最后推荐一个排序插件 <a href="https://github.com/Teun/thenBy.js">thenBy</a>，你可以用它进行多字段排序，比如用在合并相同单元格的场景，在绘制表格前先对数据进行排序，那么最后合并的结果就是把所有相同的数据聚合到一起了，并且还将它们合并到一起了，起到了一个隐形的过滤查询功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-01-23）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-01-23</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-01-23">
        </link>
        <updated>2019-01-23T14:00:35.000Z</updated>
        <content type="html"><![CDATA[<p>前段时间的刷屏文章《甘柴劣火》被曝出是洗稿文章，微信官方取消了该文章的原创标识和赞赏；再往前追溯一段时间，公众号「差评」也因为洗稿行为，眼看就要到手的 3000 万投资飞走了。国内渐渐加大了版权保护的力度，但是读者从来不会关心是否原创，所以「兽爷」式文章总是能撩到大众的 G 点。</p>
<p>被微信平台邀请为洗稿合议小组成员后，参与了一篇存在洗稿争议的评审，体会到了保护原创的困难，不知道把存在洗稿争议的两篇文章发给高考阅卷老师看会是怎样的结果，在保护原创文章方面，微信平台应该是国内做的最好的。</p>
<p>微信的「看一看」里面都快变成营销圈了，干脆去掉了这个入口，自微信改版之后，我点「好看」都变的异常谨慎了，以前给文章点赞只是认同作者的一个行为，而现在点赞也变成社交行为了，所以我也收起了点赞的食指。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>网友推荐了一个小视频，虽然只有简短的几分钟，但是很有意思，讲的是历史的错觉。（此部分知识来源于网络）</p>
<p>虽然刘邦和秦始皇同为两个朝代的开创者，但秦始皇只比刘邦大 3 岁，而且刘邦是在秦朝建立之前的周朝出生的。</p>
<p>在历史课本上，乾隆属于古代史部分，华盛顿属于现代史部分，但实际上他俩是同一年出生的，历史课本的编排让我们感觉他俩像隔了很久一样。</p>
<p>都清楚毛泽东是离我们很近的人物，但是毛泽东比末代皇帝傅仪大了 13 岁。</p>
<p>不知道你又没有觉得前苏联是离我们很远的、历史上的国家，如果你这样觉得，那告诉你前苏联总统戈尔巴乔夫现在还活着，会不会觉得更加诧异。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>最近熬夜看完了《大江大河》第一部，很不错的电视剧，讲述从改革开放开始的中国，通过两个主人公的经历来展现国营企业、集体企业、个体户的发展。剧中的大多数场景我居然都经历过，可能我是一个假的 90 后吧。</p>
<p>导演很注重细节，没有冗余的啰嗦，有两个小细节记忆深刻。第一个是宋运辉父亲用“吹火筒”（我家那块是这么叫）助燃，小时候我还帮爸爸做过一个“吹火筒”；第二个是杨巡和他母亲给雷东宝写借条时，格式是很标准的，借条的格式是小学六年级时学习常用应用文格式时记下的。</p>
<p>电视剧中多次提到长毛兔，小时候家里也养过长毛兔，不过我那时候调皮，兔子的耳朵又大又好玩，我就牵着兔子的耳朵对着它大吼，兔子总是会发飙一样快速跑一段距离，但是家里最后两只长毛兔也就被我这么吼到离家出走了，自那以后家里就没有兔子了。</p>
<p>我喜欢听别人讲述历史，最近参加了几次校友活动，最大的师兄师姐是 80 级的，听他们讲述那个时代的故事很有趣，《大江大河》是不错的了解历史的渠道，唯一的缺点就是电视剧时间太长了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>如果在某件事情上的观点和关系很亲近的人不合，要想说服他不一定非得苦口婆心给他讲，换一条路可能效果更好。比如我师傅在给他娃起名的时候和媳妇发生了分歧，男士肯定是争不过女士的，所以师傅每次见到七大姑八大姨，就给他们说这个名字从姓名学、风水等等方面存在哪些问题，这些七大姑八大姨自然而然就会去说媳妇，最终媳妇主动提出来要给娃改名字。</p>
<p>要和对象、朋友处好关系，你也不用天天告诉她对她有多好，你观察一下对方周围的朋友就可以了。比如你对象闺蜜的男朋友会陪她到 11 点，那你只需要陪她到 12 点或者 11：30 就可以了，对象的闺蜜会拿你和她自己的男朋友作对比，自然就会在你对象面前念叨你的各种优点，中国好男人这个形象会在你对象心里越来越明显，她也会越来越觉得自己是捡了个宝，也就是你要给对方足够炫耀的资本。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>最近好几个知识星球到期了，我也算比较早接触知识付费的人群了，有一些星球早就停更了，挑了几个比较好的续费了，刘大、曹大、冯大、池大，同时新加入了方军老师的星球，方老师送了本书，再让我免费加入了一个价值 998 元的星球。</p>
<p>除了在得到上买专栏，我还开了喜马拉雅的会员，买了个喜马拉雅的智能音箱，发现真好玩，用它听书很不错，不是机器阅读的，是真人阅读的，体验很棒。</p>
<p>想说的是，我遇到很多人吃一顿饭花几百，买个课程花几百就心疼的要死，我比大多数人都穷（信用卡都快还不起了，哈哈），但是我敢花大手笔去让自己成长。后来我就不劝朋友花钱买课程了，那种让人觉得我骗他钱的感觉很不好受。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>释压能力很重要，最近也遇到好几个被压力给弄崩溃了的人，我承认年轻人压力是挺大，但是没必要再给自己无端增加压力，像我这种活的单纯自在、没心没肺的人就最乐了，换个角度也是没追求的表现。</p>
<p>一个压崩溃了的同学总是很相信我，但是前前后后快一年了，给他说了很多东西，最近发现我自己都是白说了，还说我说话不中听，他骂我而我没有骂他，而那同学言语间倒是给了我一种感觉，我的教养好，所以我不应该骂人。</p>
<p>因此我得出的结论是，同样一句话给不同的人讲，效果是不一样的，绝大部分东西是他自己内心的反射，你也不要试图去改变他什么，是没什么办法改变别人的。这里推荐一篇子柳老师的文章<a href="https://mp.weixin.qq.com/s/yZJPQ8JpNbuwefYO184mAg">天下谁人不焦虑？</a></p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>之前在<a href="https://mp.weixin.qq.com/s/TnbKdM79pO_06oz1cfPtAQ">这是一篇不正经文章</a>中贴了一张网图，前几天看到很标准的现实版，照片是在我住的地方偷摸拍的。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569506722099.JPG" alt=""></figure>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1569506728053.JPG" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大学生书单推荐]]></title>
        <id>https://mengxiaoxu.github.io//post/da-xue-sheng-shu-dan-tui-jian</id>
        <link href="https://mengxiaoxu.github.io//post/da-xue-sheng-shu-dan-tui-jian">
        </link>
        <updated>2018-12-30T14:52:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>此篇文章由刘小绪同学首发于知识星球</p>
</blockquote>
<p>首先推荐李笑来的《把时间当作朋友》和《财富自由之路》，这两本书写的真不错，虽然李笑来的人设倒下了，但是不影响这两本书的质量，也不要因为一次人设倒下就全盘否定一个人。</p>
<p>季羡林的书值得一读，读几本季老先生的文集就可以了，从文字里面去感受季老求真务实的态度，什么才是做学术的态度，大家之所以为大家，不仅仅是因为天资聪慧，还有为人处世。</p>
<p>《小狗钱钱》、《24 堂财富课————与女儿谈创业》、《穷爸爸富爸爸》、《好好赚钱》中可以选一本阅读，大学只交了我们生存的技能，并没有教我们如何理财，而这又是每个人不得不面对的问题，这几本入门书籍，可以帮助您建立财富理念。</p>
<p>《浪潮之巅》、《数学之美》、《大学之路》等等，吴军博士的书籍都值得一看，晦涩难懂的道理在吴军博士的文字中变的简单了，感受一下心态、格局等的提升会给人生带来多么重要的改变，我个人目前还没有读完。</p>
<p>《编码：隐藏在计算机软硬件背后的语言》，看下微软大师是如何用故事来给您造出一台计算机的，计算机基础不再是简单的机械背诵，而是在故事中理解记忆。</p>
<p>《深入理解计算机系统》也应该看一看，现在的技术日新月异，但是纵观这么多年的技术发展，最基本的原理是不变的，在这个瞬息万变的时代，只有掌握了最核心根本的原理，才能从容应对不同的变化，高级程序员必读经典。</p>
<p>像《长乐路》、《明朝那些事儿》一类的书籍是可以读读的，应该去了解一下历史的细节，你所看到的不一定是真实的，光芒的背后是另一片黑暗，历史是有规律的，我们的生活可以在历史中找到影子。</p>
<p>《人类简史》、《人性的弱点》、《心灵七游戏》等心理、哲学类书籍选几本读读，哲学是所有学科的抽象，到一个新的高度看看世界，提高自己的情商，让整个世界都为您张开拥抱的双臂。</p>
<p>读不动名著小说，可以读《偷影子的人》，每个人都有相似的童年，只是大部分人都不敢说出来而已，主人公就好像在经历自己曾经经历过的生活一样，从没有想过普普通通的童年居然能被描写的如此动情。《月亮与六便士》也是不错的选择。</p>
<p>多阅读高于自己的作品，远离精神毒品，互联网时代的阅读不再限于书籍了，良心大佬的博客也是一个不错的选择，只有阅读高于自己的作品才能获得成长，少刷抖音、微博、知乎一类的产品，里面是有一些有趣的人生，但是一刷就是几个小时，太浪费时间。</p>
<p>「一席」上的大部分演讲是值得听的，让您对中国社会有一个更好的了解；「TED」、「网易公开课」上国外高校的视频可以多看看，讲的真心不错；国内出观众、大部分二流学校的演讲能不去就不去，还不如把这种时间拿去睡睡觉，补充补充精力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回忆高中网校生活]]></title>
        <id>https://mengxiaoxu.github.io//post/5BDtFnlOc</id>
        <link href="https://mengxiaoxu.github.io//post/5BDtFnlOc">
        </link>
        <updated>2018-12-15T13:33:05.000Z</updated>
        <content type="html"><![CDATA[<p>周三刷星球时看到一条关于成都七中网校的信息，没想到周四就被成都七中网校给刷屏了，看到文章里面的描写，感悟颇多，网校陪伴了自己三年，<a href="https://mp.weixin.qq.com/s/hBKC4krTLl5rR4npMQf_fA">一个诗意的女孩——西凉忆</a>就是因为网校结识的。</p>
<p>我是 12 年入学高中，那一年学校也刚和成都七中开通网校，因此我属于学校第一届全程使用网校资源的学生。</p>
<p>记得刚入学时，对这种教学方式并不适应。不止学生不适应，老师也不适应，政治课老师就不使用直播课程，而是选择自己给我们讲。不过后来年级组出了硬性规定，特优班必须使用直播课程。</p>
<p>就像<a href="http://m.cyol.com/yuanchuang/2018-12/12/content_17849270.htm?from=timeline&amp;isappinstalled=0">教育的水平线</a>中描述的一样，我们被称为远端学生，大家都是第一次使用这样的系统，七中老师估计也很好奇，都在第一节课或者第二节课上抽了远端同学回答问题，后来就很少有抽远端同学回答问题了，估计是因为远程视频效果不好还浪费时间。</p>
<p>成都七中本部的学生上课很有激情，一到讨论等环节，虽然很吵但是却很有秩序，而我们这边基本是大家都盯着屏幕，等待对方讨论结束。</p>
<p>对方学生的基础我们是没办法比的，大部分能够完全以纯英文交流，而我们远端学生大部分都只能说出“My name is ..., I'm from ..., I like ...”，英语的差距是最大的。我自己是主动找了英语老师谈话，和她做了一个约定，每周我写一篇作文交给她，她帮我批改，这样坚持了两年。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569418431870.jpg" alt=""></figure>
<p>让我感受到最大差距的是，一个中学有自己的电视台，经常会有像《汉语桥》冠军一类的人物前来演讲，美国第一夫人米歇尔也到七中演讲（那是总统还是奥巴马），作为远端学生有幸蹭了一场名人演讲；七中学生的寒暑假是参加联合国模拟大会、到哈佛做了简短的交流、到华盛顿旅行......</p>
<p>而大部分远端的学生，要么是参加学校组织的补课，要么是在家干农活，基本连县城都没有走出去过，和七中相比，完全是天壤之别。</p>
<p>现在我依旧还清晰的记得七中的几个老师，做 PPT 从来没有背景图的数学老师，语速超快但又吐字清晰的化学老师，说着一口标准川普的物理老师，有着一头蓬松金黄卷发的历史老师（男）......去看这些老师的背景，也都是名校出身，武汉大学、华中师大等等。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569418441535.jpg" alt=""></figure>
<p>有一个细节记得很清楚，在一堂数学课中有个题目，题目具体内容忘了，只记得是要求算新华中学的一本录取率，最后的答案是在 74% 左右，这个数字在我眼里很高了，但是那一刻并没有觉得有什么，毕竟这是书上的学校嘛！！</p>
<p>想不到的是，下一秒那个做 PPT 从来没有背景图的数学老师说了句：“这个就比较低了啊，我们学校考的很差的时候才是百分之七十多的录取率”。一下让我震惊了，因为我在心里算过自己学校的一本录取率，在此之前不到 10%，而且我所在高中在所有远端学校中还是比较靠前的。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569418454783.jpg" alt=""></figure>
<p>让我意外的是，七中的老师原来也会骂人、打人，即使打的很轻；学生没完成作业，也会被罚拿个小凳子到教室外面补作业；在全国禁止补课的规定之下，七中也会给高三的学生补课，当然我们也同步补课了。</p>
<p>我无法构想如果三年没有使用网校资源会是神马结果，如果仅仅是看数据的话，一本率是按倍数翻的，12 年开始使用网校资源后，学校有了第一个清华，13 年又添了一个清华。我属于 14 届，这届没有清华，最好的是浙大，我进了个普普通通的哈尔滨工程大学。据说 15 届又出了清华。</p>
<p>我所在的高中也被央视作为典型案例探讨农村高考。无疑能上央视，那这个学校在当地乃至全国同等水平的学校中是很成功的。</p>
<p>无疑这种生活给每个同学都留下了难忘的记忆，如果哪位同学加了七中本部直播班级某位同学的 QQ（那时没有人用微信），那能吹好几天牛逼，七中人在我们眼里就像明星一样。</p>
<p>我们当地 14 届县状元高考分数是 635 分，七中本部平均分是 616 分，这差距至今都让我目瞪口呆。前段时间曹大在星球发起了一个作业：十年后的期望目标。我所提交的作业中写了句，如果有能力，希望能给乡村学校带去一点教育资源。</p>
<p>我并不认为穷是光荣的事情，但在很多农村人眼里穷是一种资本，一种获取国家福利的资本，如果某次补助没有评到自己头上，那得记恨村长一辈子。我认为这才是造成农村孩子和城里孩子有巨大差距的原因，如果孩子没有从这种思维走出来，那一辈子也不可能有什么大的成就。</p>
<p>没想到自己都大学毕业了，却看到成都七中的网校被刷屏了。毫无疑问，这是一件极为有意义的事情，这种内容就应该被刷屏，愿七中和远端学校都越办越好。</p>
<blockquote>
<p>文中照片取自于同学 QQ 空间，不知道这么把几位老师放出来有没有侵权。记得我原来还有英语老师 Spring 的 QQ，高中时向他请教过自己的英语问题，可能后来 Spring 把我删了 =_=，反正是没了。</p>
</blockquote>
]]></content>
    </entry>
</feed>