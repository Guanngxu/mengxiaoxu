<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-12-15T14:17:58.002Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[用户关注而程序员不关注的事]]></title>
        <id>https://mengxiaoxu.github.io//post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi</id>
        <link href="https://mengxiaoxu.github.io//post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">
        </link>
        <updated>2019-12-15T13:04:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="https://instadeq.com/blog/posts/things-end-users-care-about-but-programmers-dont/">Things end users care about but programmers don't</a></p>
</blockquote>
<h3 id="色彩">色彩</h3>
<ul>
<li>改变元素的颜色</li>
<li>漂亮的默认调色板</li>
<li>使用我喜欢的调色板</li>
<li>导入/导出颜色主题</li>
<li>一些标识符、关键字等应该始终具有特定的颜色</li>
<li>同一事物在任何地方都应颜色一致</li>
<li>具有适宜的对比度</li>
<li>切换深色/浅色背景时，自动调整对比度以适应当前背景</li>
<li>自动生成大量颜色
<ul>
<li>所有的颜色都属于同一个系列</li>
<li>不生成不易辨别的颜色</li>
<li>相似的颜色不要放在一起</li>
<li>不要将背景色用在元素上</li>
</ul>
</li>
</ul>
<h3 id="格式">格式</h3>
<ul>
<li>将基本格式应用于文本</li>
<li>文本对齐</li>
<li>使用我在 office 中使用的字体</li>
<li>类似于 Word 中的 WYSIWYG 编辑器</li>
<li>数字对齐</li>
<li>数字/日期自动根据语言环境设置格式</li>
<li>小数设置为右边有固定小数位</li>
<li>在任何地方都没有奇怪的 .0000004 格式</li>
<li>整数后面不应该有 .00</li>
<li>支持 Emoji</li>
</ul>
<h3 id="主题">主题</h3>
<ul>
<li>深色主题</li>
<li>我的主题</li>
<li>公司品牌</li>
<li>将 logo 放在合适的位置</li>
<li>在登录页面有 logo</li>
</ul>
<h3 id="系统整合">系统整合</h3>
<ul>
<li>与账户系统整合</li>
<li>使用 Active Directory 中的账户/权限</li>
<li>导入 Excel/CSV</li>
<li>从电子邮件附件导入</li>
<li>导出为 Excel</li>
<li>导出为 PDF/图像</li>
<li>录制短片
<ul>
<li>制作 gif</li>
</ul>
</li>
<li>作为邮件发送
<ul>
<li>定期发送邮件</li>
<li>以 PDF 附件形式发送邮件</li>
</ul>
</li>
<li>导入/附加图像
<ul>
<li>上传前裁剪</li>
<li>压缩</li>
<li>变更格式</li>
</ul>
</li>
<li>使用图像作为背景，并且以正确的方式拉伸</li>
<li>APP 上的通知
<ul>
<li>在手机的应用程序上</li>
<li>通过短信</li>
<li>在我们的系统上</li>
<li>在我的邮箱</li>
</ul>
</li>
</ul>
<h3 id="用户体验">用户体验</h3>
<ul>
<li>良好的错误处理</li>
<li>简洁的错误描述
<ul>
<li>翻译错误信息</li>
</ul>
</li>
<li>告诉我如何做才能解决错误</li>
<li>在我点击前告诉我会发生什么</li>
<li>支持手势和鼠标</li>
<li>快捷键
<ul>
<li>支持自定义</li>
</ul>
</li>
<li>任何时间都可以撤销</li>
<li>支持多次撤销</li>
<li>恢复已被删除的东西</li>
<li>在删除前给提示</li>
<li>复制与粘贴</li>
<li>模板</li>
<li>详细的用户指南，并且每一步都有截图与重点标注
<ul>
<li>在视频中</li>
<li>截图随着产品的发布保持更新</li>
<li>与我正在使用的版本同步</li>
<li>适应我的自定义设置</li>
</ul>
</li>
<li>最新的详细文档</li>
<li>自动翻译为我的语言（国际化）</li>
<li>任何地方都支持排序
<ul>
<li>自然排序</li>
<li>根据多个条件排序</li>
</ul>
</li>
<li>任何地方都支持过滤器
<ul>
<li>模糊匹配</li>
<li>大小写敏感/不敏感过滤</li>
<li>按多个复杂条件筛选</li>
</ul>
</li>
<li>记录历史操作，在我删除时给出警告</li>
<li>可选的级联删除</li>
<li>在每个平台本机都提供简单的日期选择器</li>
<li>对列表/已经项排序（按标签）
<ul>
<li>自然排序</li>
</ul>
</li>
<li>带有过滤功能的下拉菜单</li>
<li>预览</li>
<li>一致的按钮排序/标签</li>
<li>一致的大小写</li>
<li>慢速操作显示进度条</li>
<li>缓慢操作时 UI 可以快速响应</li>
<li>响应缓慢时禁用按钮</li>
<li>处理应单击元素的双击事件</li>
<li>明确指示可以单击的内容</li>
</ul>
<h3 id="兼容性">兼容性</h3>
<ul>
<li>可在其它系统部署</li>
<li>可在旧的/不支持的版本上部署</li>
<li>在我拥有的任何系统上都可部署</li>
<li>不需要网络就可部署</li>
<li>处理 Excel, CSV, JSON, XML
<ul>
<li>处理以上所有格式不正确的版本</li>
</ul>
</li>
<li>处理（猜测）没有时区的日期</li>
<li>处理模糊的/被更改的日期格式</li>
<li>可与过时的软件混合</li>
<li>可以在旧安卓的浏览器工作</li>
<li>编码
<ul>
<li>处理具有未知和可变编码的输入</li>
</ul>
</li>
</ul>
<h3 id="操作">操作</h3>
<ul>
<li>易安装</li>
<li>易更新</li>
<li>易备份</li>
<li>易恢复</li>
<li>可与我们所使用的的数据库版本一起工作</li>
<li>可以挂载在非根路径</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-12-15）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi">
        </link>
        <updated>2019-11-18T14:14:27.000Z</updated>
        <content type="html"><![CDATA[<p>利用周末时间到成都走了走，见到了四五年没见的三个高中同桌，心中甚是欢喜。在去往成都的途中，与我挨着的乘客是一个彝族同胞，她在东莞的一个纺织厂做衣服，这次请了两个月的假，回家与家人团聚过年。彝族的「年」叫做「库斯」，现在定在每年的 11 月 20 日，出于对不了解文化的好奇，我加了小姑娘的微信，天天都能看到他们的村民盛装举办各种活动，让我明年此时到凉山州走一走的想法愈发强烈。</p>
<p>四五年的时间让我和同学产生了很大的差异，他们做菜都超级棒，而我做的菜可能也只有自己才能忍着吃下去，找到了两点原因。一者成都的房子大部分都很适合做饭，空间很大，给了足够大的舞台让你展现厨艺，同等配置的房子在深圳需要成都两到三倍的租金；二者成都加班时间远比深圳少的多，同学说他有时候会加班到七点，而深圳大部分公司七点应该算正常下班时间，因此在成都的超市我看到了很多年轻人在买菜也就不足为奇了。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1574088668252.gif" alt=""></figure>
<p>前两天在微信朋友圈看到一篇<a href="https://mp.weixin.qq.com/s/0L8llYRQMklp-L9qcpHj9g">《香港问题和世界真相》</a>，以前也看到过类似标题的一些文章，那时候还会花些时间去读一读，最近愈发觉得微信公众号咋这么多人才呢？不管多么深奥的问题都能在公众号上找到答案，还引经据典讲的神乎其神，一篇公众号文章就能把科学家解决不了的问题全给解决了，实乃圣人也，我更愿意做一个俗人！</p>
<p>微信公众号可能是国内在保护原创这块做的最好的平台，但是其缺点也并不少。现在能看到很多作者变成了公众号平台的写作苦力，在微信公众号的机制下，你需要一直更新才能积累人气，很少有人持续输出高质量的内容，那些还没毕业或是刚毕业几年的小孩子更加不可能做到。</p>
<p>公众号是一个封闭的平台，搜索引擎无法检索到公众号的文章，这一点和互联网开放共享的思想是相违背的。公众平台提供的改几个错别字功能，远远不够纠正文章中引入的错误。以前我把公众号当个记事本，但是有一次因为说了不该说的话，直接给我封号了，连自己的历史文章都看不了，好在最后给解封了，赶紧把文章都备份下来。</p>
<p>去年十月份有个那么一周很多公众号都在推荐一个写作课，是几个 90 后开的写作课，其中一个的微信昵称是「九爷」，课程内容大致就是自媒体写作赚钱；而最近我微信朋友圈莫名出现了一个昵称为「宝藏女孩买买提」的人天天发京东各种商品的抢购链接，点进去看才发现这就是去年的那个「九爷」，心想这女生变得也太快了吧，何况我还不能百分百确定是女生，还是赶紧删掉好！</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1574088668252.gif" alt=""></figure>
<p>上面两个片段已经写完一个多月了，这一个多月没有找到什么片段可以凑到这里来，那就水一把说自己经历的一个小事吧。学长是做体育赛事直播的，他们公司举办了一个 2-4 岁儿童的骑跑比赛，我被学长抓壮丁去帮他在现场奖品和完赛纪念品，有一个家长给我的印象非常深刻。</p>
<p>一位妈妈在我这里领完纪念品后，一下扔到地上气冲冲的走了，孩子的表情我形容不出来，自己去把纪念品捡起来，但也没有去追妈妈。我本以为是我们哪里做的不对致使她那么大火气，结果一了解才知道是因为孩子比赛成绩太差了，自己家孩子赶不上别家孩子给气的。</p>
<p>上面那件事情不作评论，毕竟这一个片段是用来凑字数的，那就得有凑字数的样子。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 中的零拷贝技术]]></title>
        <id>https://mengxiaoxu.github.io//post/linux-zhong-de-ling-kao-bei-ji-zhu</id>
        <link href="https://mengxiaoxu.github.io//post/linux-zhong-de-ling-kao-bei-ji-zhu">
        </link>
        <updated>2019-11-18T13:43:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="https://lwn.net/Articles/178199/">Two new system calls: splice() and sync_file_range()</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/index.html">Linux 中的零拷贝技术1</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/index.html">Linux 中的零拷贝技术2</a><br>
<a href="https://www.linuxjournal.com/article/6345">Zero Copy I: User-Mode Perspective</a><br>
<a href="http://man7.org/linux/man-pages/man2/splice.2.html">Linux man-pages splice()</a></p>
</blockquote>
<p>此前在<a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua/">Nginx 文件操作优化</a>中有提到零拷贝技术，它可以有效的改善数据传输的性能，但是由于存储体系结构非常复杂，而且网络协议栈有时需要对数据进行必要的处理，所以零拷贝技术有可能会产生很多负面影响，甚至会导致零拷贝技术自身的优点完全丧失。</p>
<p>零拷贝就是一种避免 CPU 将一块存储拷贝到另一块存储的技术。它可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率，而且零拷贝技术也减少了内核态与用户态之间切换所带来的开销。进行大量的数据拷贝操作是一件简单的任务，从操作系统的角度来看，如果 CPU 一直被占用着去执行这项简单的任务，是极其浪费资源的。如果是高速网络环境下，很可能就出现这样的场景。</p>
<h3 id="零拷贝技术分类">零拷贝技术分类</h3>
<p>现在的零拷贝技术种类很多，也并没有一个适合于所有场景的零拷贝零拷贝技术，概括起来总共有下面几种：</p>
<ul>
<li>
<p><strong>直接 I/O</strong>：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统只是辅助数据传输，这类零拷贝技术可以让数据在应用程序空间和磁盘之间直接传输，不需要操作系统提供的页缓存支持。关于直接 I/O 可以参看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html">Linux 中直接 I/O 机制的介绍</a>。</p>
</li>
<li>
<p><strong>避免数据在内核态与用户态之间传输</strong>：在一些场景中，应用程序在数据进行传输的过程中不需要对数据进行访问，那么将数据从页缓存拷贝到用户进程的缓冲区是完全没有必要的，Linux 中提供的类似系统调用主要有<code>mmap()</code>、<code>sendfile()</code>和<code>splice()</code>。</p>
</li>
<li>
<p><strong>对数据在页缓存和用户进程之间的传输进行优化</strong>：这类零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统页缓存之间的拷贝操作，此类方法延续了传统的通信方式，但是更加灵活。在 Linux 中主要利用了「写时复制」技术。</p>
</li>
</ul>
<p>前两类方法的目的主要是为了避免在用户态和内核态的缓冲区间拷贝数据，第三类方法则是对数据传输本身进行优化。我们知道硬件和软件之间可以通过 DMA 来解放 CPU，但是在用户空间和内核空间并没有这种工具，所以此类方法主要是改善数据在用户地址空间和操作系统内核地址空间之间传递的效率。</p>
<h3 id="避免在内核与用户空间拷贝">避免在内核与用户空间拷贝</h3>
<p>Linux 主要提供了<code>mmap()</code>、<code>sendfile()</code>、<code>splice()</code>三个系统调用来避免数据在内核空间与用户空间进行不必要的拷贝，在<a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua/">Nginx 文件操作优化</a>对<code>sendfile()</code>已经做了比较详细的介绍了，这里就不再赘述了，下面主要介绍<code>mmap()</code>和<code>splice()</code>。</p>
<h4 id="mmap">mmap()</h4>
<p>当调用<code>mmap()</code>之后，数据会先通过 DMA 拷贝到操作系统的缓冲区，然后应用程序和操作系统共享这个缓冲区，这样用户空间与内核空间就不需要任何数据拷贝了，当大量数据需要传输的时候，这样做就会有一个比较好的效率。</p>
<p>但是这种改进是需要代价的，当对文件进行了内存映射，然后调用<code>write()</code>系统调用，如果此时其它进程截断了这个文件，那么<code>write()</code>系统调用将会被总线错误信号<code>SIGBUG</code>中断，因为此时正在存储的是一个错误的存储访问，这个信号将会导致进程被杀死。</p>
<p>一般可以通过文件租借锁来解决这个问题，我们可以通过内核给文件加读或者写的租借锁，当另外一个进程尝试对用户正在进行传输的文件进行截断时，内核会给用户发一个实时<code>RT_SIGNAL_LEASE</code>信号，这个信号会告诉用户内核破坏了用户加在那个文件上的写或者读租借锁，<code>write()</code>系统调用就会被中断，并且进程会被<code>SIGBUS</code>信号杀死。需要注意的是文件租借锁需要在对文件进行内存映射之前设置。</p>
<h4 id="splice">splice()</h4>
<p>和<code>sendfile()</code>类似，<code>splice()</code>也需要两个已经打开的文件描述符，并且其中的一个描述符必须是表示管道设备的描述符，它可以在操作系统地址空间中整块地移动数据，从而减少大多数数据拷贝操作。适用于可以确定数据传输路径的用户应用程序，不需要利用用户地址空间的缓冲区进行显示的数据传输操作。</p>
<p><code>splice()</code>不局限于<code>sendfile()</code>的功能，也就是说<code>sendfile()</code>是<code>splice()</code>的一个子集，在 Linux 2.6.23 中，<code>sendfile()</code>这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过内部已经使用了<code>splice()</code>这种机制来实现了。</p>
<h3 id="写时复制">写时复制</h3>
<p>在某些情况下，Linux 操作系统内核中的页缓存可能会被多个应用程序所共享，操作系统有可能会将用户应用程序地址空间缓冲区中的页面映射到操作系统内核地址空间中去。如果某个应用程序想要对这共享的数据调用<code>write()</code>系统调用，那么它就可能破坏内核缓冲区中的共享数据，传统的<code>write()</code>系统调用并没有提供任何显示的加锁操作，Linux 中引入了写时复制这样一种技术用来保护数据。</p>
<p>写时复制的基本思想是如果有多个应用程序需要同时访问同一块数据，那么可以为这些应用程序分配指向这块数据的指针，在每一个应用程序看来，它们都拥有这块数据的一份数据拷贝，当其中一个应用程序需要对自己的这份数据拷贝进行修改的时候，就需要将数据真正地拷贝到该应用程序的地址空间中去，也就是说，该应用程序拥有了一份真正的私有数据拷贝，这样做是为了避免该应用程序对这块数据做的更改被其他应用程序看到。这个过程对于应用程序来说是透明的，如果应用程序永远不会对所访问的这块数据进行任何更改，那么就永远不需要将数据拷贝到应用程序自己的地址空间中去。这也是写时复制的最主要的优点。</p>
<p>写时复制的实现需要 MMU 的支持，MMU 需要知晓进程地址空间中哪些特殊的页面是只读的，当需要往这些页面中写数据的时候，MMU 就会发出一个异常给操作系统内核，操作系统内核就会分配新的物理存储空间，即将被写入数据的页面需要与新的物理存储位置相对应。它最大好处就是可以节约内存，不过对于操作系统内核来说，写时复制增加了其处理过程的复杂性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim 常用命令快速查询]]></title>
        <id>https://mengxiaoxu.github.io//post/vim-chang-yong-ming-ling-kuai-su-cha-xun</id>
        <link href="https://mengxiaoxu.github.io//post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
        </link>
        <updated>2019-10-31T16:02:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容<br>
<a href="http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html">Learning Vim The Pragmatic Way</a><br>
《鸟哥的 Linux 私房菜》</p>
</blockquote>
<p>Vim 可以认为是 Vi 的高级版本，Vim 可以用颜色或下划线的方式来显示一些特殊信息，您可以认为 Vi 是一个文本处理工具，而 Vim 是一个程序开发工具，现在大部分 Linux 的发行版都以 Vim 替换 Vi 了。在 Linux 命令行模式下有很多编辑器，但是 Vi 文本编辑器是所有 Unix-like 系统都会内置的，因此学会 Vi/Vim 的使用时非常有必要的，对于 Vi 的三种模式（命令模式、编辑模式、命令行模式）这里就不在做说明了，下面是一些比较常用的命令。</p>
<h3 id="一般命令模式下">一般命令模式下</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h、j、k、l</td>
<td>与键盘的方向键一一对应，分别为左、下、上、右，在键盘上着几个字母是排在一起的</td>
</tr>
<tr>
<td>Ctrl+f、Ctrl+b</td>
<td>分别对应键盘的「Page Down」、「Page Up」，我更习惯于这两个键，而不是前面的组合键</td>
</tr>
<tr>
<td>0、$</td>
<td>分别对应键盘的「Home」、「End」，即移动到该行的最前面/后面字符处</td>
</tr>
<tr>
<td>n&lt;Enter&gt;</td>
<td>n 为数字，光标向下移动 n 行</td>
</tr>
<tr>
<td>/word、?word</td>
<td>向光标之上/下寻找一个字符串名称为 word 的字符串</td>
</tr>
<tr>
<td>n、N</td>
<td>如果我们刚刚执行了上面上面的 /word 或 ?word 查找操作，那么 n 则表示重复前一个查找操作，可以简单理解为向下继续查找下一个名称为 word 的字符串，N 则与 n 刚好相反</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将这个字符串替换为 word2，如果前面的 n1,n2 使用 1,$ 代替则表示从第一行到最后一行，最后的 g 后面可以加个 c，即 :1,$s/word1/word2/gc，这样就会在替换钱显示提示字符给用户确认（confirm）</td>
</tr>
<tr>
<td>x、X</td>
<td>分别对应键盘的「Del」、「Backspace」键</td>
</tr>
<tr>
<td>dd、yy</td>
<td>删除/复制光标所在的那一整行</td>
</tr>
<tr>
<td>p、P</td>
<td>p 将已复制的数据在光标下一行粘贴，P 粘贴在光标上一行</td>
</tr>
<tr>
<td>u</td>
<td>恢复前一个操作，类似于 Windows 下的 Ctrl+Z</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做上一个操作</td>
</tr>
<tr>
<td>.</td>
<td>小数点，重复上一个操作</td>
</tr>
</tbody>
</table>
<h3 id="命令行模式下">命令行模式下</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>将编辑的数据写入硬盘中</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为只读，强制写入该文件，不过到底能不能写入，还是跟文件权限有关系</td>
</tr>
<tr>
<td>:q、:q!</td>
<td>与 w 一样，q 为关闭的意思</td>
</tr>
<tr>
<td>:r [filename]</td>
<td>在编辑的数据中读入另一个文件的数据，即将[filename]这个文件的内容追加到光标所在行的后面</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据保存为另一个文件</td>
</tr>
<tr>
<td>:set nu/nonu</td>
<td>显示/不显示行号</td>
</tr>
</tbody>
</table>
<h3 id="编辑模式下">编辑模式下</h3>
<table>
<thead>
<tr>
<th>组合键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+n</td>
<td>通过目前正在编辑的这个文件的内容文字作为关键字，予以自动补全</td>
</tr>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+f</td>
<td>以当前目录内的文件名作为关键字补全</td>
</tr>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+o</td>
<td>以扩展名作为语法补充，以 Vim 内置的关键字予以补全</td>
</tr>
</tbody>
</table>
<p>当我们在使用 Vim 编辑器的时候，Vim 会在与被编辑的文件目录下再建立一个名为<code>.filename.swp</code>的文件，我们对文件的操作都会记录到这个 swp 文件中去，如果系统因为某些原因掉线了，就可以利用这个 swp 文件来恢复内容。如果存在对应的 swp 文件，那么 Vim 就会主动判断当前这个文件可能有问题，会给出相应的提示。</p>
<p>我们也可以给 Vim 环境设置一些个性化的参数，虽然在命令行模式下可以使用<code>:set</code>来设置，但是这样每次设置实在是太麻烦，因此我们可以设置一些全局的参数。Vim 的整体设置值一般放在<code>/etc/vimrc</code>中，我们一般通过修改<code>~/.vimrc</code>这个文件（默认不存在）来设置一些自己的参数，比如：</p>
<pre><code class="language-vim">&quot; 该文件的双引号是注释
set nu &quot;在每一行的最前面显示行号
set autoindent &quot; 自动缩进
set ruler &quot; 可显示最后一行的状态
set bg=dark &quot; 显示不同的底色色调
syntax on &quot;进行语法检验，颜色显示，比如 C 语言等
</code></pre>
<p>最后附上一张命令速查卡，此图来源于<a href="http://jrmiii.com/">Learning Vim The Pragmatic Way</a>，PDF 版下载链接在<a href="http://jrmiii.com/attachments/Vim.pdf">这里</a>。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1572670913809.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-10-28）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
        </link>
        <updated>2019-10-27T17:13:22.000Z</updated>
        <content type="html"><![CDATA[<p>分享一个视频：<a href="https://twitter.com/williamwoo7/status/1186498521408647168">施利伦法，利用折射率的不同使肉眼不可见的物质可视化</a>，我把它下下来了，如下：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/bDK1UfMQfqs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>在一位做酱香酒的朋友那里学了个鉴别真伪飞天茅台的方法，我不会喝酒所以没什么研究，实用性还请读者大人自行判断，反正我喝茅台的感觉与喝二锅头差不多，到嘴里都是一个味。</p>
<p>方法一：如果「酒」字里面的那一横，是图一的那个样子，那是真酒；而如果是图二的样子则是假酒。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1572196530821.png" alt=""></figure>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1572196539935.png" alt=""></figure>
<p>方法二：在如图左边仙女标红圈那个位置，如果线条的交汇点是穿出去的，则为真，反之为假。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1572196549838.jpg" alt=""></figure>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1572196558785.png" alt=""></figure>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>看了<a href="https://www.bilibili.com/video/av73524393?from=search&amp;seid=12678980801438574288">2019·菠萝科学奖颁奖典礼</a>，一个沙雕、严谨、有趣......的节目，处处都透漏着尴尬又不失礼貌的微笑，永远向好奇心致敬。我个人认为这个节目最大的优点就是把常人眼里那种无趣、严谨的科学以一种有趣的方式呈现出来，这可以让大多数人更喜欢科学，让科学家在科研的道路上坚持的更久。</p>
<p>在<a href="https://mp.weixin.qq.com/s/-aHGec_9wiIYsT0F4z4LMg">怎样才能开开心心的呢</a>中有提到过降低对事物的期望值，这里再详细谈一下降低期望值对学习的促进作用。以这两年大量冒出来的线上英语阅读打卡为例，只要打卡多少天就有小礼物，全勤甚至可以返还学费，这么一想那公司还怎么赚钱呢？原因就在于绝大部分人都只能坚持短短的几天，和健身卡的套路基本一致。</p>
<p>我想读者大人肯定都知道复利曲线，其实并不需要给自己定多么多么高远的目标，只需要每天坚持花一点时间一直去做，就能达到复利曲线的效果。之所以坚持不下去无非是因为学习很痛苦，而如果把学习变成像玩游戏一样有趣，那你肯定不会拒绝学习。比如上面说的英语学习，每天去背单词没几个人坚持的下来，那如果是每天看一集美剧呢？</p>
<p>人是需要被成就感驱动的，给自己一下定的目标太高很容易就气馁了，降低自己的期望值，把目标定小一点点，说不定每天都可以获得满满的成就感，配上一些有趣的方式、方法，学习这件事做起来简直妙不可言，其它事情也是一样的道理。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>最近取关了很多公众号，互联网时代不得不承认网上的好文不少，但是大部分人都没有那么多精力去读完，与其走马观花的读一遍，我更愿意精读一篇文章后再从中挖掘信息。之前一直不肯取关一些公众号，总是觉得某天会有个重要信息从那里得到，<a href="http://mindhacks.cn/">刘未鹏</a>老师说这是源于人「不肯关上一扇门」的心理，而实际关上一扇门可能增大我们的收益，注意力不至于被滑不到底的信息流骚扰。读过了却不一定领悟了，愈发赞同人与人学习的差距不在资质上，而在于花在思考上的时间与思考的深度。</p>
<p>同样为了不让太多事物让自己分心，我周末也花了些时间把很久没用的东西，很久没有穿的衣物等等都扔了，屋子一下显得宽敞了许多，忘记此前在哪里看到一篇文章有讲太多的家具会让自己分心，不过当时是找了一圈没舍得扔，因为每一件物品我好像总能想到它在某个场景下的作用，而现实情况是那些场景可能是我幻想出来的，或者当那个场景出现的时候，对应的物品也因为放的太久而无法使用了，还不如扔了算了。</p>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>下面是一些比较有意思的文章。</p>
<p><a href="https://tylervigen.com/spurious-correlations">tylervigen.com</a> 专门收集那些看起来高度相关但实际上毫不相关的数据，比如美国在科学、太空、技术方面的投入，与采用上吊、勒死、窒息方式自杀的案例，这两组数据之间的相关性高达 99.79% 。</p>
<p><a href="https://bruno-simon.com/">https://bruno-simon.com</a> 是一个超酷的网站主页，网站的源码在 <a href="https://github.com/brunosimon/folio-2019">Github</a>。页面用到了 3D 导航，你可以像玩游戏一样在里面探索，也可以把这个网页当成一个减压神器。</p>
<p><a href="https://daquan.tv/collections/funny/this-will-make-you-look-at-history-very-differently?stid=0&amp;utm_campaign=tw_daquan_look_history_us_dt_yo&amp;utm_medium=9949&amp;utm_source=1005&amp;utm_content=tw_daquan_look_history_us_dt_yo_i4">一些可能会颠覆你对世界的认识的照片</a> 文章里面列举了大量可能颠覆你认知的照片，比如世界上第一张自拍花了 30 秒，即保持一个姿势 30 秒不动。</p>
<p>Youtube 上最近有个视频火了：美国加州某地的微波传输站失灵了，技术人员在微波天线罩里面发现了 300磅（136公斤）的橡子，大家都认为是松鼠干的，根据美国「国家地理」的文章 <a href="https://www.nationalgeographic.com/news/2015/11/151113-antenna-cache-acorn-woodpecker-california/">Meet the Bird that Filled an Antenna With Acorns</a> 介绍，在微波天线罩里藏橡子的很可能不是松鼠，而是橡子啄木鸟。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 文件操作优化]]></title>
        <id>https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua</id>
        <link href="https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua">
        </link>
        <updated>2019-10-19T11:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="http://www.178linux.com/54790">Nginx AIO 机制与 sendfile 机制</a><br>
<a href="https://segmentfault.com/q/1010000003055006/a-1020000003064578">sendfile 适用场景</a><br>
<a href="http://xiaorui.cc/2015/06/24/%E6%89%AF%E6%B7%A1nginx%E7%9A%84sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5/">扯淡 Nginx 的 sendfile 零拷贝的概念</a><br>
<a href="https://www.jianshu.com/p/fad3339e3448">浅析 Linux 中的零拷贝技术</a><br>
<a href="http://man7.org/linux/man-pages/man2/sendfile.2.html">Linux man-pages sendfile</a></p>
</blockquote>
<p>今天在看 Nginx 配置的时候，看到了一个<code>sendfile</code>配置项，它可以配置在<code>http、server、location</code>三个块中，出于好奇就去查了一下<code>sendfile</code>的作用。</p>
<p>文件下载是服务器的基本功能，其基本流程就是循环的从磁盘读取文件内容到缓冲区，再将缓冲区内容发送到<code>socket</code>文件，程序员基本都会写出类似下面看起来比较高效的程序。</p>
<pre><code class="language-c">while((n = read(diskfd, buf, BUF_SIZE)) &gt; 0)
    write(sockfd, buf , n);
</code></pre>
<p>上面程序中我们使用了<code>read</code>和<code>write</code>两个系统调用，看起来也已经没有什么优化空间了。这里的<code>read</code>和<code>write</code>屏蔽了系统内部的操作，我们并不知道操作系统做了什么，现实情况却是由于 Linux 的 I/O 操作默认是缓冲 I/O，上面的程序发生了多次不必要的数据拷贝与上下文切换。</p>
<p>上述两行代码执行流程大致可以描述如下：</p>
<ol>
<li>系统调用<code>read</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>DMA 执行拷贝（现在都是 DMA 了吧！），把文件数据拷贝到内核缓冲区；</li>
<li>文件数据从内核缓冲区拷贝到用户缓冲区；</li>
<li><code>read</code>调用返回，从内核态切换为用户态；</li>
<li>系统调用<code>write</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>把步骤 3 读到的数据从用户缓冲区拷贝到 Socket 缓冲区；</li>
<li>系统调用<code>write</code>返回，从内核态切换到用户态；</li>
<li>DMA 从 Socket 缓冲区把数据拷贝到协议栈。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1571580838587.png" alt=""></figure>
<p>可以看到两行程序共发生了 4 次拷贝和 4 次上下文切换，其中 DMA 进行的数据拷贝不需要 CPU 访问数据，所以整个过程需要 CPU 访问两次数据。很明显中间有些拷贝和上下文切换是不需要的，<code>sendfile</code>就是来解决这个问题的，它是从 2.1 版本内核开始引入的，这里放个 2.6 版本的<a href="http://lxr.linux.no/linux+v2.6.36/fs/read_write.c#L809">源码</a>。</p>
<p>系统调用<code>sendfile</code>是将<code>in_fd</code>的内容发送到<code>out_fd</code>，描述符<code>out_fd</code>在 Linux 2.6.33 之前，必须指向套接字文件，自 2.6.33 开始，<code>out_fd</code>可以是任何文件；<code>in_fd</code>只能是支持<code>mmap</code>的文件（<code>mmap</code>是一种内存映射方法，在被调用进程的虚拟地址空间中创建一个新的指定文件的映射）。</p>
<p>所以当 Nginx 是一个静态服务器时，开启<code>sendfile</code>配置项是可以大大提高 Nginx 性能的，但是当把 Nginx 作为一个反向代理服务器时，<code>sendfile</code>则没有什么用，因为当 Nginx 时反向代理服务器时，<code>in_fd</code>就是一个套接字，这不符合<code>sendfile</code>的参数要求。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1571580849307.png" alt=""></figure>
<p>可以看到现在我们只需要一次拷贝就可以完成功能了，但是能否把这一次拷贝也省略掉呢？我们可以借助硬件来实现，仅仅需要把缓冲区描述符和文件长度传过去，这样 DMA 直接将缓冲区的数据打包发送到网络中就可以了。</p>
<p>这样就实现了零拷贝技术，需要注意的是这里所说的零拷贝是相对操作系统而言的，即在内核空间不存在冗余数据。数据的实际走向是从硬盘到内存，再从内存到设备。</p>
<p>Nginx 中还有一个<code>aio</code>配置，它的作用是启用内核级别的异步 I/O 功能，要使<code>aio</code>生效需要将<code>directio</code>开启（<code>directio</code>对大文件的读取速度有优化作用），<code>aio</code>很适合大文件的传送。需要注意的是<code>sendfile</code>和<code>aio</code>是互斥的，不可同时兼得二者，因此我们可以设置一个文件大小限制，超过该阀值使用<code>aio</code>，低于该阀值使用<code>sendfile</code>。</p>
<pre><code class="language-nginx">location /video/ {
    sendfile on;
    sendfile_max_chunk 256k; 
    aio threads;
    directio 512k;
    output_buffers 1 128k;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 高级知识技巧]]></title>
        <id>https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao</id>
        <link href="https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao">
        </link>
        <updated>2019-10-13T15:02:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象">对象</h2>
<p>Js 共有<code>number、string、boolean、null、undefined、object</code>六种主要类型，除了<code>object</code>的其它五中类型都属于基本类型，它们本身并不是对象。但是<code>null</code>有时会被当做对象处理，其原因在于不同的对象在底层都表示为二进制，在 js 中二进制前三位都为 0 的话就会被判定为<code>object</code>类型，而<code>null</code>的二进制表示全是 0， 所以使用<code>typeof</code>操作符会返回<code>object</code>，而后续的 Js 版本为了兼容前面埋下的坑，也就没有修复这个 bug。</p>
<p><code>&quot;I'm a string&quot;</code>本身是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度、访问某个字符等，那就需要将其转换为<code>String</code>类型，在必要的时候 js 会自动帮我们完成这种转换，也就是说我们并不需要用<code>new String('I'm a string')</code>来显示的创建一个对象。类似的像使用<code>42.359.toFixed(2)</code>时，引擎也会自动把数字转换为<code>Number</code>对象。</p>
<p><code>null</code>和<code>undefined</code>没有对应的构造形式，它们只有文字形式。相反，<code>Date</code>只有构造，没有文字形式。对于<code>Object、Array、Function</code>和<code>RegExp</code>（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</p>
<h2 id="array-类型">Array 类型</h2>
<p>数组类型有一套更加结构化的值存储机制，但是要记住的是，数组也是对象，所以有趣的是你也可以给数组添加属性。</p>
<pre><code class="language-javascript">var myArray = [&quot;foo&quot;, 42, &quot;bar&quot;];
myArray.baz = &quot;baz&quot;;
myArray.length; // 3
myArray.baz; // &quot;baz&quot;
</code></pre>
<p>数组类型的<code>length</code>属性是比较有特点的，它的特点在于不是只读的，也就是说你可以修改它的值。因此可以通过设置这个属性从数组末尾删除或添加新的项。</p>
<pre><code class="language-javascript">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
colors.length = 2;
console.info(colors[2]); // undefined
colors.length = 4;
console.info(colors[4]); // undefined
// 向后面追加元素
colors[colors.length] = &quot;black&quot;;
</code></pre>
<p>数组还有一些很方便的迭代方法，比如every()、filter()、forEach()、map()、some()，这些方法都不会修改数组中包含的值，传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。</p>
<h2 id="function-类型">Function 类型</h2>
<p>在 ECMAScript 中，每个函数都是<code>Function</code>类的实例，而且都与其它引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>在函数的内部有两个特殊的对象，<code>this</code>和<code>arguments</code>。<code>arguments</code>对象有<code>callee</code>和<code>caller</code>属性。<code>caller</code>用来指向调用它的<code>function</code>对象，若直接在全局环境下调用，则会返回<code>null</code>；<code>callee</code>用来指向当前执行函数，所以我们可以通过下面的方式来实现阶乘函数。</p>
<pre><code class="language-javascript">function factorial(num) {
    if (num &lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
</code></pre>
<p>每个函数都包含两个非继承而来的方法，<code>apply()</code>和<code>call()</code>，这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。首先，<code>apply()</code>方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是<code>Array</code>的实例，也可以是<code>arguments</code>对象。<code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅仅在于接收参数的方式不同，在使用<code>call()</code>方法时必须逐个列举出来。</p>
<pre><code class="language-javascript">window.color = &quot;red&quot;;
var o = {color: &quot;blue&quot;};
function sayColor() {
    console.info(this.color);
}
sayColor(); // red
sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
sayColor.apply(o); // blue
</code></pre>
<p>需要注意的是，在严格模式下未指定环境对象而调用函数，则<code>this</code>值不会转型为<code>window</code>，除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>。</p>
<h2 id="安全的类型检查">安全的类型检查</h2>
<p>Js 内置的类型检查机制并不是完全可靠的，比如在 Safari（第5版前），对正则表达式应用<code>typeof</code>操作符会返回<code>function</code>；像<code>instanceof</code>在存在多个全局作用域（包含 frame）的情况下，也会返回不可靠的结果；前文提到的 Js 一开始埋下的坑也会导致类型检查出错。</p>
<p>我们可以使用<code>toString()</code>方法来达到安全类型检查的目的，在任何值上调用<code>Object</code>原生的<code>toString()</code>方法都会返回一个<code>[object NativeConstructorName]</code>格式的字符串，下面以检查数组为例。</p>
<pre><code class="language-javascript">Object.prototype.toString.call([]); // &quot;[object Array]&quot;
function isArray(val) {
    return Object.prototype.toString.call(val) == &quot;[object Array]&quot;;
}

</code></pre>
<h2 id="作用域安全的构造函数">作用域安全的构造函数</h2>
<p>构造函数其实就是一个使用<code>new</code>操作符调用的函数，当使用<code>new</code>操作符调用时，构造函数内用到的<code>this</code>对象会指向新创建的对象实例，比如我们有下面的构造函数。</p>
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
</code></pre>
<p>现在的问题在于，要是我们不使用<code>new</code>操作符呢？会发生什么！</p>
<pre><code class="language-javascript">let person = Person('name', 23);
console.info(window.name); // name
console.info(window.age); // 23
</code></pre>
<p>很明显，这里污染了全局作用域，原因就在于没有使用<code>new</code>操作符调用构造函数，此时它就会被当作一个普通的函数被调用，<code>this</code>就被解析成了<code>window</code>对象。我们需要将构造函数修改为先确认this是否是正确类型的实例，如果不是则创建新的实例并返回。</p>
<pre><code class="language-javascript">function Person(name, age) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
    } else {
        return new Person(name, age);
    }
}
</code></pre>
<h2 id="高级定时器">高级定时器</h2>
<p>大部分人都知道使用<code>setTimeout()</code>和<code>setInterval()</code>可以方便的创建定时任务，看起来好像 Js 也是多线程的一样，实际上定时器仅仅是计划代码在未来的某个时间执行，但是执行时机是不能保证的。因为在页面的生命周期中，不同时间可能有其它代码控制着 JavaScript 进程。</p>
<p>这里需要注意一下<code>setInterval()</code>函数，仅当没有该定时器的任何其他代码实例时，Js 引起才会将定时器代码添加到队列中。这样可以避免定时器代码可能在代码再次被添加到队列之前还没有完成执行，进而导致定时器代码连续运行好几次的问题。但是这也导致了另外的问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。</p>
<p>假设某个<code>click</code>事件处理程序使用<code>setInterval()</code>设置了一个 200ms 间隔的重复定时器。如果这个事件处理程序花了 300ms 多的时间完成，同时定时器代码也花了差不多了的时间，就会同时出现跳过间隔切连续运行定时器代码的情况。</p>
<p>为了避免<code>setInterval()</code>的重复定时器的这两个缺点，我们可以使用如下模式的链式<code>setTimeout()</code>，代码一看就懂什么意思了。</p>
<pre><code class="language-javascript">setTimeout(function() {
    // 处理中
    setTimeout(arguements.callee, interval);
}, interval)
</code></pre>
<h2 id="消息队列与事件循环">消息队列与事件循环</h2>
<p>如下图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1570979103039.png" alt=""></figure>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。<br>
JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>来看个例子：执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt; 5s）后，再点击两下，整个过程的输出结果是什么？</p>
<pre><code class="language-javascript">setTimeout(function(){
    for(var i = 0; i &lt; 100000000; i++){}
    console.log('timer a');
}, 0)
for(var j = 0; j &lt; 5; j++){
    console.log(j);
}
setTimeout(function(){
    console.log('timer b');
}, 0)
function waitFiveSeconds(){
    var now = (new Date()).getTime();
    while(((new Date()).getTime() - now) &lt; 5000){}
    console.log('finished waiting');
}
document.addEventListener('click', function(){
    console.log('click');
})
console.log('click begin');
waitFiveSeconds();
</code></pre>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达 5s。然后，在 Js 引擎线程执行的时候，<code>'timer a'</code>对应的定时器产生的回调、<code>'timer b'</code>对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于 Js 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务，最后，5s 后的两次 click 事件被放入消息队列，由于此时 Js 引擎线程空闲，便被立即执行了。因此会产生下面的输出顺序。</p>
<pre><code class="language-text">0
1
2
3
4
click begin
finished waiting
click
click
timer a
timer b
click
click
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[家里的狗]]></title>
        <id>https://mengxiaoxu.github.io//post/jia-li-de-gou</id>
        <link href="https://mengxiaoxu.github.io//post/jia-li-de-gou">
        </link>
        <updated>2019-10-12T14:18:04.000Z</updated>
        <content type="html"><![CDATA[<p>为了防止晚上有人来家里偷东西，几乎家家户户都至少会养一只狗。在我的记忆中，我家一开始是没有狗的。</p>
<p>忘记是哪一年夏天的一个清晨，天还没有大亮，我隐约看见在牛棚后面的空地有个黑影，走近一点仔细一看，原来是一只不知道从哪里来的一只黑狗。</p>
<p>它惊恐的看着我，眼神中夹杂着恐惧与无助，佝偻的身子比弓还要弯，倒是很像一个活着的牛轭。他的身子还没有草高，露水把全身的毛都打湿了，还沾着一些不知名的植物种子。我和它对视着，恐惧慢慢填满了它的眼球，我害怕吓到它，赶紧走开去告诉妈。</p>
<p>妈远远看了一眼，让我别管它。随后妈把装着昨晚剩饭的猪食瓢放到牛棚后面的一块石头上，黑狗看见妈带着武器走近早就跑了，我吃早饭时还不时去望望它在不在，有没有吃妈给放在那里的饭。</p>
<p>妈已经把猪喂完准备下地干活了，仍旧没有再次发现黑狗的踪影，也没见猪食瓢有什么变化，我心里有一点点的失落，黑狗应该是已经逃走了吧。</p>
<p>晚上吃完饭妈去拿猪食瓢，告诉我里面的饭已经被吃的一粒不剩，我心里开始期待和它的再次见面。第二天早晨果然见到它了，身上已经没有昨天那么湿了，显然没有前一天来这里时钻的草丛多，妈依旧用猪食瓢装着米饭和米汤放在牛棚后的那个石头上。</p>
<p>就这样过了几日，黑狗走进了我家的屋檐，它的样子实在太丑了。每一根肋骨都清晰的扎眼，看起来爸的手指都比它的小腿粗，感觉下一秒它就会死去。</p>
<p>我并不喜欢它，甚至还有些讨厌它，我实在找不到更丑的词来形容它，不过是出于心里的怜悯与对生命的敬畏，会在吃饭的时候给它丢几个我不吃的肥肉，被烟熏黑的那一层肉边我也丢给它......</p>
<p>有一次同村的一个人路过家门口时，看见那只黑狗吓的赶紧往妈身后躲。“有我在，它不敢咬。”，妈说。邻居夸夸妈说：“这个狗儿喂得好肥”。妈自豪的告诉那个人这只狗每天还送林儿（我）上学。</p>
<p>是的，我也不知道什么时候我已经和大黑狗变得如此亲密了，它每天早上会把我送到山顶的学校，我每天下午回家做完作业会和它一起到田间追逐。在学校也常常会给同学们说大黑狗胸前的那长成了“人”字的一片白毛，我一直相信“人”字是老天爷特地印在它身上，用来告诉我大黑狗是他派来的使者。</p>
<p>大黑狗来我家时已经很老很老了，是我读三年级的某一天，它像往常一样把我送到学校，但是我下午回家却不见它的踪影，一直等到晚上都没有见它回来。那些天我放学回家第一件事就是朝我和它常去的那些地方大声的唤它。</p>
<p>不到一个月后的一天早晨，像大黑狗第一次来我家附近时的场景一样，湿漉漉的身子带着些杂草种子，不同的是它身旁还跟着一只背部有些黑毛的小黄狗，小黄狗胸前也有一个很明显的“人”字。我赶紧去用猪食瓢盛满饭放在它面前，它吃了几口就又走了。</p>
<p>就这样，大黑狗离开了我，给我留下了一只小小的黄奶狗。我不知道它是去找它原来的主人去了，还是觉得自己老了，不愿意让我看见它倒下的样子，反正它就是再也没有回来过。</p>
<p>小黄狗长成了大黄狗，我对这只大黄狗的印象很浅，只记得爸妈把这只黄狗送给了外婆家附近的亲戚，我们留下了它生的一只小黄狗。外婆知道我们把大黄狗送人，还狠狠的批评了爸妈，说自己来家里的狗不能送人。</p>
<p>自然小黄狗很快就长成了大黄狗，我像以前一样也偷偷给大黄狗吃肉，逐渐开始懂事的妹妹也会背着爸妈给它肉吃，我和妹都会夹几片我们压根就不吃的肥肉，离开饭桌假装是到外面吃饭，实际上是给大黄狗送肉去了。</p>
<p>我到离家 30 多公里的镇上读高中，每个月才回家一次。每次离家大黄狗都会送我到集市去赶车，我会在寒暑假的黄昏和它到新修的公路去追逐，带它去它自己一个人不敢去探索的地方。</p>
<p>上大学后和大黄狗相处的时间更少了，听爸妈说它会经常跑到外婆家，外婆好吃好喝的招待它，招呼都不打一声就又跑回来了。还经常和邻居家的狗到麦子地打闹，要把一大片麦子弄倒才肯回家。</p>
<p>每学期回家在离家还有四五百米的地方都会听到它的吠叫，因为它把我当陌生人了。但是只要我大喊一声，它就会立刻停止吠叫，飞奔到我这里，兴奋的往我身上爬，把它的前爪往我身上搭；我努力不让它碰到我的衣服，然而每次到家时我都带着一身泥巴做的狗爪印。</p>
<p>现在大黄狗已经 10 多岁了，它就像大黑狗当年送我一样每天送我妹上学。我也已经走入职场开始工作，待在家里的时间更少了，我不知道它还能活多久，生怕哪次爸妈打电话时会给我说大黄狗死了，只要爸妈没有在电话中提及大黄狗，我都是非常开心的，因为那就代表着它依旧健健康康的活着。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[怎样才能开开心心的呢？]]></title>
        <id>https://mengxiaoxu.github.io//post/o9IjztOrR</id>
        <link href="https://mengxiaoxu.github.io//post/o9IjztOrR">
        </link>
        <updated>2019-09-08T13:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。</p>
<p>说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。</p>
<p>媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。</p>
<p>包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”</p>
<p>像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。</p>
<p>我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。</p>
<p>很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。</p>
<p>这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。</p>
<p>于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。</p>
<p>当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。</p>
<p>当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。</p>
<p>举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。</p>
<p>我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。</p>
<p>另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。</p>
<p>周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？</p>
<p>凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量提升与作用域]]></title>
        <id>https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu</id>
        <link href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu">
        </link>
        <updated>2019-08-08T14:29:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="https://www.crifan.com/lhs_rhs_meaning/">lhs rhs是啥意思</a><br>
《Javasript 高级程序设计（第三版）》<br>
《你不知道的 JavaScript（上卷）》</p>
</blockquote>
<p>几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为<strong>作用域</strong>。</p>
<h3 id="编译原理">编译原理</h3>
<p>我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。</p>
<p>传统语言在执行之前会经历三个步骤：<strong>分词/词法分析、解析/语法分析、代码生成</strong>，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。</p>
<p>我们需要先了解三个名词。<strong>引擎</strong>：从头到尾负责整个 js 程序的编译及执行过程；<strong>编译器</strong>：负责词法分析及代码生成；<strong>作用域</strong>：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
<p><code>var a = 2;</code>，我们以这段程序为例，它首先声明了变量<code>a</code>，然后将<code>2</code>赋值给变量<code>a</code>。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。</p>
<p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>
<h3 id="变量提升">变量提升</h3>
<p>用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码</p>
<pre><code class="language-javascript">console.log(a);
var a = 2;
</code></pre>
<p>上述代码在<code>a</code>声明之前访问了变量<code>a</code>，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是<code>undefined</code>。</p>
<p>回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，<strong>包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理</strong>。所以我们前面列出来的代码实际上会变成下面这个样子。</p>
<pre><code class="language-javascript">var a;
console.log(a);
a = 2;
</code></pre>
<p>这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。</p>
<pre><code class="language-javascript">foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}
</code></pre>
<p>这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。</p>
<pre><code class="language-javascript">function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};
</code></pre>
<p>可以看到，虽然<code>var foo</code>出现在<code>function foo()</code>之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。</p>
<h3 id="lhs-和-rhs-查询">LHS 和 RHS 查询</h3>
<p>LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是<strong>赋值操作符的左侧和右侧</strong>。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。</p>
<p>RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。</p>
<p><code>console.info(a);</code>我们深入研究一下这句代码。这里对<code>a</code>的引用是 RHS 引用，因为这里<code>a</code>并没有赋予任何值，相应的需要查找并取得<code>a</code>的值，这样才能传递给<code>console.info()</code>。</p>
<p><code>a = 2;</code>对<code>a</code>的引用则是一个 LHS 引用，因为实际上我们并关心<code>a</code>当前的值是什么，只是想为<code>= 2</code>这个赋值操作找到一个目标。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a);
}
foo(2);
</code></pre>
<p>为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行<code>foo()</code>函数的调用需要对<code>foo</code>进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给<code>foo()</code>函数时，2 会被分配给参数<code>a</code>，为了给参数<code>a</code>（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了<code>a = 2</code>的语句。</p>
<p>前文已经说过了<code>console.info(a);</code>会对<code>a</code>进行一次 RHS 查询，需要注意的是<code>console.info()</code>本身也需要一个引用才能执行，因此会对<code>console</code>对象进行 RHS 查询，并检查得到的值中是否有一个<code>log</code>方法。</p>
<h3 id="为什么区分-lhs-和-rhs">为什么区分 LHS 和 RHS</h3>
<p>我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);
</code></pre>
<p>第一次对<code>b</code>进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。</p>
<p>引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<blockquote>
<p>需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。</p>
</blockquote>
<p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。</p>
<h3 id="作用域链">作用域链</h3>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是<code>window</code>对象，因此所有的全局变量和函数都是作为<code>window</code>对象的属性和方法创建的。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。</p>
<p>当代码在环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function changeColor() {
    var anotherColor = &quot;red&quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();
</code></pre>
<p>下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。</p>
<pre><code class="language-text">window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor
</code></pre>
<p>作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function getColor() {
    var color = &quot;red&quot;;
    return color;
}

console.info(getColor()); // &quot;red&quot;
</code></pre>
<p>在<code>getColor()</code>中沿着作用域链在局部环境中已经找到了<code>color</code>，所以搜索就停止了，也就是说任何位于局部变量<code>color</code>的声明之后的代码，如果不使用<code>window.color</code>都无法访问全局<code>color</code>变量。</p>
]]></content>
    </entry>
</feed>