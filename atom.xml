<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-09-25T13:04:22.148Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[如何让你的网页看起来更美观]]></title>
        <id>https://mengxiaoxu.github.io//post/WsHPYySZU</id>
        <link href="https://mengxiaoxu.github.io//post/WsHPYySZU">
        </link>
        <updated>2019-09-25T12:53:51.000Z</updated>
        <content type="html"><![CDATA[<p>现在基本都离不开做网页，但是不同网页给人的感觉完全不一样，如何让你的网页看起来更加清爽，怎样让用户更愿意停留在你的网页中，就需要很好的设计了，偶然发现一篇《网页设计中常见的错误》，将其中的内容作了简单的整理。</p>
<h4 id="把内容分解成逻辑块">把内容分解成逻辑块</h4>
<p>把信息分组到逻辑块中，用户会更容易消化他们，设置内边距为 120px~180px ，并且使用彩色背景分割文本。</p>
<p>字体合适，并且块之间用颜色分开，使得每一部分内容都很清楚。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569416092787.png" alt=""></figure>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569416099806.png" alt=""></figure>
<h4 id="各部分内容间隔均匀">各部分内容间隔均匀</h4>
<p>围绕逻辑块设置相同大小的间隔，这样可以避免页面混乱的情况，让用户给给予每个部分同等的考虑。</p>
<p>不同宽度的空间看起来不均匀，让人感觉到下面的内容是和上面的内容是从属关系，但实际上它们是同等重要的并列关系。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569416113978.png" alt=""></figure>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569416125520.png" alt=""></figure>
<h4 id="足够的内边距">足够的内边距</h4>
<p>太小的内边距会让用户无法梳理内容的逻辑，为了避免逻辑块的混乱，应该使用一个大的空间将它们分开。</p>
<p>过于狭窄的内容填充让页面显得混乱，容易让用户认为这是一个纯文本，而不是具有不同含义的逻辑块，使用足够的大的空间填充，就可以立即看到这两个块之间的差异。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569416135927.png" alt=""></figure>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569416145729.png" alt=""></figure>
<h4 id="增大背景与文字的对比度">增大背景与文字的对比度</h4>
<p>有时候会使用图片作为文字内容的背景，为了突出文字内容，可以在图片上放一个遮罩层，然后再放上文字，推荐使用黑色遮罩层。当然，你也可以一开始就使用对比度比较高的图片作为背景。</p>
<p>背景图片亮度太高，阅读图片上的文字时就显得困难，加上一个黑色遮罩层，会让阅读变得轻松。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569416157769.png" alt=""></figure>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1569416167190.png" alt=""></figure>
<h4 id="避免在同一页面有太多样式">避免在同一页面有太多样式</h4>
<p>在同一页面上使用过多的样式风格会显得不专业，同时也让阅读体验大打折扣，可以把你的字体限制在一种，字体的饱和度选项限制在两种，比如正常和黑体。</p>
<p>过多的样式让页面的重点不清晰，而经过修改后的页面看起来更加干净整洁。</p>
<figure data-type="image" tabindex="9"><img src="https://mengxiaoxu.github.io//post-images/1569416179111.png" alt=""></figure>
<figure data-type="image" tabindex="10"><img src="https://mengxiaoxu.github.io//post-images/1569416191396.png" alt=""></figure>
<h4 id="避免强调窄页元素">避免强调窄页元素</h4>
<p>使用颜色来强调窄页元素只是看起来不太好，例如标题本身的字体大小、字体样式已经给了它们很好的标记，如果想强调页面上某个特定的点，可以给整个区块使用颜色背景。</p>
<p>图中有颜色背景的标题打破了页面的连续性，看起来标题更像是独立的元素，把标题和文本都使用同一个颜色块作为背景，表示它们属于同一个逻辑块。</p>
<figure data-type="image" tabindex="11"><img src="https://mengxiaoxu.github.io//post-images/1569416203228.png" alt=""></figure>
<figure data-type="image" tabindex="12"><img src="https://mengxiaoxu.github.io//post-images/1569416214285.png" alt=""></figure>
<h4 id="在狭窄的列中放太多的文本">在狭窄的列中放太多的文本</h4>
<p>当在一个狭窄的列中放置太多的文本时，用户必须从一行跳到下一行，而且很难看；最好是减少行数和缩短文本长度，否则没人愿意读它。</p>
<figure data-type="image" tabindex="13"><img src="https://mengxiaoxu.github.io//post-images/1569416224540.png" alt=""></figure>
<figure data-type="image" tabindex="14"><img src="https://mengxiaoxu.github.io//post-images/1569416234160.png" alt=""></figure>
<h4 id="居中的文字不要太多">居中的文字不要太多</h4>
<p>当页面上的文本很少时，将文本内容居中是个不错的选择，用户很容易就能注意到它，同时文字大小从 24px 开始，如果文本比较多时，使用可折叠的文本块比较好。</p>
<figure data-type="image" tabindex="15"><img src="https://mengxiaoxu.github.io//post-images/1569416243846.png" alt=""></figure>
<figure data-type="image" tabindex="16"><img src="https://mengxiaoxu.github.io//post-images/1569416252635.png" alt=""></figure>
<h4 id="文字遮挡图像有意义的部分">文字遮挡图像有意义的部分</h4>
<p>避免使用文字遮挡图像中有意义的部分或小细节，这样你既能使图像变得模糊，又能使文本难以辨认。</p>
<figure data-type="image" tabindex="17"><img src="https://mengxiaoxu.github.io//post-images/1569416263434.png" alt=""></figure>
<figure data-type="image" tabindex="18"><img src="https://mengxiaoxu.github.io//post-images/1569416274340.png" alt=""></figure>
<h4 id="避免滥用视觉层次结构">避免滥用视觉层次结构</h4>
<p>为了使信息层次结构清晰可见，封面上的标题应该比其他标题大，至少不能比其他标题小，尤其是标题很长的时候。</p>
<p>上面的大标题比下面的小标题还要小，看起来会很奇怪，也会让用户很困惑，清晰的层次结构能让用户区分重要和不重要的信息。</p>
<figure data-type="image" tabindex="19"><img src="https://mengxiaoxu.github.io//post-images/1569416283994.png" alt=""></figure>
<figure data-type="image" tabindex="20"><img src="https://mengxiaoxu.github.io//post-images/1569416293388.png" alt=""></figure>
<h4 id="避免把同一个逻辑块一分为二">避免把同一个逻辑块一分为二</h4>
<p>把一个全屏的图像放在文本之后，会类似于一个独立的模块，可以在图片周围添加填充，由于共享背景，文本和图像看起来才是一个逻辑整体。</p>
<figure data-type="image" tabindex="21"><img src="https://mengxiaoxu.github.io//post-images/1569416302928.png" alt=""></figure>
<figure data-type="image" tabindex="22"><img src="https://mengxiaoxu.github.io//post-images/1569416311721.png" alt=""></figure>
<h4 id="别让标题又大又长">别让标题又大又长</h4>
<p>非常大的句子适合短句子，如果是很长的标题，使用较小的字体，这样会更加容易阅读，并且为页面上其他空间留下足够的空间。</p>
<p>一个太大的标题占据整个封面，会与其它元素争夺空间，选择更小的标题能让页面元素相互平衡，易于阅读。<br>
<img src="https://mengxiaoxu.github.io//post-images/1569416325028.png" alt=""></p>
<figure data-type="image" tabindex="23"><img src="https://mengxiaoxu.github.io//post-images/1569416338562.png" alt=""></figure>
<h4 id="错误的使用按钮边框样式">错误的使用按钮边框样式</h4>
<p>当按钮的样式是透明时，边框是必要的，而为有颜色的按钮添加样式就显得没有任何意义了，这会让页面显得超负荷了，不利于阅读。</p>
<figure data-type="image" tabindex="24"><img src="https://mengxiaoxu.github.io//post-images/1569416349188.png" alt=""></figure>
<h4 id="使用过多的颜色">使用过多的颜色</h4>
<p>在页面上使用过多的颜色会让用户感到困惑，无法弄清楚哪个部分更重要，一到两种颜色就足以突出真正重要的东西。</p>
<figure data-type="image" tabindex="25"><img src="https://mengxiaoxu.github.io//post-images/1569416357517.png" alt=""></figure>
<figure data-type="image" tabindex="26"><img src="https://mengxiaoxu.github.io//post-images/1569416365198.png" alt=""></figure>
<h4 id="过载的菜单栏">过载的菜单栏</h4>
<p>用户在访问网站寻找解决他们问题的办法时，菜单栏可以快速方便的让用户定位他们想要的内容，不要在菜单栏放置过多的信息，有 5-7 个菜单项就足够了。</p>
<figure data-type="image" tabindex="27"><img src="https://mengxiaoxu.github.io//post-images/1569416374750.png" alt=""></figure>
<figure data-type="image" tabindex="28"><img src="https://mengxiaoxu.github.io//post-images/1569416383396.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅析浏览器缓存机制]]></title>
        <id>https://mengxiaoxu.github.io//post/qCt13nLLT</id>
        <link href="https://mengxiaoxu.github.io//post/qCt13nLLT">
        </link>
        <updated>2019-09-25T12:29:29.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。</p>
<h4 id="http-报文">HTTP 报文</h4>
<p>HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。</p>
<h4 id="缓存概述">缓存概述</h4>
<p>浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569414647062.png" alt=""></figure>
<p>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有<strong>强制缓存</strong>和<strong>协商缓存</strong>两类，也有人把协商缓存叫对比缓存。</p>
<h4 id="强制缓存">强制缓存</h4>
<p>我们先自己想一下，使用缓存是不是会有下面几种情况出现。</p>
<ul>
<li>
<p>存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；</p>
</li>
<li>
<p>存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；</p>
</li>
<li>
<p>不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。</p>
</li>
</ul>
<p>控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，并且<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<h6 id="expires">Expires</h6>
<p><code>Expires</code>是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于<code>Expires</code>值，就直接使用缓存数据。到了 HTTP/1.1，<code>Expires</code>已经被<code>Cache-Control</code>替代了。</p>
<p><code>Expires</code>被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。</p>
<h6 id="cache-control">Cache-Control</h6>
<p><code>Cache-Control</code>是 HTTP/1.1 中最重要的规则，主要取值为：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与<code>private</code>一样。</td>
</tr>
<tr>
<td><code>private</code></td>
<td>所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认值。</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存内容将在 xxx 秒后失效</td>
</tr>
</tbody>
</table>
<p>我们可以看看下面这个例子，可以从截图中看到<code>Expires</code>是一个绝对值，而<code>Cache-Control</code>是一个相对值，此处为<code>max-age=3600</code>，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，<code>Cache-Control</code>相比于<code>Expires</code>是更好的选择，所以同时存在时只有<code>Cache-Control</code>生效。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569414685538.png" alt=""></figure>
<h4 id="协商缓存">协商缓存</h4>
<p>协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569414775602.png" alt=""></figure>
<p>上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，所以同时存在时只有<code>Etag / If-None-Match</code>生效。</p>
<h6 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h6>
<p>你可以往上翻一翻，看一下那张响应报文截图，其中有一个<code>Last-Modified</code>字段，它的值是该资源文件在服务器最后被修改的时间。</p>
<p><code>If-Modified-Since</code>则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值。服务器收到该请求后，发现该请求头有<code>If-Modified-Since</code>字段，则会将<code>If-Modified-Since</code>与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569414811322.png" alt=""></figure>
<h6 id="etag-if-none-match">Etag / If-None-Match</h6>
<p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。</p>
<p><code>If-None-Match</code>则是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569414845179.png" alt=""></figure>
<h4 id="disk-cache-与-memory-cache">disk cache 与 memory cache</h4>
<p>我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569414871028.png" alt=""></figure>
<p>猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。</p>
<p>内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。</p>
<p>浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。</p>
<h4 id="总结">总结</h4>
<p>到这里偷懒一下子了，找到人家画的一张图，看图就行了。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569414915648.png" alt=""></figure>
<blockquote>
<p>参考内容：<br>
<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a><br>
<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bootstrap-table 合并相同单元格]]></title>
        <id>https://mengxiaoxu.github.io//post/MqqlYHD78</id>
        <link href="https://mengxiaoxu.github.io//post/MqqlYHD78">
        </link>
        <updated>2019-09-25T12:22:05.000Z</updated>
        <content type="html"><![CDATA[<p>Bootstrap-table 官方提供了合并单元格方法 <a href="https://bootstrap-table.com/docs/api/methods/#mergecells">mergeCells</a>，它根据四个参数可以合并任意个单元格，我们要做的只是告诉它怎么合并。</p>
<p>要合并同一列相同的单元格，无非两种办法，一种是一边遍历一边合并，遍历完了再合并。这里采用第二种办法，这里不需要遍历所有数据，因为用户只能看到当前页的数据，所以只遍历当前页的数据更省时间。</p>
<p>下面是我实现的获取合并信息算法，最终返回的是一个哈希表，比如下面的这个表格，如果要对「性别」这一列进行合并，很明显前面两个“男”需要合并成一个单元格，再去看下 Bootstrap-table 提供的 API，它需要的是从哪个单元格开始，合并多少个单元格，也就是它需要的是两个数值类型的参数。</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>男</td>
<td>23</td>
</tr>
<tr>
<td>李四</td>
<td>男</td>
<td>19</td>
</tr>
<tr>
<td>王二</td>
<td>女</td>
<td>20</td>
</tr>
<tr>
<td>麻子</td>
<td>男</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>所以我把哈希表设置为，键存的是索引，值存的是从这个索引开始后面连续有多少个和它一样的单元格，那么上述表格性别这一列所得到的合并信息哈希表就为：</p>
<pre><code>{
    0: 2,
    2: 1,
    3: 1
}
</code></pre>
<p>下面算法很简单，使用两个指针遍历指定的列，如果两个指针所指向的数据相同，那么就将键所对应的值进行加一操作，整个方法只会对该列数据遍历一边，所以时间复杂度为 O(n)。</p>
<pre><code class="language-typescript">let getMergeMap = function (data, index: number) {
    let preMergeMap = {};
    // 第 0 项为表头，索引从 2 开始为了防止数组越界
    for (let i = 2; i &lt; data.length; i++) {
        let preText = $(data[i-1]).find('td')[index].innerText;
        let curText = $(data[i]).find('td')[index].innerText;
        let key = i - 2;
        preMergeMap[key] = 1;
        while ((preText == curText) &amp;&amp; (i &lt; data.length-1)) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
            i++;
            preText = $(data[i - 1]).find('td')[index].innerText;
            curText = $(data[i]).find('td')[index].innerText;
        }
        // while循环跳出后，数组最后一项没有判断
        if (preText == curText) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
        }
    }
    return preMergeMap;
}
</code></pre>
<p>上述算法得到了单列数据的合并信息，下一步就是按照这个信息进行相同单元格的合并了，因此封装了下面的方法按照指定哈希表进行合并。</p>
<pre><code class="language-typescript">let mergeCells = function (preMergeMap: Object, target, fieldName: string) {
    for (let prop in preMergeMap) {
        let count = preMergeMap[prop];
        target.bootstrapTable('mergeCells', { index: parseInt(prop), field: fieldName, rowspan: count });
    }
}
</code></pre>
<p>到目前为止，我们实现的都只是对单列数据进行合并，要实现对多列数据进行合并，那么只需要对所有列都进行相同的操作即可。</p>
<pre><code class="language-typescript">export let mergeCellsByFields = function (data: Object[], target, fields) {
    for (let i = 0; i &lt; fields.length; i++) {
        let field = fields[i];
        // 保证 field 与 i 是相对应的
        let preMergeMap = getMergeMap(data, i);
        let table = target.bootstrapTable();
        mergeCells(preMergeMap, table, field);
    }
}
</code></pre>
<p>因为我在程序中做了一点处理，保证了<code>fields</code>中每个值得索引与对应表头的索引是一样的，因此不需要额外传入索引信息。简单来说就是我所实现的表格会根据<code>fields</code>的顺序，实现列之间的动态排序。你需要注意的是这一点很可能和你不一样。</p>
<p>到现在已经能够合并所有的列了，查看 Bootstrap-table 的配置信息发现，它有个属性是 <a href="https://bootstrap-table.com/docs/api/events/#onpostbody">onPostBody</a> 它会在 table body 加载完成是触发，所以把这个属性配置成我们的合并单元格方法即可。</p>
<pre><code class="language-typescript">// groups 为要合并的哪些列
onPostBody: function () {
    mergeCellsByFields($('#table' + ' tr'), $('#table'), groups);
}
</code></pre>
<p>再说一点不太相关的，我实现的是让用户可以自己选可以合并多少列，即用了一个可多选的下拉列表框供用户选择，根据用户选择的数量去合并，所以传入了一个<code>groups</code>参数。</p>
<p>最后推荐一个排序插件 <a href="https://github.com/Teun/thenBy.js">thenBy</a>，你可以用它进行多字段排序，比如用在合并相同单元格的场景，在绘制表格前先对数据进行排序，那么最后合并的结果就是把所有相同的数据聚合到一起了，并且还将它们合并到一起了，起到了一个隐形的过滤查询功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何解决跨域请求问题]]></title>
        <id>https://mengxiaoxu.github.io//post/MYYZrm7wn</id>
        <link href="https://mengxiaoxu.github.io//post/MYYZrm7wn">
        </link>
        <updated>2019-09-25T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569413513576.JPG" alt=""></figure>
<p>刚毕业入职，大部分时间还在培训，中间有一段时间的空闲时间，就学习了下 Angular，在学校都是编写的单体应用，所有代码都放在同一个工程下面，到公司使用的是前后端分离了，虽然后端程序也是我自己写的，但是有一些数据是从公司现有接口去拿的，然后就遇到让我纠结了两小时的<strong>跨域请求问题</strong>，为了避免出现上图中的尴尬场面，在这里做一个简单的总结输出。</p>
<h4 id="什么是跨域请求">什么是跨域请求</h4>
<p>跨域请求问题是浏览器的<strong>同源策略</strong>造成的，该策略不允许执行其它网站的脚本，是浏览器施加的安全限制。什么是同源？最初是指网页  A 设置的 Cookie 不能被网页 B 打开，包括三个相同：<strong>协议、域名、端口</strong>。这个同源是从 URL 判断的，不是从 IP 判断的，如果同一个服务器对应连个域名，这两个域名是不同源的。</p>
<pre><code>http://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 非跨域

http://www.nealyang.cn/index.html 调用 http://www.neal.cn/server.php 跨域,主域不同

http://abc.nealyang.cn/index.html 调用 http://def.neal.cn/server.php 跨域,子域名不同

http://www.nealyang.cn:8080/index.html 调用 http://www.nealyang.cn/server.php 跨域,端口不同

https://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 跨域,协议不同

localhost 调用 127.0.0.1 跨域
</code></pre>
<p>同源政策的目的是为了保护用户信息的安全，防止恶意网站窃取数据，随着互联网的发展，同源政策更加严格了，下面三种行为都会受到限制。</p>
<pre><code>（1） Cookie、LocalStorage 和 IndexDB 无法读取。
（2） DOM 无法获得。
（3） AJAX 请求不能发送。
</code></pre>
<p>所有的现代浏览器都对网络连接进行了安全限制，包括 XMLHttpRequest，如果你的 web 应用程序和其使用的数据在同一个服务器，你不会遇到跨域请求问题。但是当你的 web 应用程序和 web 服务数据不在同一个服务器时，就会被浏览器限制连接了。</p>
<h4 id="常用解决方案">常用解决方案</h4>
<p>对于跨域请求有很多的解决方案，最常用的解决方案是在你的 web 服务器上面<strong>设置代理</strong>。在设置代理之前就通过，应用程序直接去请求另一个服务器下的数据；设置代理之后，应用程序从自己的 web 服务器中请求数据，再由代理去请求数据，这样 web 服务器拿到数据之后返回给应用程序即可。从浏览器角度看，就是从同一个服务器拿的数据，并没有进行跨域请求。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569413461355.gif" alt=""></figure>
<p>通俗易懂的说，你家的宠物狗不会吃别家的食物，因为它担心别人的食物会把自己给药死，所以你的狗狗只管找你要食物，你是它的主人，它绝对相信你，而你可以鉴别别人给的食物是不是安全的。类比，小狗就是浏览器，你就是代理。</p>
<h4 id="angular-中的解决办法">Angular 中的解决办法</h4>
<p>上面所说的解决方案在开发过程中不方便操作，每新发一个接口都到服务器中去配置一下，不仅麻烦而且效率低下。首先说一下在 Angular 中一个人比较常用的解决方法，默认你在使用<code>angular-cli</code>构建你的项目，我们可以创建一个代理配置文件<code>proxy.conf.json</code>（假设你的后端服务的访问地址为<code>10.121.163.10:8080</code>），代理配置文件如下：</p>
<pre><code class="language-json">{
  &quot;/api&quot;: {
    &quot;target&quot;: &quot;http://10.121.163.10:8080&quot;,
    &quot;secure&quot;: false
  }
}
</code></pre>
<p>然后修改<code>package.json</code>文件中的启动命令为<code>&quot;start&quot;: &quot;ng serve --proxy-config proxy.conf.json&quot;</code>，启动项目时使用<code>npm start</code>即可解决跨域请求问题。</p>
<p>上述解决方案仅在开发时使用，你当然可以使用 tomcat、nginx 配置代理，但是这很麻烦，需要打包代码部署，为了保证效率，我们想写完了立刻测试，同时也不想麻烦做后端的同学，在项目发布时，应该把代理配置到服务器中去；修改启动命令也不是必须的，你也可以选择每次使用 <code>ng serve --proxy-config proxy.conf.json</code>命令启动项目；示例代理配置文件内容可以有更多的属性，可以通过网络查阅相关资料。</p>
<h4 id="后端解决办法">后端解决办法</h4>
<p>我的后端是是用 tornado 实现的，然后我又写了一个单独的页面用于在大屏幕上展示相关数据，没有用 Angular 了，要通过 AJAX请求数据，又怎么解决跨域请求问题呢？这时就需要设置请求头了，让后端允许跨域请求。</p>
<p>这时需要了解一下<strong>简单请求</strong>和<strong>非简单请求</strong>了，简单请求就是只发送一次请求的请求；非简单请求会发送数据之前先发一次请求做<strong>预检</strong>，通过预检后才能再发送一次请求用于数据传输。</p>
<p>更清晰区别，满足下列两大条件的属于简单请求，而非简单请求就是请求方法为<code>PUT</code>或<code>DELETE</code>，或者 <code>Content-Type</code>字段是<code>application/json</code>的请求。</p>
<blockquote>
<p>1.请求方法为 GET、POST、HEAD之一<br>
2.HTTP头信息不超出字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type，并且 Content-Type 的值仅限于 application/x-www-form-urlencoded、multipart/form-data、text/plain。</p>
</blockquote>
<p>对于简单请求，只需要设置一下响应头就可以了。</p>
<pre><code class="language-python">class TestHandler(tornado.web.RequestHandler):
    def get(self):
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        # 可以把 * 写成具体的域名
        self.write('cors get success')
</code></pre>
<p>对于复杂请求，需要设置预检方法，如下所示：</p>
<pre><code class="language-python">class CORSHandler(tornado.web.RequestHandler):
    # 复杂请求方法put
    def put(self):
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        self.write('put success')
    # 预检方法设置
    def options(self, *args, **kwargs):
        #设置预检方法接收源
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        #设置预复杂方法自定义请求头h1和h2
        self.set_header('Access-Control-Allow-Headers', &quot;h1,h2&quot;)
        #设置允许哪些复杂请求方法
        self.set_header('Access-Control-Allow-Methods', &quot;PUT,DELETE&quot;)
        #设置预检缓存时间秒,缓存时间内发送请求无需再预检
        self.set_header('Access-Control-Max-Age', 10)
</code></pre>
<p>本人不太懂前端知识，更多的前端跨域解决方案可以参考下面列出的文章，除第一篇外，其他都介绍了前端跨域解决方法。</p>
<p>参考资料及推荐文章</p>
<pre><code>标题：JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls
链接：https://developer.yahoo.com/javascript/howto-proxy.html?guccounter=1

标题：别慌，不就是跨域么!
链接：https://mp.weixin.qq.com/s/A0Oi-fUrmboRPPeNEjG3aw

标题：跨域资源共享 CORS 详解
链接：http://www.ruanyifeng.com/blog/2016/04/cors.html

标题：AJAX请求和跨域请求详解（原生JS、Jquery）
链接：http://www.cnblogs.com/tkqasn/p/5869175.html

标题：JavaScript跨域总结与解决办法
链接：http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读高于自己的作品，远离精神毒品]]></title>
        <id>https://mengxiaoxu.github.io//post/FoEH1GV6f</id>
        <link href="https://mengxiaoxu.github.io//post/FoEH1GV6f">
        </link>
        <updated>2019-09-25T12:06:54.000Z</updated>
        <content type="html"><![CDATA[<p>关于阅读与写作的重要性，可能每个人都多少有一些概念。阅读打开世界的大门，写作提升语言组织能力。</p>
<p>还在读大一大二的时候，我很崇拜那些随随便便就能做一个网站、写一个复杂算法的大神。那时候仅仅盯着技术，认为只要技术好，怎么样都行，因此在大二阶段，我没有读过一本技术之外的书籍，现在看来是眼界狭隘了。</p>
<p>专业能力是生存之本，但是其他方面的能力也同样重要，大学能交给我们的只是一个在社会上赖以生存的本领（实际上一部分连赖以生存的本领都没有从大学学到），其他的技能需要靠自己的主动学习。</p>
<p>阅读是一种了解知识的重要手段，但并不是所有的阅读都是有效的，甚至有的阅读是精神毒品。</p>
<p>阅读需要挑选高于自己的作品，要能仰视它，才能攀登。现在的生活节奏很快，碎片化阅读成了很多人的阅读方式；有人抨击碎片化阅读，也有人提倡碎片化阅读，每个人由不同的观点，我个人是赞同碎片化阅读的。</p>
<p>来自互联网的阅读内容和自己大多是平等的，每个人都在使用微信，但我相信很多人都有屏蔽一些人朋友圈的习惯，因为你会选择跟你脾气相同、你喜欢的、跟你水平接近内容去阅读；现在的 APP 也很多，而且很多首次注册都会让你选择自己感兴趣的内容，所以也就会失去挑战自我的机会。</p>
<p>阅读是提升认知的重要手段，人与人之间的根本差距在于认知，如果读了一本书之后能让自己的认知得到提升，那么这就没白读；当然，如果读完一本书或是一篇文章之后能让有很大程度的转变，那这种认知的提升我相信是宝贵的财富，而且认识是伴随终身的。能达到这样效果的好文章、好书肯定少之又少，对我个人影响的最大的一本书是《把时间当作朋友》，我很推荐这本书，接触这本书算我认知上的一个转折点。</p>
<p>也有一些阅读是日积月累对自己产生影响的。我曾经关注了近 150 个公众号，从里面精挑细选了一部分原创公众号留下，涉及技术、新闻、产品、理财等方面。我现在每天的阅读主要就是公众号阅读和付费加入的几个知识星球，以及得到上面的付费知识。</p>
<p>日积月累，我筛选有效信息的能力也更强了，我认为筛选信息能力在这个信息爆炸的时代是很重要的。</p>
<p>有一次听到朋友说：“文章太长了，我不想看”。我没说话，只给了一个无奈的眼神，因为他只想要一个结论，因为这可以很轻松的获得一种愉悦感，而且对大脑来说，也是最容易接受的，但是慢慢地，大脑就会失去独立思考的能力。</p>
<p>从产品角度讲，不得不佩服头条对人性的洞察，为了“懂你”，在自己的产品上加入推荐算法，但实际上是让你把时间花在他们产品的身上，把产品做到这种程度，不得不说是很牛的。</p>
<p>但是像抖音、快手、头条、微博这些产品我认为基本都是在浪费用户时间（我还没有用过快手和微博，评价它们有点冒昧了），他们无异于精神毒品，吞噬你的时间。我并不是讨厌这些产品，我自己也喜欢体验新的产品，我只是觉得把宝贵的时间放到更有价值的事情上去，那么就会比周边人更加优秀。</p>
<p>需要选择的是高于自己内容阅读，而不是把时间都花在那种不需要思考就能得到的愉悦上去；如果把大部分时间都花在轻易就能获得的愉悦感上，那么你应该正在一步步颓废。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录在南京大学的半天]]></title>
        <id>https://mengxiaoxu.github.io//post/aSkANU6p0</id>
        <link href="https://mengxiaoxu.github.io//post/aSkANU6p0">
        </link>
        <updated>2019-09-25T12:01:17.000Z</updated>
        <content type="html"><![CDATA[<p>因为工作需要，到南京出差了半个月，中间利用周末和最好的朋友疯了一天，之后自己又一个人到南京大学鼓楼校区逛了逛。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412914052.JPG" alt=""></figure>
<p>不会勾搭妹子的我总是能勾搭到老爷爷，到南大就勾搭了一个 86 岁高龄的老教授，他毕业于中山大学，年轻时候是做地质工作的。</p>
<p>我就像个熊孩子一样要爷爷给我讲有趣的故事，要听他讲我们这一代人或者是大部分人都不知道的历史。</p>
<p>爷爷虽然已经是快到耄耋之年的人了，但是对年轻时候的事记得很清楚，只是对最近的事记不起来。这篇文章仅仅是记录一下爷爷所讲的趣事。</p>
<p>爷爷年轻时候接到中科院的任务，前往内蒙古考察。在考察期间他们用汽车压死过一只狼，而且当时吃了狼肉，一行 30 多个人都吃过那匹狼的心，但是没有吃过狗肺。</p>
<p>据爷爷说，狼是很狡猾的动物，他们用汽车去追狼，狼就在原地不跑，等到你离它只有 10 来米的时候，突然拐弯跑了，这样的情况他们一共遇到了 6 次。这和《狼图腾》一书中的描写基本一致，狼有先进的军事文化。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412927749.JPG" alt=""></figure>
<p>爷爷告诉我，南大起源于金陵大学，南京大学的标志性建筑「北大楼」是个教堂的样子，金陵大学本来是个教会大学，现在的「北大楼」就是原来的「钟楼」。</p>
<p>南大的地下有隧道，是当年毛主席提倡「深挖洞、广积粮、不称霸」时挖的，目的是为了防空。后来被南京食品公司用来存放香蕉，就是那种没有熟的香蕉，在隧道里面放熟了，再拿出来卖。不过现在隧道所有的口都没堵上了，完全废弃了。</p>
<p>在南大，有一些楼中间有 5 层，然后到两遍就只有 3 层了，整体看来像是个三角形。实际上这些楼当年都是要修 8 层的，因为那时候没钱，建着建着发现没资金了，所以就封顶了。</p>
<p>但是南大计算中心那栋楼只有 3 层却不是因为没钱，而是因为它旁边是消防大队，本来也是要建 8 层的，消防队说建高了挡住了他们视线，不能及时发现火情。爷爷笑着对我说：“但是也没见他们在上面拿个望远镜望啊！”。</p>
<p>我们都知道「五四运动」，但是却很少有人知道「四五运动」，这个运动的起源就在南大，当时 300 多学生（我回来查资料说是 400）发起了这个运动，后来演变为全国性的运动，直接带动了半年后四人帮被粉碎。</p>
<p>那是爷爷是个老师，他说他们教职工是很支持这些学生的，但是不敢公开性的支持。学生们很聪明，把标语刷到火车上，但是所有出南京的火车都被四人帮用水把标语给冲刷掉了，学生们就用沥青往火车上面写，才通过火车把这项运动的信息带到了全国各地。</p>
<blockquote>
<p>我回来后查了一点资料，「四五运动」的起源是因为周恩来总理的去世，四人帮居然压制人民群众悼念周恩来，诬陷邓小平，而那时的毛主席也已经病到无法行动。</p>
</blockquote>
<blockquote>
<p>人们把花圈都放到人民英雄纪念碑前悼念周总理，却被四人帮给清理了，北京广大人民群众在“还我花圈，还我战友”的口号下行成了天安门广场大规模的群众抗议运动。</p>
</blockquote>
<blockquote>
<p>那也是一个诗意的年代，人们通过写诗来表达自己心中的愤怒，把小瓶子挂在树上，蕴意着期待邓小平的归来。那段时间四人帮应该是很难过的，从姚文元的日记就可以看出来。</p>
</blockquote>
<p>爷爷还给我讲了一点他们的研究，他们研究行政规划的很多人认为，中国现在的行政划分有很多缺点的，中国应该划分 50~80 个省级单位。现在中国的行政级别也有问题，宪法规定行政层级只有三级（这一点我没查），而现在很多地方县下面是镇，镇下面还有乡，严格讲这是违宪的。</p>
<p>快到午饭时间时，爷爷还教我写了一会儿字，有的简体字很难看，比如「龍飛鳳舞」用繁体字写出来很好看，但是用简体字写出来就特难看。要想练好毛笔字，把三个字写好了就行了，然而我现在只记得一个“飛”字了，这可能就是老师们常说的「你又还给我了」。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[告别囤干货，你才能真正进步]]></title>
        <id>https://mengxiaoxu.github.io//post/8-A2fl99e</id>
        <link href="https://mengxiaoxu.github.io//post/8-A2fl99e">
        </link>
        <updated>2019-09-25T11:52:46.000Z</updated>
        <content type="html"><![CDATA[<p>这两天，没事整理了自己的微信收藏和 QQ 收藏文件夹下面的文章。发现了一个在大多数人身上都存在的问题，那就是<strong>囤干货</strong>。</p>
<p>我使用微信的时间比较晚，从14年才开始，但是仅仅不到4年的时间，在微信收藏里面就有几百篇文章，有一些传授技能的文章，比如 word、ps 等简单教程；其他一些属于心灵鸡汤类文章（现在反倒不觉得这类文章值得看），还有一些搞笑的文章，当然里面也夹杂着些许的优秀视频。文章数量数 14 年和 15 年最多。</p>
<p>现在回头看，我当时就陷入了囤文章的陷阱了，或者说自己是在“假装阅读”。仔细一想，其实生活中大多数人都有类似的举动。早成起床、饭后的一段时间、晚上睡觉前，这些时间大多数人都习惯性的去翻翻公众号、朋友圈，这里面不乏有好文章、干货文章。然而没多少人会静下心来把文章读完，而是在大概读到一半的时候，选择收藏这篇文章，然后在心里告诉自己，明天要好好读一下这篇文章。到了明天，其实又是重复了今天的这样一个过程。</p>
<p>记得大概一年前也无意中看到大学认识的一位师弟发的说说，内容如下：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412401636.jpg" alt=""></figure>
<p>上面的图是我特地翻出来的，一年后这个师弟又发了一条说说，存满了两个云盘，应该是有 5000 G 左右的资源。</p>
<p>我认为这都是在假装学习，而且假装学习的人不计其数。为什么上学的时候，那些每天都静静的待在教室学习的同学，成绩反倒不是很好呢？而且大多数这样的学生在班级都是排在中等，而成绩好的学生却不是学习投入最多的人。背后的原因显而易见。</p>
<p>我囤课最严重的时间段是也是 14 年和 15 年，网上有不少干货资源，什么 Linux、各种项目实战、计算机网络等等培训视频不计其数。那时候干的第一件事就是，上百度云把这些资源下下来，而且一个资源往往要下一周甚至更久；然后告诉自己，下周开始每天看一段视频，但是最终的结果是过去了 N 个下周，依然没有去处理这些资源。</p>
<p>现在博客、公众号也有一些不知道是为了获取更多人的关注，还是仅仅是做公益，文章末尾会标注：关注公众号，回复“XXXXX”，即可获得多少多少G的资源，这个多少一般是在 500 以上。我个人现在是对这类文章没有什么兴趣的，因为几百 G 甚至上千 G 的东西，我是不可能看完的，我清楚自己的能力，我也不否认可能有人有毅力能看完，那肯定是凤毛菱角了，我一个普通人不与凤毛菱角对比。</p>
<p>当然，我现在的认识相比几年前，得到了一些提升，至少我现在不糊干囤课之类的事了，仅仅是把干货囤在那里，其时你还是昨天的自己，并没有进步。现在我都会把自己收藏的好文章在一周之内处理掉。</p>
<p>所以要想真正取得进步，首先就需要告别囤课的习惯，不能假装学习，如果学习是为了给比别人看，那还不如不学。文章仅是我个人的一点感悟，没有文采逻辑和言，总之希望与你共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么处理排序数组比未排序数组快]]></title>
        <id>https://mengxiaoxu.github.io//post/SpXxa8r-v</id>
        <link href="https://mengxiaoxu.github.io//post/SpXxa8r-v">
        </link>
        <updated>2019-09-25T11:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天在群里看到一个有意思的问题——为什么处理排序数组比处理没有排序的数组要快，这个问题来源于 <a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">StackoverFlow</a>，虽然我看到代码略微知道原因，但是模模糊糊不够清晰，搜了很多博客也讲的不够明白，所以就自己来总结了。</p>
<p>首先来看一下问题，下面是很简单的一段代码，随机生成一些数字，对其中大于 128 的元素求和，记录并打印求和所用时间。</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c &lt; arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i &lt; 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c &lt; arraySize; ++c)
            {
                if (data[c] &gt;= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println(&quot;sum = &quot; + sum);
    }
}
</code></pre>
<p>我的运行结果：分别在对数组排序和不排序的前提下测试，在不排序时所用的时间比先排好序所用时间平均要多 10 ms。这不是巧合，而是必然的结果。</p>
<p>问题就出在那个<code>if</code>判断上面，在旧文<a href="https://mp.weixin.qq.com/s/8WwJK0CfKz1o_bwefxBd5Q">顺序、条件、循环语句的底层解释</a>中其实已经提到了造成这种结果的原因，只是旧文中没有拿出具体的例子来说明。</p>
<p>为了把这个问题搞明白，需要先对<code>流水线</code>有一定的了解。计算机是指令流驱动的，执行的是一个一个的指令，而执行一条指令，又要经过<code>取指、译码、执行、访存、写回、更新</code>六个阶段（不同的划分方式所包含的阶段不一样）。</p>
<p>六个阶段使用的硬件基本是不一样的，如果一条指令执行完再去执行另一条指令，那么在这段时间里会有很多硬件处于空闲状态，要使计算机的速度变快，那么就不能让硬件停下来，所以有了流水线技术。</p>
<p>流水线技术通过将指令重叠来实现几条指令并行处理，下图表示的是三阶段指令时序，即把一个指令分为三个阶段。在第一条指令的 B 阶段，A 阶段相关的硬件是空闲的，于是可以将第二条指令的 A 阶段提前操作。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412133980.png" alt=""></figure>
<p>很明显，这种设计大幅提高了指令运行的效率，聪明的你可能发现问题了，要是不知道下一条指令是什么怎么办，那提前的阶段也就白干了，那样流水线不就失效了？没错，这就是导致开篇问题的原因。</p>
<p>让流水线出问题的情况有三种：1、<code>数据相关</code>，后一条指令需要用到前一条指令的运算结果；2、<code>控制相关</code>，比如无条件跳转，跳转的地址需要在译码阶段才能知道，所以跳转之后已经被取出的指令流水就需要清空；3、<code>结构相关</code>，由于一些指令需要的时钟周期长（比如浮点运算等），长时间占用硬件，导致之后的指令无法进入译码等阶段，即它们在争用同一套硬件。</p>
<p>代码中的<code>if (data[c] &gt;= 128)</code>翻译成机器语言就是跳转指令，处理器事先并不知道要跳转到哪个分支，那难道就等知道了才开始下一条指令的取指工作吗？处理器选择了假装知道会跳转到哪个分支（不是谦虚，是真的假装知道），如果猜中了是运气好，而没有猜中那就浪费一点时间重新来干。</p>
<p>没有排序的数组，元素是随机排列的，每次<code>data[c] &gt;= 128</code>的结果也是随机的，前面的经验就不可参考，所以下一次执行到这里理论上还是会有 50% 的可能会猜错，猜错了肯定就需要花时间来修改犯下的错误，自然就会浪费更多的时间。</p>
<p>对于排好序的数组，开始几次也需要靠猜，但是猜着猜着发现有规律啊，每次都是往同一个分支跳转，所以以后基本上每次都能猜中，当遍历到与 128 分界的地方，才会出现猜不中的情况，但是猜几次之后，发现这又有规律啊，每次都是朝着另外一个相同分支走的。</p>
<p>虽然都会猜错，但是在排好序的情况下猜错的几率远远小于未排序时的几率，最终呈现的结果就是处理排序数组比未排序数组快，其原因就是流水线发生了大量的控制相关现象，下面通俗一点，加深一下理解。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412222054.jpg" alt=""></figure>
<p>远在他方心仪多年的姑娘突然告诉你，其实她也喜欢你，激动的你三天三夜睡不着觉，决定开车前往她的城市，要和她待在一起，但是要去的路上有很多很多岔路，你只能使用的某某地图导航，作为老司机并且怀着立马要见到爱人心情的你，开车超快，什么样罚单都不在乎了。</p>
<p>地图定位已经跟不上你的速度了，为了尽快到达，遇到岔路你都是随机选一条路前进，遗憾的是，自己的选择不一定对（我们假设高速可以回退），走错路了就要重新回到分岔点，这就对应着未排序的情况。</p>
<p>现在岔路是有规律的，告诉你开始一直朝着一边走，到某个地点后会一直朝着另一边走，你只需要花点时间去探索一下开始朝左边还是右边，到了中间哪个地点会改变方向就可以了，相比之下就能节省不少时间了，尽快见到自己的爱人，这对应着排好序的情况。</p>
<blockquote>
<p>最后的故事改编自两个人的现实生活，一位是自己最好的朋友之一，谈恋爱开心的睡不着觉；另一位是微信上的一位好友，为了对方从北京裸辞飞到了深圳。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数调用与空间分配]]></title>
        <id>https://mengxiaoxu.github.io//post/cYbqHG1mh</id>
        <link href="https://mengxiaoxu.github.io//post/cYbqHG1mh">
        </link>
        <updated>2019-09-25T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们在编程序的时候，都会把某一个特定功能封装在一个函数里面，对外暴露一个接口，而隐藏了函数行为的具体实现，一个大型的复杂系统里面包含了很多这样的小函数，我们称之为<strong>过程</strong>。</p>
<p>过程是相对独立的小模块，系统的运行需要这些过程的紧密合作，这种合作就是函数调用。</p>
<p>在一个函数执行时调用别的函数，比如 P 调用 Q，需要执行一些特定的动作。<code>传递控制</code>，在调用 Q 之前，控制权在 P 的手里，既然要调用 Q，那么就需要把控制权交给 Q；<code>传递数据</code>，就是函数传参；<code>分配与释放内存</code>，在开始时，Q 可能需要位局部变量分配空间，结束时又必须释放这些存储空间。</p>
<p>大多数语言都使用栈提供的先进后出机制来管理内存，x86-64 可以通过通用寄存器传递最多 6 个整数值（整数或地址），如果超过 6 个，那就需要在栈中分配内存，并且通过栈传递参数时，所有数据的大小都要向 8 的倍数对齐。将控制权从 P 转交给 Q，只需要将 PC（程序计数器）的值置为 Q 代码的起始位置，并记录好 P 执行的位置，方便 Q 执行完了，继续执行 P 剩余的代码。</p>
<p>在函数的传参、执行中，多多少少都需要空间来保存变量，局部数据能保存在寄存器中就会保存在寄存器中，如果寄存器不够，将会保存在内存中。除了寄存器不够用的情况，还有数组、结构体和地址等局部变量都必须保存在内存中。分配内存很简单，只需要减小栈指针的值就行了，同样释放也只需要增加栈指针。</p>
<p>在函数执行过程中，处理栈指针<code>%rsp</code>，其它寄存器都被分类为<code>被调用者保存寄存器</code>，即当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。</p>
<p>所以递归也就不难理解了，初学算法总觉得递归有点奇妙，怎么自己调用自己，而实际上对于计算机来说，它和调用其它函数没什么区别，在计算机眼里，没有自身与其它函数的区别，所有被调用者都是其它人。</p>
<p>数组是编程中不可或缺的一种结构，“数组是分配在连续的内存中”这句话已经烂熟于心了，历史上，C 语言只支持大小在编译时就能确定的多维数组，这个多多少少有一些不便利，所以在<code>ISO C99</code>标准中就引入了新的功能，允许数组的维度是表达式。</p>
<pre><code class="language-c">int A[expr1][expr2]
</code></pre>
<p>因为数组是连续的内存，所以很容易就能访问到指定位置的元素，它通过首地址加上偏移量即可计算出对应元素的地址，这个偏移量一定意义上就是由索引给出。</p>
<p>比如现在有一个数组<code>A</code>，那么<code>A[i]</code>就等同于表达式<code>* (A + i)</code>，这是一个指针运算。C 语言的一大特性就是指针，既是优点也是难点，单操作符<code>&amp;</code>和<code>*</code>可以产生指针和简介引用指针，也就是，对于一个表示某个对象的表达式<code>expr</code>，<code>&amp;expr</code>给出该对象地址的一个指针，而对于一个表示地址的表达式<code>Aexpr</code>，<code>*Aexpr</code>给出该地址的值。</p>
<p>即使我们创建嵌套（多维）数组，上面的一般原则也是成立的，比如下面的例子。</p>
<pre><code class="language-c">int A[5][3];

// 上面声明等价于下面
typedef int row3_t[3];
row3_t A[5];
</code></pre>
<p>这个数组在内存的中就是下面那个样子的。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411935351.png" alt=""></figure>
<p>还有一个重要的概念叫做<code>数据对齐</code>，即很多计算机系统要求某种类型的对象的地址必须是某个值 K（一般是2、4 或 8）的倍数，这种限制简化了处理器和内存接口之间的设计，甚至有的系统没有进行数据对齐，程序就无法正常运行。</p>
<p>比如现在有一个如下的结构体。</p>
<pre><code class="language-c">struct S1 {
    int i;
    char c;
    int j;
}
</code></pre>
<p>如果编译器用最小的 9 字节分配，那么将是下面的这个样子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411921819.png" alt=""></figure>
<p>但是上面这种结构无法满足 i 和 j 的 4 字节对齐要求，所以编译器会在 c 和 j 之间插入 3 个字节的间隙。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411906634.png" alt=""></figure>
<p>在极客时间专栏中有这样一段代码。</p>
<pre><code class="language-c">int main(int argc, char *argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i &lt;= 3; i++){
        arr[i] = 0;
        printf(&quot;Hello world!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这段代码神奇的是在某种情况下会一直循环的输出<code>Hello world</code>，并不会结束，在<a href="https://mp.weixin.qq.com/s/BRRReU3akhqh8vgm59GNvA">计算机系统漫游（补充）</a>中也提到过。</p>
<p>造成上面这种结果是因为函数体内的局部变量存在栈中，并且是连续压栈，而 Linux 中栈又是从高向低增长。数组<code>arr</code>中是 3 个元素，加上 i 是 4 个元素，刚好满足 8 字节对齐（编译器 64 位系统下默认会 8 字节对齐），变量<code>i</code>在数组<code>arr</code>之前，即<code>i</code>的地址与<code>arr</code>相邻且比它大。</p>
<p>代码中很明显访问数组时越界了，当<code>i</code>为 3 时，实际上正好访问到变量<code>i</code>的地址，而循环体中又有一句<code>arr[i] = 0;</code>，即又把<code>i</code>的值设置为了 0，由此就导致了死循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[顺序、条件、循环语句的底层解释]]></title>
        <id>https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi</id>
        <link href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">
        </link>
        <updated>2019-09-25T11:19:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="顺序结构">顺序结构</h4>
<h5 id="数据传送指令">数据传送指令</h5>
<p>我们都清楚，绝大多数编译器都把汇编语言作为中间语言，把汇编语言程序变成可运行的二进制文件早就解决了，所以现在的高级语言基本上只需要把自己翻译成汇编语言就可以了。</p>
<p>汇编指令总共只有那么多，大多数指令都是对数据进行操作，比如常见的数据传送指令<code>mov</code>。不难理解，被操作数据无非有三种形式，<strong>立即数</strong>，即用来表示常数值；<strong>寄存器</strong>，此时的数据即存放在指定寄存器中的内容；<strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置。</p>
<p>需要注意的是，到了汇编层级，就不像高级语言那样随随便便<code>int</code>就能和<code>long</code>类型的数据相加减，他们在底层所占有的字节是不一样的，汇编指令是区分操作数据大小的，比如数据传送指令，就有下面这些品种（x86-64 对数据传送指令加了一条限制：两个操作数不能都指向内存位置）。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569410442560.png" alt=""></figure>
<h5 id="压栈与弹栈">压栈与弹栈</h5>
<p>对于栈，我想不必多讲，IT 行业的同学都清楚，它是一种线性数据结构，其中的数据遵循“先进后出”原则，寄存器<code>%rsp</code>保存着栈顶元素的地址，即栈顶指针。一个程序要运行起来，离不开栈这种数据结构。</p>
<p>栈使用最多的就是弹栈<code>popq</code>和压栈<code>pushq</code>操作。比如将一个四字值压入栈中，栈顶指针首先要减 8（栈向下增长），然后将值写到新的栈顶地址；而弹栈则需要先将栈顶数据读出，然后再将栈指针加 8。所以<code>pushq</code>和<code>popq</code>指令就可以表示为下面的形式。</p>
<pre><code class="language-c">// 压栈
subq $8, %rsp
movq %rbp, (%rsp)

// 弹栈
movq (%rsp), %rax
addq $8, %rsp
</code></pre>
<p>其他还有算术、逻辑、加载有效地址、移位等等指令，可以查阅相关文档了解，不作过多介绍，汇编看起来确实枯燥乏味。</p>
<h4 id="条件结构">条件结构</h4>
<p>前面讲的都是顺序结构，我们的程序中不可能只有顺序结构，条件结构是必不可缺的元素，那么汇编又是如何实现条件结构的呢？</p>
<p>首先你需要知道，除了整数寄存器，CPU 还维护着一组<strong>条件码寄存器</strong>，我们主要是了解如何把高级语言的条件结构转换为汇编语言，不去关注这些条件码寄存器，只需要知道汇编可以通过检测这些寄存器来执行条件分支指令。</p>
<h5 id="if-else-语句">if-else 语句</h5>
<p>下面是 C 语言中的<code>if-else</code>语句的通用形式。</p>
<pre><code class="language-c">if(test-expr){
    then-statement
}else{
    else-statement
}
</code></pre>
<p>汇编语言通常会将上面的 C 语言模板转换为下面的控制流形式，只要使用条件跳转和无条件跳转，这种形式的控制流就可以和汇编代码一一对应，我们以 C 语言形式给出。</p>
<pre><code class="language-c">    t = test-expr;
    if(!t){
        goto false;
    }
    then-statement;
    goto done;
false:
    else-statement;
done:
</code></pre>
<p>但是这种条件控制转移形式的代码在现代处理器上可能会很低效。原因是它无法事先确定要跳转到哪个分支，我们的处理器通过<strong>流水线</strong>来获得高性能，流水线的要求就是事先明确要执行的指令顺序，而这种形式的代码只有当条件分支求值完成后，才能决定走哪一个分支。即使处理器采用了非常精密的分支预测逻辑，但是还是有错误预测的情况，一旦预测错误，那将会浪费 15 ~ 30 个时钟周期，导致性能下降。</p>
<blockquote>
<p>在流水线中，把一条指令分为多个阶段，每个阶段只执行所需操作的一小部分，比如取指令、确定指令类型、读数据、运算、写数据以及更新程序计数器。流水线通过重叠连续指令的步骤来获得高性能，比如在取一条指令的同时，执行它前面指令的算术运算。所以如果事先不知道指令执行顺序，那么事先所做的预备工作就白干了。</p>
</blockquote>
<p>为了提高性能，可以改写成使用条件数据传送的代码，比如下面的例子。</p>
<pre><code class="language-c">v = test-expr ? then-expr : else-expr；

// 使用条件数据传送方法
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t){
    v = ve;
}
</code></pre>
<p>这样改写，就能提高程序的性能了，但是并不是所有的条件表达式都可以使用条件传送来编译，一般只有当两个表达式都很容易计算时，编译器才会采用条件数据传送的方式，大部分都还是使用条件控制转移方式编译。</p>
<h5 id="switch-语句">switch 语句</h5>
<p><code>switch</code>语句可以根据一个整数索引值进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。为了让<code>switch</code>的实现更加高效，使用了一种叫做<strong>跳转表</strong>的数据结构（Radis 也是用的跳表）。跳转表是一个数组，表项 i 是一个代码段的地址，当开关情况数量比较多的时候，就会使用跳转表。</p>
<p>我们举个例子，还是采用 C 语言的形式表是控制流，要理解的是执行<code>switch</code>语句的关键步骤就是通过跳转表来访问代码的位置。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
    long val = x;
    switch(n){
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
        case 103:
            val += 11;
            break;
        case 104:
        case 105:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
</code></pre>
<p>要注意的是，上面的代码中有的分支没有<code>break</code>，这种问题在笔试中会经常遇到，没有<code>break</code>会继续执行下面的语句，即变成了顺序执行。上面的代码会被翻译为下面这种控制流。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
        static void *jt[7] = {
            &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,
            &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,
            &amp;&amp;loc_D
        };
        unsigned long index = n - 100;
        long val;
        if(index &gt; 6){
            goto loc_def;
        }
        goto *jt[index];
    loc_A:
        val = x * 13;
        goto done;
    loc_B:
        x = x + 10;
    loc_C:
        val = x + 11;
        goto done;
    loc_D:
        val = x * x;
        goto done;
    loc_def:
        val = 0;
    done:
        *dest = val;
}
</code></pre>
<h4 id="循环结构">循环结构</h4>
<p>C 语言中有<code>do-while</code>、<code>while</code>和<code>for</code>三种循环结构，它们的通用形式一般都长下面那样。</p>
<pre><code class="language-c">// do-while
do
    body-statement
    while(test-expr);
    
// while
while(test-expr)
    body-statement
    
// for
for(init-expr; test-expr; update-expr)
    body-statement
</code></pre>
<p><code>do-while</code>的特点是<code>body-statement</code>一定会执行一次，所以我们可以将<code>do-while</code>翻译成下面的控制流形式，很容易就能联想到它的汇编形式。</p>
<pre><code class="language-c">loop:
    body-statement;
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p><code>while</code>循环我们给出两种形式的控制流，其中一种包含<code>do-while</code>形式，如下所示。</p>
<pre><code class="language-c">// 第一种形式
t = test-expr;
if(!t){
    goto done;
}
do
    body-statement;
    while(test-expr);
done:


// 第二种形式
    goto test;
loop:
    body-statement;
test:
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p>面试的时候，有的面试官会问你<code>for</code>循环的执行顺序，现在深入理解了三种循环的机制，再也不怕面试官啦。<code>for</code>循环可以转换成如下的<code>while</code>形式。</p>
<pre><code class="language-c">init-expr;
while(test-expr){
    body-statement;
    update-expr;
}
</code></pre>
<p>有了这种形式的<code>for</code>循环，我们只需要将其中的<code>while</code>部分再翻译一下就好了，前文给出了两种<code>while</code>翻译的方式，而具体采用哪种方式，取决于编译器优化的等级。</p>
<h4 id="总结">总结</h4>
<p>计算机就是用那么几条简简单单的指令就完成了各种复杂的操作，不得不折服于计算机科学家们的魅力。现在人工智能被炒的很火热，然后人是事件、情感驱动的，而计算机是控制流驱动的，所以从架构上就决定了，冯诺依曼体系计算机实现的都是弱人工智能。</p>
]]></content>
    </entry>
</feed>