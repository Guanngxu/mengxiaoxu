<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-09-26T14:26:13.851Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[怎样才能开开心心的呢？]]></title>
        <id>https://mengxiaoxu.github.io//post/o9IjztOrR</id>
        <link href="https://mengxiaoxu.github.io//post/o9IjztOrR">
        </link>
        <updated>2019-09-08T13:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。</p>
<p>说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。</p>
<p>媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。</p>
<p>包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”</p>
<p>像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。</p>
<p>我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。</p>
<p>很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。</p>
<p>这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。</p>
<p>于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。</p>
<p>当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。</p>
<p>当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。</p>
<p>举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。</p>
<p>我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。</p>
<p>另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。</p>
<p>周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？</p>
<p>凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅析浏览器缓存机制]]></title>
        <id>https://mengxiaoxu.github.io//post/qCt13nLLT</id>
        <link href="https://mengxiaoxu.github.io//post/qCt13nLLT">
        </link>
        <updated>2019-04-26T12:29:29.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。</p>
<h4 id="http-报文">HTTP 报文</h4>
<p>HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。</p>
<h4 id="缓存概述">缓存概述</h4>
<p>浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569414647062.png" alt=""></figure>
<p>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有<strong>强制缓存</strong>和<strong>协商缓存</strong>两类，也有人把协商缓存叫对比缓存。</p>
<h4 id="强制缓存">强制缓存</h4>
<p>我们先自己想一下，使用缓存是不是会有下面几种情况出现。</p>
<ul>
<li>
<p>存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；</p>
</li>
<li>
<p>存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；</p>
</li>
<li>
<p>不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。</p>
</li>
</ul>
<p>控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，并且<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<h6 id="expires">Expires</h6>
<p><code>Expires</code>是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于<code>Expires</code>值，就直接使用缓存数据。到了 HTTP/1.1，<code>Expires</code>已经被<code>Cache-Control</code>替代了。</p>
<p><code>Expires</code>被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。</p>
<h6 id="cache-control">Cache-Control</h6>
<p><code>Cache-Control</code>是 HTTP/1.1 中最重要的规则，主要取值为：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与<code>private</code>一样。</td>
</tr>
<tr>
<td><code>private</code></td>
<td>所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认值。</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存内容将在 xxx 秒后失效</td>
</tr>
</tbody>
</table>
<p>我们可以看看下面这个例子，可以从截图中看到<code>Expires</code>是一个绝对值，而<code>Cache-Control</code>是一个相对值，此处为<code>max-age=3600</code>，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，<code>Cache-Control</code>相比于<code>Expires</code>是更好的选择，所以同时存在时只有<code>Cache-Control</code>生效。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569414685538.png" alt=""></figure>
<h4 id="协商缓存">协商缓存</h4>
<p>协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569414775602.png" alt=""></figure>
<p>上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，所以同时存在时只有<code>Etag / If-None-Match</code>生效。</p>
<h6 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h6>
<p>你可以往上翻一翻，看一下那张响应报文截图，其中有一个<code>Last-Modified</code>字段，它的值是该资源文件在服务器最后被修改的时间。</p>
<p><code>If-Modified-Since</code>则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值。服务器收到该请求后，发现该请求头有<code>If-Modified-Since</code>字段，则会将<code>If-Modified-Since</code>与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569414811322.png" alt=""></figure>
<h6 id="etag-if-none-match">Etag / If-None-Match</h6>
<p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。</p>
<p><code>If-None-Match</code>则是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569414845179.png" alt=""></figure>
<h4 id="disk-cache-与-memory-cache">disk cache 与 memory cache</h4>
<p>我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569414871028.png" alt=""></figure>
<p>猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。</p>
<p>内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。</p>
<p>浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。</p>
<h4 id="总结">总结</h4>
<p>到这里偷懒一下子了，找到人家画的一张图，看图就行了。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569414915648.png" alt=""></figure>
<blockquote>
<p>参考内容：<br>
<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a><br>
<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bootstrap-table 合并相同单元格]]></title>
        <id>https://mengxiaoxu.github.io//post/MqqlYHD78</id>
        <link href="https://mengxiaoxu.github.io//post/MqqlYHD78">
        </link>
        <updated>2019-01-26T12:22:05.000Z</updated>
        <content type="html"><![CDATA[<p>Bootstrap-table 官方提供了合并单元格方法 <a href="https://bootstrap-table.com/docs/api/methods/#mergecells">mergeCells</a>，它根据四个参数可以合并任意个单元格，我们要做的只是告诉它怎么合并。</p>
<p>要合并同一列相同的单元格，无非两种办法，一种是一边遍历一边合并，遍历完了再合并。这里采用第二种办法，这里不需要遍历所有数据，因为用户只能看到当前页的数据，所以只遍历当前页的数据更省时间。</p>
<p>下面是我实现的获取合并信息算法，最终返回的是一个哈希表，比如下面的这个表格，如果要对「性别」这一列进行合并，很明显前面两个“男”需要合并成一个单元格，再去看下 Bootstrap-table 提供的 API，它需要的是从哪个单元格开始，合并多少个单元格，也就是它需要的是两个数值类型的参数。</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>男</td>
<td>23</td>
</tr>
<tr>
<td>李四</td>
<td>男</td>
<td>19</td>
</tr>
<tr>
<td>王二</td>
<td>女</td>
<td>20</td>
</tr>
<tr>
<td>麻子</td>
<td>男</td>
<td>21</td>
</tr>
</tbody>
</table>
<p>所以我把哈希表设置为，键存的是索引，值存的是从这个索引开始后面连续有多少个和它一样的单元格，那么上述表格性别这一列所得到的合并信息哈希表就为：</p>
<pre><code>{
    0: 2,
    2: 1,
    3: 1
}
</code></pre>
<p>下面算法很简单，使用两个指针遍历指定的列，如果两个指针所指向的数据相同，那么就将键所对应的值进行加一操作，整个方法只会对该列数据遍历一边，所以时间复杂度为 O(n)。</p>
<pre><code class="language-typescript">let getMergeMap = function (data, index: number) {
    let preMergeMap = {};
    // 第 0 项为表头，索引从 2 开始为了防止数组越界
    for (let i = 2; i &lt; data.length; i++) {
        let preText = $(data[i-1]).find('td')[index].innerText;
        let curText = $(data[i]).find('td')[index].innerText;
        let key = i - 2;
        preMergeMap[key] = 1;
        while ((preText == curText) &amp;&amp; (i &lt; data.length-1)) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
            i++;
            preText = $(data[i - 1]).find('td')[index].innerText;
            curText = $(data[i]).find('td')[index].innerText;
        }
        // while循环跳出后，数组最后一项没有判断
        if (preText == curText) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
        }
    }
    return preMergeMap;
}
</code></pre>
<p>上述算法得到了单列数据的合并信息，下一步就是按照这个信息进行相同单元格的合并了，因此封装了下面的方法按照指定哈希表进行合并。</p>
<pre><code class="language-typescript">let mergeCells = function (preMergeMap: Object, target, fieldName: string) {
    for (let prop in preMergeMap) {
        let count = preMergeMap[prop];
        target.bootstrapTable('mergeCells', { index: parseInt(prop), field: fieldName, rowspan: count });
    }
}
</code></pre>
<p>到目前为止，我们实现的都只是对单列数据进行合并，要实现对多列数据进行合并，那么只需要对所有列都进行相同的操作即可。</p>
<pre><code class="language-typescript">export let mergeCellsByFields = function (data: Object[], target, fields) {
    for (let i = 0; i &lt; fields.length; i++) {
        let field = fields[i];
        // 保证 field 与 i 是相对应的
        let preMergeMap = getMergeMap(data, i);
        let table = target.bootstrapTable();
        mergeCells(preMergeMap, table, field);
    }
}
</code></pre>
<p>因为我在程序中做了一点处理，保证了<code>fields</code>中每个值得索引与对应表头的索引是一样的，因此不需要额外传入索引信息。简单来说就是我所实现的表格会根据<code>fields</code>的顺序，实现列之间的动态排序。你需要注意的是这一点很可能和你不一样。</p>
<p>到现在已经能够合并所有的列了，查看 Bootstrap-table 的配置信息发现，它有个属性是 <a href="https://bootstrap-table.com/docs/api/events/#onpostbody">onPostBody</a> 它会在 table body 加载完成是触发，所以把这个属性配置成我们的合并单元格方法即可。</p>
<pre><code class="language-typescript">// groups 为要合并的哪些列
onPostBody: function () {
    mergeCellsByFields($('#table' + ' tr'), $('#table'), groups);
}
</code></pre>
<p>再说一点不太相关的，我实现的是让用户可以自己选可以合并多少列，即用了一个可多选的下拉列表框供用户选择，根据用户选择的数量去合并，所以传入了一个<code>groups</code>参数。</p>
<p>最后推荐一个排序插件 <a href="https://github.com/Teun/thenBy.js">thenBy</a>，你可以用它进行多字段排序，比如用在合并相同单元格的场景，在绘制表格前先对数据进行排序，那么最后合并的结果就是把所有相同的数据聚合到一起了，并且还将它们合并到一起了，起到了一个隐形的过滤查询功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-01-23）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-01-23</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-01-23">
        </link>
        <updated>2019-01-23T14:00:35.000Z</updated>
        <content type="html"><![CDATA[<p>前段时间的刷屏文章《甘柴劣火》被曝出是洗稿文章，微信官方取消了该文章的原创标识和赞赏；再往前追溯一段时间，公众号「差评」也因为洗稿行为，眼看就要到手的 3000 万投资飞走了。国内渐渐加大了版权保护的力度，但是读者从来不会关心是否原创，所以「兽爷」式文章总是能撩到大众的 G 点。</p>
<p>被微信平台邀请为洗稿合议小组成员后，参与了一篇存在洗稿争议的评审，体会到了保护原创的困难，不知道把存在洗稿争议的两篇文章发给高考阅卷老师看会是怎样的结果，在保护原创文章方面，微信平台应该是国内做的最好的。</p>
<p>微信的「看一看」里面都快变成营销圈了，干脆去掉了这个入口，自微信改版之后，我点「好看」都变的异常谨慎了，以前给文章点赞只是认同作者的一个行为，而现在点赞也变成社交行为了，所以我也收起了点赞的食指。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>网友推荐了一个小视频，虽然只有简短的几分钟，但是很有意思，讲的是历史的错觉。（此部分知识来源于网络）</p>
<p>虽然刘邦和秦始皇同为两个朝代的开创者，但秦始皇只比刘邦大 3 岁，而且刘邦是在秦朝建立之前的周朝出生的。</p>
<p>在历史课本上，乾隆属于古代史部分，华盛顿属于现代史部分，但实际上他俩是同一年出生的，历史课本的编排让我们感觉他俩像隔了很久一样。</p>
<p>都清楚毛泽东是离我们很近的人物，但是毛泽东比末代皇帝傅仪大了 13 岁。</p>
<p>不知道你又没有觉得前苏联是离我们很远的、历史上的国家，如果你这样觉得，那告诉你前苏联总统戈尔巴乔夫现在还活着，会不会觉得更加诧异。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>最近熬夜看完了《大江大河》第一部，很不错的电视剧，讲述从改革开放开始的中国，通过两个主人公的经历来展现国营企业、集体企业、个体户的发展。剧中的大多数场景我居然都经历过，可能我是一个假的 90 后吧。</p>
<p>导演很注重细节，没有冗余的啰嗦，有两个小细节记忆深刻。第一个是宋运辉父亲用“吹火筒”（我家那块是这么叫）助燃，小时候我还帮爸爸做过一个“吹火筒”；第二个是杨巡和他母亲给雷东宝写借条时，格式是很标准的，借条的格式是小学六年级时学习常用应用文格式时记下的。</p>
<p>电视剧中多次提到长毛兔，小时候家里也养过长毛兔，不过我那时候调皮，兔子的耳朵又大又好玩，我就牵着兔子的耳朵对着它大吼，兔子总是会发飙一样快速跑一段距离，但是家里最后两只长毛兔也就被我这么吼到离家出走了，自那以后家里就没有兔子了。</p>
<p>我喜欢听别人讲述历史，最近参加了几次校友活动，最大的师兄师姐是 80 级的，听他们讲述那个时代的故事很有趣，《大江大河》是不错的了解历史的渠道，唯一的缺点就是电视剧时间太长了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>如果在某件事情上的观点和关系很亲近的人不合，要想说服他不一定非得苦口婆心给他讲，换一条路可能效果更好。比如我师傅在给他娃起名的时候和媳妇发生了分歧，男士肯定是争不过女士的，所以师傅每次见到七大姑八大姨，就给他们说这个名字从姓名学、风水等等方面存在哪些问题，这些七大姑八大姨自然而然就会去说媳妇，最终媳妇主动提出来要给娃改名字。</p>
<p>要和对象、朋友处好关系，你也不用天天告诉她对她有多好，你观察一下对方周围的朋友就可以了。比如你对象闺蜜的男朋友会陪她到 11 点，那你只需要陪她到 12 点或者 11：30 就可以了，对象的闺蜜会拿你和她自己的男朋友作对比，自然就会在你对象面前念叨你的各种优点，中国好男人这个形象会在你对象心里越来越明显，她也会越来越觉得自己是捡了个宝，也就是你要给对方足够炫耀的资本。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>最近好几个知识星球到期了，我也算比较早接触知识付费的人群了，有一些星球早就停更了，挑了几个比较好的续费了，刘大、曹大、冯大、池大，同时新加入了方军老师的星球，方老师送了本书，再让我免费加入了一个价值 998 元的星球。</p>
<p>除了在得到上买专栏，我还开了喜马拉雅的会员，买了个喜马拉雅的智能音箱，发现真好玩，用它听书很不错，不是机器阅读的，是真人阅读的，体验很棒。</p>
<p>想说的是，我遇到很多人吃一顿饭花几百，买个课程花几百就心疼的要死，我比大多数人都穷（信用卡都快还不起了，哈哈），但是我敢花大手笔去让自己成长。后来我就不劝朋友花钱买课程了，那种让人觉得我骗他钱的感觉很不好受。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>释压能力很重要，最近也遇到好几个被压力给弄崩溃了的人，我承认年轻人压力是挺大，但是没必要再给自己无端增加压力，像我这种活的单纯自在、没心没肺的人就最乐了，换个角度也是没追求的表现。</p>
<p>一个压崩溃了的同学总是很相信我，但是前前后后快一年了，给他说了很多东西，最近发现我自己都是白说了，还说我说话不中听，他骂我而我没有骂他，而那同学言语间倒是给了我一种感觉，我的教养好，所以我不应该骂人。</p>
<p>因此我得出的结论是，同样一句话给不同的人讲，效果是不一样的，绝大部分东西是他自己内心的反射，你也不要试图去改变他什么，是没什么办法改变别人的。这里推荐一篇子柳老师的文章<a href="https://mp.weixin.qq.com/s/yZJPQ8JpNbuwefYO184mAg">天下谁人不焦虑？</a></p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569507889427.gif" alt=""></figure>
<p>之前在<a href="https://mp.weixin.qq.com/s/TnbKdM79pO_06oz1cfPtAQ">这是一篇不正经文章</a>中贴了一张网图，前几天看到很标准的现实版，照片是在我住的地方偷摸拍的。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569506722099.JPG" alt=""></figure>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1569506728053.JPG" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[回忆高中网校生活]]></title>
        <id>https://mengxiaoxu.github.io//post/5BDtFnlOc</id>
        <link href="https://mengxiaoxu.github.io//post/5BDtFnlOc">
        </link>
        <updated>2018-12-15T13:33:05.000Z</updated>
        <content type="html"><![CDATA[<p>周三刷星球时看到一条关于成都七中网校的信息，没想到周四就被成都七中网校给刷屏了，看到文章里面的描写，感悟颇多，网校陪伴了自己三年，<a href="https://mp.weixin.qq.com/s/hBKC4krTLl5rR4npMQf_fA">一个诗意的女孩——西凉忆</a>就是因为网校结识的。</p>
<p>我是 12 年入学高中，那一年学校也刚和成都七中开通网校，因此我属于学校第一届全程使用网校资源的学生。</p>
<p>记得刚入学时，对这种教学方式并不适应。不止学生不适应，老师也不适应，政治课老师就不使用直播课程，而是选择自己给我们讲。不过后来年级组出了硬性规定，特优班必须使用直播课程。</p>
<p>就像<a href="http://m.cyol.com/yuanchuang/2018-12/12/content_17849270.htm?from=timeline&amp;isappinstalled=0">教育的水平线</a>中描述的一样，我们被称为远端学生，大家都是第一次使用这样的系统，七中老师估计也很好奇，都在第一节课或者第二节课上抽了远端同学回答问题，后来就很少有抽远端同学回答问题了，估计是因为远程视频效果不好还浪费时间。</p>
<p>成都七中本部的学生上课很有激情，一到讨论等环节，虽然很吵但是却很有秩序，而我们这边基本是大家都盯着屏幕，等待对方讨论结束。</p>
<p>对方学生的基础我们是没办法比的，大部分能够完全以纯英文交流，而我们远端学生大部分都只能说出“My name is ..., I'm from ..., I like ...”，英语的差距是最大的。我自己是主动找了英语老师谈话，和她做了一个约定，每周我写一篇作文交给她，她帮我批改，这样坚持了两年。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569418431870.jpg" alt=""></figure>
<p>让我感受到最大差距的是，一个中学有自己的电视台，经常会有像《汉语桥》冠军一类的人物前来演讲，美国第一夫人米歇尔也到七中演讲（那是总统还是奥巴马），作为远端学生有幸蹭了一场名人演讲；七中学生的寒暑假是参加联合国模拟大会、到哈佛做了简短的交流、到华盛顿旅行......</p>
<p>而大部分远端的学生，要么是参加学校组织的补课，要么是在家干农活，基本连县城都没有走出去过，和七中相比，完全是天壤之别。</p>
<p>现在我依旧还清晰的记得七中的几个老师，做 PPT 从来没有背景图的数学老师，语速超快但又吐字清晰的化学老师，说着一口标准川普的物理老师，有着一头蓬松金黄卷发的历史老师（男）......去看这些老师的背景，也都是名校出身，武汉大学、华中师大等等。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569418441535.jpg" alt=""></figure>
<p>有一个细节记得很清楚，在一堂数学课中有个题目，题目具体内容忘了，只记得是要求算新华中学的一本录取率，最后的答案是在 74% 左右，这个数字在我眼里很高了，但是那一刻并没有觉得有什么，毕竟这是书上的学校嘛！！</p>
<p>想不到的是，下一秒那个做 PPT 从来没有背景图的数学老师说了句：“这个就比较低了啊，我们学校考的很差的时候才是百分之七十多的录取率”。一下让我震惊了，因为我在心里算过自己学校的一本录取率，在此之前不到 10%，而且我所在高中在所有远端学校中还是比较靠前的。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569418454783.jpg" alt=""></figure>
<p>让我意外的是，七中的老师原来也会骂人、打人，即使打的很轻；学生没完成作业，也会被罚拿个小凳子到教室外面补作业；在全国禁止补课的规定之下，七中也会给高三的学生补课，当然我们也同步补课了。</p>
<p>我无法构想如果三年没有使用网校资源会是神马结果，如果仅仅是看数据的话，一本率是按倍数翻的，12 年开始使用网校资源后，学校有了第一个清华，13 年又添了一个清华。我属于 14 届，这届没有清华，最好的是浙大，我进了个普普通通的哈尔滨工程大学。据说 15 届又出了清华。</p>
<p>我所在的高中也被央视作为典型案例探讨农村高考。无疑能上央视，那这个学校在当地乃至全国同等水平的学校中是很成功的。</p>
<p>无疑这种生活给每个同学都留下了难忘的记忆，如果哪位同学加了七中本部直播班级某位同学的 QQ（那时没有人用微信），那能吹好几天牛逼，七中人在我们眼里就像明星一样。</p>
<p>我们当地 14 届县状元高考分数是 635 分，七中本部平均分是 616 分，这差距至今都让我目瞪口呆。前段时间曹大在星球发起了一个作业：十年后的期望目标。我所提交的作业中写了句，如果有能力，希望能给乡村学校带去一点教育资源。</p>
<p>我并不认为穷是光荣的事情，但在很多农村人眼里穷是一种资本，一种获取国家福利的资本，如果某次补助没有评到自己头上，那得记恨村长一辈子。我认为这才是造成农村孩子和城里孩子有巨大差距的原因，如果孩子没有从这种思维走出来，那一辈子也不可能有什么大的成就。</p>
<p>没想到自己都大学毕业了，却看到成都七中的网校被刷屏了。毫无疑问，这是一件极为有意义的事情，这种内容就应该被刷屏，愿七中和远端学校都越办越好。</p>
<blockquote>
<p>文中照片取自于同学 QQ 空间，不知道这么把几位老师放出来有没有侵权。记得我原来还有英语老师 Spring 的 QQ，高中时向他请教过自己的英语问题，可能后来 Spring 把我删了 =_=，反正是没了。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录在南京大学的半天]]></title>
        <id>https://mengxiaoxu.github.io//post/aSkANU6p0</id>
        <link href="https://mengxiaoxu.github.io//post/aSkANU6p0">
        </link>
        <updated>2018-12-12T12:01:17.000Z</updated>
        <content type="html"><![CDATA[<p>因为工作需要，到南京出差了半个月，中间利用周末和最好的朋友疯了一天，之后自己又一个人到南京大学鼓楼校区逛了逛。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412914052.JPG" alt=""></figure>
<p>不会勾搭妹子的我总是能勾搭到老爷爷，到南大就勾搭了一个 86 岁高龄的老教授，他毕业于中山大学，年轻时候是做地质工作的。</p>
<p>我就像个熊孩子一样要爷爷给我讲有趣的故事，要听他讲我们这一代人或者是大部分人都不知道的历史。</p>
<p>爷爷虽然已经是快到耄耋之年的人了，但是对年轻时候的事记得很清楚，只是对最近的事记不起来。这篇文章仅仅是记录一下爷爷所讲的趣事。</p>
<p>爷爷年轻时候接到中科院的任务，前往内蒙古考察。在考察期间他们用汽车压死过一只狼，而且当时吃了狼肉，一行 30 多个人都吃过那匹狼的心，但是没有吃过狗肺。</p>
<p>据爷爷说，狼是很狡猾的动物，他们用汽车去追狼，狼就在原地不跑，等到你离它只有 10 来米的时候，突然拐弯跑了，这样的情况他们一共遇到了 6 次。这和《狼图腾》一书中的描写基本一致，狼有先进的军事文化。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412927749.JPG" alt=""></figure>
<p>爷爷告诉我，南大起源于金陵大学，南京大学的标志性建筑「北大楼」是个教堂的样子，金陵大学本来是个教会大学，现在的「北大楼」就是原来的「钟楼」。</p>
<p>南大的地下有隧道，是当年毛主席提倡「深挖洞、广积粮、不称霸」时挖的，目的是为了防空。后来被南京食品公司用来存放香蕉，就是那种没有熟的香蕉，在隧道里面放熟了，再拿出来卖。不过现在隧道所有的口都没堵上了，完全废弃了。</p>
<p>在南大，有一些楼中间有 5 层，然后到两遍就只有 3 层了，整体看来像是个三角形。实际上这些楼当年都是要修 8 层的，因为那时候没钱，建着建着发现没资金了，所以就封顶了。</p>
<p>但是南大计算中心那栋楼只有 3 层却不是因为没钱，而是因为它旁边是消防大队，本来也是要建 8 层的，消防队说建高了挡住了他们视线，不能及时发现火情。爷爷笑着对我说：“但是也没见他们在上面拿个望远镜望啊！”。</p>
<p>我们都知道「五四运动」，但是却很少有人知道「四五运动」，这个运动的起源就在南大，当时 300 多学生（我回来查资料说是 400）发起了这个运动，后来演变为全国性的运动，直接带动了半年后四人帮被粉碎。</p>
<p>那是爷爷是个老师，他说他们教职工是很支持这些学生的，但是不敢公开性的支持。学生们很聪明，把标语刷到火车上，但是所有出南京的火车都被四人帮用水把标语给冲刷掉了，学生们就用沥青往火车上面写，才通过火车把这项运动的信息带到了全国各地。</p>
<blockquote>
<p>我回来后查了一点资料，「四五运动」的起源是因为周恩来总理的去世，四人帮居然压制人民群众悼念周恩来，诬陷邓小平，而那时的毛主席也已经病到无法行动。</p>
</blockquote>
<blockquote>
<p>人们把花圈都放到人民英雄纪念碑前悼念周总理，却被四人帮给清理了，北京广大人民群众在“还我花圈，还我战友”的口号下行成了天安门广场大规模的群众抗议运动。</p>
</blockquote>
<blockquote>
<p>那也是一个诗意的年代，人们通过写诗来表达自己心中的愤怒，把小瓶子挂在树上，蕴意着期待邓小平的归来。那段时间四人帮应该是很难过的，从姚文元的日记就可以看出来。</p>
</blockquote>
<p>爷爷还给我讲了一点他们的研究，他们研究行政规划的很多人认为，中国现在的行政划分有很多缺点的，中国应该划分 50~80 个省级单位。现在中国的行政级别也有问题，宪法规定行政层级只有三级（这一点我没查），而现在很多地方县下面是镇，镇下面还有乡，严格讲这是违宪的。</p>
<p>快到午饭时间时，爷爷还教我写了一会儿字，有的简体字很难看，比如「龍飛鳳舞」用繁体字写出来很好看，但是用简体字写出来就特难看。要想练好毛笔字，把三个字写好了就行了，然而我现在只记得一个“飛”字了，这可能就是老师们常说的「你又还给我了」。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么处理排序数组比未排序数组快]]></title>
        <id>https://mengxiaoxu.github.io//post/SpXxa8r-v</id>
        <link href="https://mengxiaoxu.github.io//post/SpXxa8r-v">
        </link>
        <updated>2018-11-28T11:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天在群里看到一个有意思的问题——为什么处理排序数组比处理没有排序的数组要快，这个问题来源于 <a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">StackoverFlow</a>，虽然我看到代码略微知道原因，但是模模糊糊不够清晰，搜了很多博客也讲的不够明白，所以就自己来总结了。</p>
<p>首先来看一下问题，下面是很简单的一段代码，随机生成一些数字，对其中大于 128 的元素求和，记录并打印求和所用时间。</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c &lt; arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i &lt; 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c &lt; arraySize; ++c)
            {
                if (data[c] &gt;= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println(&quot;sum = &quot; + sum);
    }
}
</code></pre>
<p>我的运行结果：分别在对数组排序和不排序的前提下测试，在不排序时所用的时间比先排好序所用时间平均要多 10 ms。这不是巧合，而是必然的结果。</p>
<p>问题就出在那个<code>if</code>判断上面，在旧文<a href="https://mp.weixin.qq.com/s/8WwJK0CfKz1o_bwefxBd5Q">顺序、条件、循环语句的底层解释</a>中其实已经提到了造成这种结果的原因，只是旧文中没有拿出具体的例子来说明。</p>
<p>为了把这个问题搞明白，需要先对<code>流水线</code>有一定的了解。计算机是指令流驱动的，执行的是一个一个的指令，而执行一条指令，又要经过<code>取指、译码、执行、访存、写回、更新</code>六个阶段（不同的划分方式所包含的阶段不一样）。</p>
<p>六个阶段使用的硬件基本是不一样的，如果一条指令执行完再去执行另一条指令，那么在这段时间里会有很多硬件处于空闲状态，要使计算机的速度变快，那么就不能让硬件停下来，所以有了流水线技术。</p>
<p>流水线技术通过将指令重叠来实现几条指令并行处理，下图表示的是三阶段指令时序，即把一个指令分为三个阶段。在第一条指令的 B 阶段，A 阶段相关的硬件是空闲的，于是可以将第二条指令的 A 阶段提前操作。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412133980.png" alt=""></figure>
<p>很明显，这种设计大幅提高了指令运行的效率，聪明的你可能发现问题了，要是不知道下一条指令是什么怎么办，那提前的阶段也就白干了，那样流水线不就失效了？没错，这就是导致开篇问题的原因。</p>
<p>让流水线出问题的情况有三种：1、<code>数据相关</code>，后一条指令需要用到前一条指令的运算结果；2、<code>控制相关</code>，比如无条件跳转，跳转的地址需要在译码阶段才能知道，所以跳转之后已经被取出的指令流水就需要清空；3、<code>结构相关</code>，由于一些指令需要的时钟周期长（比如浮点运算等），长时间占用硬件，导致之后的指令无法进入译码等阶段，即它们在争用同一套硬件。</p>
<p>代码中的<code>if (data[c] &gt;= 128)</code>翻译成机器语言就是跳转指令，处理器事先并不知道要跳转到哪个分支，那难道就等知道了才开始下一条指令的取指工作吗？处理器选择了假装知道会跳转到哪个分支（不是谦虚，是真的假装知道），如果猜中了是运气好，而没有猜中那就浪费一点时间重新来干。</p>
<p>没有排序的数组，元素是随机排列的，每次<code>data[c] &gt;= 128</code>的结果也是随机的，前面的经验就不可参考，所以下一次执行到这里理论上还是会有 50% 的可能会猜错，猜错了肯定就需要花时间来修改犯下的错误，自然就会浪费更多的时间。</p>
<p>对于排好序的数组，开始几次也需要靠猜，但是猜着猜着发现有规律啊，每次都是往同一个分支跳转，所以以后基本上每次都能猜中，当遍历到与 128 分界的地方，才会出现猜不中的情况，但是猜几次之后，发现这又有规律啊，每次都是朝着另外一个相同分支走的。</p>
<p>虽然都会猜错，但是在排好序的情况下猜错的几率远远小于未排序时的几率，最终呈现的结果就是处理排序数组比未排序数组快，其原因就是流水线发生了大量的控制相关现象，下面通俗一点，加深一下理解。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412222054.jpg" alt=""></figure>
<p>远在他方心仪多年的姑娘突然告诉你，其实她也喜欢你，激动的你三天三夜睡不着觉，决定开车前往她的城市，要和她待在一起，但是要去的路上有很多很多岔路，你只能使用的某某地图导航，作为老司机并且怀着立马要见到爱人心情的你，开车超快，什么样罚单都不在乎了。</p>
<p>地图定位已经跟不上你的速度了，为了尽快到达，遇到岔路你都是随机选一条路前进，遗憾的是，自己的选择不一定对（我们假设高速可以回退），走错路了就要重新回到分岔点，这就对应着未排序的情况。</p>
<p>现在岔路是有规律的，告诉你开始一直朝着一边走，到某个地点后会一直朝着另一边走，你只需要花点时间去探索一下开始朝左边还是右边，到了中间哪个地点会改变方向就可以了，相比之下就能节省不少时间了，尽快见到自己的爱人，这对应着排好序的情况。</p>
<blockquote>
<p>最后的故事改编自两个人的现实生活，一位是自己最好的朋友之一，谈恋爱开心的睡不着觉；另一位是微信上的一位好友，为了对方从北京裸辞飞到了深圳。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学的 2018]]></title>
        <id>https://mengxiaoxu.github.io//post/JFfO3d0iF</id>
        <link href="https://mengxiaoxu.github.io//post/JFfO3d0iF">
        </link>
        <updated>2018-11-26T13:25:54.000Z</updated>
        <content type="html"><![CDATA[<p>这个总结写的还算认真，回头看，我真的运气很好，遇到了很多大佬，在我还未毕业时并没有嫌弃我傻，教我的不仅仅是技术，还有理财、为人处世，下面是我这一年的成长经历。</p>
<p>有一段时间因为华为 34 岁以上员工被裁、中兴程序员跳楼等事件的发生，各种蹭热点讨论“中年危机”的文章漫天飞，那时我正忙于找工作。</p>
<p>当时一个微信群里面大家各种讨论中年危机，都在给自己制造焦虑，刚好群里有个大神可能看大家过于焦虑，就在群里发了几条消息，教大家如何避免中年危机，并且推荐了两本书。</p>
<p>还是学生的我下意识的就发了一个添加好友请求，庆幸的是他同意了我的好友请求，当然我们没有什么交流，我的问题过于浅显，我明白自己这个水平问问题，会浪费人家时间，当时的想法是看看大神的朋友圈，他平时都接触什么，自己学习一段时间。</p>
<p>大神推荐的书是李笑来写的《把时间当做朋友》、《财富自由之路》，两本书在学校图书馆都没有，我就给学校图书馆荐购系统提交了这两本书，图书馆效率也挺高，不到一周就把书给买回来了，我立马就借回来阅读。</p>
<p>书中的内容刷新了我以前狭隘的认知，自己从来没有像书中那样考虑问题，除了对作者的佩服之外，更多的是思考自己这种学生思维局限性太大了，要慢慢的将它摒弃。</p>
<p>有个定律是你关心什么就会来什么，后面陆续碰到几位像大神一样的人士，并加了他们的微信，但是都仅仅是通过他们朋友圈的蛛丝马迹去找知识，通过他们朋友圈的分享内容，我知道了“简七理财”、“码农翻身”公众号，然后知道了《富爸爸穷爸爸》、《小狗钱钱》，于是我通过微信读书，读完了这两本书，逐渐培养了理财理念。</p>
<p>后来没隔多久，简七出书了，我第一时间就买了她写的《好好赚钱》（同期还有刘大也出了《码农翻身》一书，我也第一时间买了），简七写的内容通俗易懂，很容易理解。</p>
<p>刘大在群里开了几次公开课，作为计算机专业的我，被刘大对技术的理解之深给折服了，正是业界浮躁的时候，成千上万人想着人工智能、大数据、区块链，而刘大一直能沉下心来去了解技术的原理，这给了我一个很好的榜样，我也逐渐沉下心来，开始去补最基础的知识，像《深入理解计算机系统》一类书也能尽下心来慢慢去啃（当时没啃完，最近又在啃），这种不浮躁的特质对我的技术成长是很有帮助的。</p>
<p>此后有一天，另一个大神在朋友圈分享了曹大写的《从校园到职场系列文章》，喜欢深入挖掘信息的我，以曹大公众号为源头，又找到了冯大、池大、二爷等人的公众号。</p>
<p>作为自由的大四学生，因为不用担心第二天起不来，我那段时间经常熬夜阅读他们的文章，再阅读的过程中我也开始思考自己此前哪些想法狭隘，哪些品质又是值得继续保持的。</p>
<p>也是那时开始接受知识付费的，那时候已经有小密圈（现在叫知识星球）了，出于对几位大佬的信任，我第一次大胆的花了几百块钱加入了刘大、曹大、冯大、程序员小灰的小密圈，其中的内容比网上蹭热点的文章好不知多少倍，一贯爱捕捉蛛丝马迹的我，又通过评论信息发现了 angela zhu、子柳老师、陈利人老师等，然后去找他们的文章，他们输出的内容要比水军写的文章好太多。</p>
<p>自己也是从那时候开始坚持写文章记录自己的心得的，通过写文章，我认识了很多优秀的人，比如吴小龙同学、了不起的杰克、java 小咖秀等公众号的作者，和他们交流的很少，但是却很受用，他们的积极向上也影响着我一直保持着乐观豁达的心态。</p>
<p>自己写的文章也被几个资深程序员赞同，同时还收到了两个出版社发来的出书邀请，让我体会到了无心插柳柳成荫的收获。</p>
<p>让我坚持一直写文章的动力不是赚钱，而是我切切实实体会到了它给我个人带来的成长，为了自己日后再看时能立刻就找到清晰的逻辑，我把都尽可能把文章写得有理有据，掌握自己的节奏，尽量提高文章质量。此前写的<a href="https://mp.weixin.qq.com/s/V0_Eb8466Ai37OG2yw4usQ">谈一下写作的重要性</a>一文有说写作可以带来的好处。</p>
<p>现在已经不把自己当新人了，而且有同龄人甚至比我年龄还大的人向我咨询问题时，我也能给出合理建议，都得到了他们的肯定。最近发现和周围伙伴最明显的一个区别就是，对于同一个新闻，我经常早于他们半天甚至一两天知道，而且掌握的信息比他们还准确，我认为这就是整体认知水平的提升。</p>
<p>想说的是，执行力与信息素养很重要，执行力强的人会与你拉开越来越大的距离，信息素养也是一个关键品质，现在网络上充斥着大量的虚假信息，如何去分别这些信息的真假，在相同条件下如何获得更多的有效信息，是必备的能力。</p>
<p>当前年龄 23，刚大学毕业几个月，没读研。按十年为期给自己定了几个小小的目标：</p>
<p>父母是地地道道的农民，智能手机都不会用，十年之类给自己和父母把重疾险、意外险之类的保险配置齐全，虽然父辈一直反对买保险。</p>
<p>提高获取信息的能力，虽然现在对信息的掌握都比周边伙伴要早半天至几天，但是都不是自己的分析结果，学习以时间的纬度跟踪事件的发展。</p>
<p>学习理财知识，现在只对信用卡、基金有一点点的了解，不管炒不炒股，金融知识都还是要学的，这方面通过看书、阅读、小额实操学习。</p>
<p>提升自己的技术实力，职业是程序员，前后端都做，但是自己对技术的热情不是多么高涨（至少比身边一半人要高涨），以我对自己的了解，我在技术的道路上成长为小公司一个的架构师应该不成问题，再高层级怕是不行。</p>
<p>慢慢做到不止一份收入来源，这方面不是多清晰，现在每个月平均会有 200 左右的非工资收入（帮助别人时发的红包等），十年后做到其它收入基本和工资持平。不至于因为钱的问题而忍受心中的不快，至少得有能指着老板的鼻子说“老子不干了”的底气。</p>
<p>世界那么大，应该去看看，国内除了西北地区，中国很多地方已经留下了我的足迹，旅游不仅仅是玩耍，更是提升见识、获得灵感的有效途径，十年至少得把自己的脚印印到 5 个国家的土地上吧。</p>
<p>十年之后应该已经结婚了，房子是现在最遥不可及的目标，但是心里莫名有一股自信，这个后面会实现的，虽然不知道哪里来的这股自信。</p>
<p>最后一个，趁年轻，多学习，做一个终身学习的人，时刻保持学习的态度，多做有利于他人的事，现在水平不高，我能帮助到的大部分都是硕士及以下。努力提高自己，帮助更多的人。更大的目标是能给山区学校带去一些更好的教育资源。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数调用与空间分配]]></title>
        <id>https://mengxiaoxu.github.io//post/cYbqHG1mh</id>
        <link href="https://mengxiaoxu.github.io//post/cYbqHG1mh">
        </link>
        <updated>2018-11-18T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们在编程序的时候，都会把某一个特定功能封装在一个函数里面，对外暴露一个接口，而隐藏了函数行为的具体实现，一个大型的复杂系统里面包含了很多这样的小函数，我们称之为<strong>过程</strong>。</p>
<p>过程是相对独立的小模块，系统的运行需要这些过程的紧密合作，这种合作就是函数调用。</p>
<p>在一个函数执行时调用别的函数，比如 P 调用 Q，需要执行一些特定的动作。<code>传递控制</code>，在调用 Q 之前，控制权在 P 的手里，既然要调用 Q，那么就需要把控制权交给 Q；<code>传递数据</code>，就是函数传参；<code>分配与释放内存</code>，在开始时，Q 可能需要位局部变量分配空间，结束时又必须释放这些存储空间。</p>
<p>大多数语言都使用栈提供的先进后出机制来管理内存，x86-64 可以通过通用寄存器传递最多 6 个整数值（整数或地址），如果超过 6 个，那就需要在栈中分配内存，并且通过栈传递参数时，所有数据的大小都要向 8 的倍数对齐。将控制权从 P 转交给 Q，只需要将 PC（程序计数器）的值置为 Q 代码的起始位置，并记录好 P 执行的位置，方便 Q 执行完了，继续执行 P 剩余的代码。</p>
<p>在函数的传参、执行中，多多少少都需要空间来保存变量，局部数据能保存在寄存器中就会保存在寄存器中，如果寄存器不够，将会保存在内存中。除了寄存器不够用的情况，还有数组、结构体和地址等局部变量都必须保存在内存中。分配内存很简单，只需要减小栈指针的值就行了，同样释放也只需要增加栈指针。</p>
<p>在函数执行过程中，处理栈指针<code>%rsp</code>，其它寄存器都被分类为<code>被调用者保存寄存器</code>，即当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。</p>
<p>所以递归也就不难理解了，初学算法总觉得递归有点奇妙，怎么自己调用自己，而实际上对于计算机来说，它和调用其它函数没什么区别，在计算机眼里，没有自身与其它函数的区别，所有被调用者都是其它人。</p>
<p>数组是编程中不可或缺的一种结构，“数组是分配在连续的内存中”这句话已经烂熟于心了，历史上，C 语言只支持大小在编译时就能确定的多维数组，这个多多少少有一些不便利，所以在<code>ISO C99</code>标准中就引入了新的功能，允许数组的维度是表达式。</p>
<pre><code class="language-c">int A[expr1][expr2]
</code></pre>
<p>因为数组是连续的内存，所以很容易就能访问到指定位置的元素，它通过首地址加上偏移量即可计算出对应元素的地址，这个偏移量一定意义上就是由索引给出。</p>
<p>比如现在有一个数组<code>A</code>，那么<code>A[i]</code>就等同于表达式<code>* (A + i)</code>，这是一个指针运算。C 语言的一大特性就是指针，既是优点也是难点，单操作符<code>&amp;</code>和<code>*</code>可以产生指针和简介引用指针，也就是，对于一个表示某个对象的表达式<code>expr</code>，<code>&amp;expr</code>给出该对象地址的一个指针，而对于一个表示地址的表达式<code>Aexpr</code>，<code>*Aexpr</code>给出该地址的值。</p>
<p>即使我们创建嵌套（多维）数组，上面的一般原则也是成立的，比如下面的例子。</p>
<pre><code class="language-c">int A[5][3];

// 上面声明等价于下面
typedef int row3_t[3];
row3_t A[5];
</code></pre>
<p>这个数组在内存的中就是下面那个样子的。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411935351.png" alt=""></figure>
<p>还有一个重要的概念叫做<code>数据对齐</code>，即很多计算机系统要求某种类型的对象的地址必须是某个值 K（一般是2、4 或 8）的倍数，这种限制简化了处理器和内存接口之间的设计，甚至有的系统没有进行数据对齐，程序就无法正常运行。</p>
<p>比如现在有一个如下的结构体。</p>
<pre><code class="language-c">struct S1 {
    int i;
    char c;
    int j;
}
</code></pre>
<p>如果编译器用最小的 9 字节分配，那么将是下面的这个样子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411921819.png" alt=""></figure>
<p>但是上面这种结构无法满足 i 和 j 的 4 字节对齐要求，所以编译器会在 c 和 j 之间插入 3 个字节的间隙。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411906634.png" alt=""></figure>
<p>在极客时间专栏中有这样一段代码。</p>
<pre><code class="language-c">int main(int argc, char *argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i &lt;= 3; i++){
        arr[i] = 0;
        printf(&quot;Hello world!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这段代码神奇的是在某种情况下会一直循环的输出<code>Hello world</code>，并不会结束，在<a href="https://mp.weixin.qq.com/s/BRRReU3akhqh8vgm59GNvA">计算机系统漫游（补充）</a>中也提到过。</p>
<p>造成上面这种结果是因为函数体内的局部变量存在栈中，并且是连续压栈，而 Linux 中栈又是从高向低增长。数组<code>arr</code>中是 3 个元素，加上 i 是 4 个元素，刚好满足 8 字节对齐（编译器 64 位系统下默认会 8 字节对齐），变量<code>i</code>在数组<code>arr</code>之前，即<code>i</code>的地址与<code>arr</code>相邻且比它大。</p>
<p>代码中很明显访问数组时越界了，当<code>i</code>为 3 时，实际上正好访问到变量<code>i</code>的地址，而循环体中又有一句<code>arr[i] = 0;</code>，即又把<code>i</code>的值设置为了 0，由此就导致了死循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[顺序、条件、循环语句的底层解释]]></title>
        <id>https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi</id>
        <link href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">
        </link>
        <updated>2018-11-11T11:19:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="顺序结构">顺序结构</h4>
<h5 id="数据传送指令">数据传送指令</h5>
<p>我们都清楚，绝大多数编译器都把汇编语言作为中间语言，把汇编语言程序变成可运行的二进制文件早就解决了，所以现在的高级语言基本上只需要把自己翻译成汇编语言就可以了。</p>
<p>汇编指令总共只有那么多，大多数指令都是对数据进行操作，比如常见的数据传送指令<code>mov</code>。不难理解，被操作数据无非有三种形式，<strong>立即数</strong>，即用来表示常数值；<strong>寄存器</strong>，此时的数据即存放在指定寄存器中的内容；<strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置。</p>
<p>需要注意的是，到了汇编层级，就不像高级语言那样随随便便<code>int</code>就能和<code>long</code>类型的数据相加减，他们在底层所占有的字节是不一样的，汇编指令是区分操作数据大小的，比如数据传送指令，就有下面这些品种（x86-64 对数据传送指令加了一条限制：两个操作数不能都指向内存位置）。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569410442560.png" alt=""></figure>
<h5 id="压栈与弹栈">压栈与弹栈</h5>
<p>对于栈，我想不必多讲，IT 行业的同学都清楚，它是一种线性数据结构，其中的数据遵循“先进后出”原则，寄存器<code>%rsp</code>保存着栈顶元素的地址，即栈顶指针。一个程序要运行起来，离不开栈这种数据结构。</p>
<p>栈使用最多的就是弹栈<code>popq</code>和压栈<code>pushq</code>操作。比如将一个四字值压入栈中，栈顶指针首先要减 8（栈向下增长），然后将值写到新的栈顶地址；而弹栈则需要先将栈顶数据读出，然后再将栈指针加 8。所以<code>pushq</code>和<code>popq</code>指令就可以表示为下面的形式。</p>
<pre><code class="language-c">// 压栈
subq $8, %rsp
movq %rbp, (%rsp)

// 弹栈
movq (%rsp), %rax
addq $8, %rsp
</code></pre>
<p>其他还有算术、逻辑、加载有效地址、移位等等指令，可以查阅相关文档了解，不作过多介绍，汇编看起来确实枯燥乏味。</p>
<h4 id="条件结构">条件结构</h4>
<p>前面讲的都是顺序结构，我们的程序中不可能只有顺序结构，条件结构是必不可缺的元素，那么汇编又是如何实现条件结构的呢？</p>
<p>首先你需要知道，除了整数寄存器，CPU 还维护着一组<strong>条件码寄存器</strong>，我们主要是了解如何把高级语言的条件结构转换为汇编语言，不去关注这些条件码寄存器，只需要知道汇编可以通过检测这些寄存器来执行条件分支指令。</p>
<h5 id="if-else-语句">if-else 语句</h5>
<p>下面是 C 语言中的<code>if-else</code>语句的通用形式。</p>
<pre><code class="language-c">if(test-expr){
    then-statement
}else{
    else-statement
}
</code></pre>
<p>汇编语言通常会将上面的 C 语言模板转换为下面的控制流形式，只要使用条件跳转和无条件跳转，这种形式的控制流就可以和汇编代码一一对应，我们以 C 语言形式给出。</p>
<pre><code class="language-c">    t = test-expr;
    if(!t){
        goto false;
    }
    then-statement;
    goto done;
false:
    else-statement;
done:
</code></pre>
<p>但是这种条件控制转移形式的代码在现代处理器上可能会很低效。原因是它无法事先确定要跳转到哪个分支，我们的处理器通过<strong>流水线</strong>来获得高性能，流水线的要求就是事先明确要执行的指令顺序，而这种形式的代码只有当条件分支求值完成后，才能决定走哪一个分支。即使处理器采用了非常精密的分支预测逻辑，但是还是有错误预测的情况，一旦预测错误，那将会浪费 15 ~ 30 个时钟周期，导致性能下降。</p>
<blockquote>
<p>在流水线中，把一条指令分为多个阶段，每个阶段只执行所需操作的一小部分，比如取指令、确定指令类型、读数据、运算、写数据以及更新程序计数器。流水线通过重叠连续指令的步骤来获得高性能，比如在取一条指令的同时，执行它前面指令的算术运算。所以如果事先不知道指令执行顺序，那么事先所做的预备工作就白干了。</p>
</blockquote>
<p>为了提高性能，可以改写成使用条件数据传送的代码，比如下面的例子。</p>
<pre><code class="language-c">v = test-expr ? then-expr : else-expr；

// 使用条件数据传送方法
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t){
    v = ve;
}
</code></pre>
<p>这样改写，就能提高程序的性能了，但是并不是所有的条件表达式都可以使用条件传送来编译，一般只有当两个表达式都很容易计算时，编译器才会采用条件数据传送的方式，大部分都还是使用条件控制转移方式编译。</p>
<h5 id="switch-语句">switch 语句</h5>
<p><code>switch</code>语句可以根据一个整数索引值进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。为了让<code>switch</code>的实现更加高效，使用了一种叫做<strong>跳转表</strong>的数据结构（Radis 也是用的跳表）。跳转表是一个数组，表项 i 是一个代码段的地址，当开关情况数量比较多的时候，就会使用跳转表。</p>
<p>我们举个例子，还是采用 C 语言的形式表是控制流，要理解的是执行<code>switch</code>语句的关键步骤就是通过跳转表来访问代码的位置。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
    long val = x;
    switch(n){
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
        case 103:
            val += 11;
            break;
        case 104:
        case 105:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
</code></pre>
<p>要注意的是，上面的代码中有的分支没有<code>break</code>，这种问题在笔试中会经常遇到，没有<code>break</code>会继续执行下面的语句，即变成了顺序执行。上面的代码会被翻译为下面这种控制流。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
        static void *jt[7] = {
            &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,
            &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,
            &amp;&amp;loc_D
        };
        unsigned long index = n - 100;
        long val;
        if(index &gt; 6){
            goto loc_def;
        }
        goto *jt[index];
    loc_A:
        val = x * 13;
        goto done;
    loc_B:
        x = x + 10;
    loc_C:
        val = x + 11;
        goto done;
    loc_D:
        val = x * x;
        goto done;
    loc_def:
        val = 0;
    done:
        *dest = val;
}
</code></pre>
<h4 id="循环结构">循环结构</h4>
<p>C 语言中有<code>do-while</code>、<code>while</code>和<code>for</code>三种循环结构，它们的通用形式一般都长下面那样。</p>
<pre><code class="language-c">// do-while
do
    body-statement
    while(test-expr);
    
// while
while(test-expr)
    body-statement
    
// for
for(init-expr; test-expr; update-expr)
    body-statement
</code></pre>
<p><code>do-while</code>的特点是<code>body-statement</code>一定会执行一次，所以我们可以将<code>do-while</code>翻译成下面的控制流形式，很容易就能联想到它的汇编形式。</p>
<pre><code class="language-c">loop:
    body-statement;
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p><code>while</code>循环我们给出两种形式的控制流，其中一种包含<code>do-while</code>形式，如下所示。</p>
<pre><code class="language-c">// 第一种形式
t = test-expr;
if(!t){
    goto done;
}
do
    body-statement;
    while(test-expr);
done:


// 第二种形式
    goto test;
loop:
    body-statement;
test:
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p>面试的时候，有的面试官会问你<code>for</code>循环的执行顺序，现在深入理解了三种循环的机制，再也不怕面试官啦。<code>for</code>循环可以转换成如下的<code>while</code>形式。</p>
<pre><code class="language-c">init-expr;
while(test-expr){
    body-statement;
    update-expr;
}
</code></pre>
<p>有了这种形式的<code>for</code>循环，我们只需要将其中的<code>while</code>部分再翻译一下就好了，前文给出了两种<code>while</code>翻译的方式，而具体采用哪种方式，取决于编译器优化的等级。</p>
<h4 id="总结">总结</h4>
<p>计算机就是用那么几条简简单单的指令就完成了各种复杂的操作，不得不折服于计算机科学家们的魅力。现在人工智能被炒的很火热，然后人是事件、情感驱动的，而计算机是控制流驱动的，所以从架构上就决定了，冯诺依曼体系计算机实现的都是弱人工智能。</p>
]]></content>
    </entry>
</feed>