<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-09-25T12:17:53.489Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[如何解决跨域请求问题]]></title>
        <id>https://mengxiaoxu.github.io//post/MYYZrm7wn</id>
        <link href="https://mengxiaoxu.github.io//post/MYYZrm7wn">
        </link>
        <updated>2019-09-25T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569413513576.JPG" alt=""></figure>
<p>刚毕业入职，大部分时间还在培训，中间有一段时间的空闲时间，就学习了下 Angular，在学校都是编写的单体应用，所有代码都放在同一个工程下面，到公司使用的是前后端分离了，虽然后端程序也是我自己写的，但是有一些数据是从公司现有接口去拿的，然后就遇到让我纠结了两小时的<strong>跨域请求问题</strong>，为了避免出现上图中的尴尬场面，在这里做一个简单的总结输出。</p>
<h4 id="什么是跨域请求">什么是跨域请求</h4>
<p>跨域请求问题是浏览器的<strong>同源策略</strong>造成的，该策略不允许执行其它网站的脚本，是浏览器施加的安全限制。什么是同源？最初是指网页  A 设置的 Cookie 不能被网页 B 打开，包括三个相同：<strong>协议、域名、端口</strong>。这个同源是从 URL 判断的，不是从 IP 判断的，如果同一个服务器对应连个域名，这两个域名是不同源的。</p>
<pre><code>http://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 非跨域

http://www.nealyang.cn/index.html 调用 http://www.neal.cn/server.php 跨域,主域不同

http://abc.nealyang.cn/index.html 调用 http://def.neal.cn/server.php 跨域,子域名不同

http://www.nealyang.cn:8080/index.html 调用 http://www.nealyang.cn/server.php 跨域,端口不同

https://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 跨域,协议不同

localhost 调用 127.0.0.1 跨域
</code></pre>
<p>同源政策的目的是为了保护用户信息的安全，防止恶意网站窃取数据，随着互联网的发展，同源政策更加严格了，下面三种行为都会受到限制。</p>
<pre><code>（1） Cookie、LocalStorage 和 IndexDB 无法读取。
（2） DOM 无法获得。
（3） AJAX 请求不能发送。
</code></pre>
<p>所有的现代浏览器都对网络连接进行了安全限制，包括 XMLHttpRequest，如果你的 web 应用程序和其使用的数据在同一个服务器，你不会遇到跨域请求问题。但是当你的 web 应用程序和 web 服务数据不在同一个服务器时，就会被浏览器限制连接了。</p>
<h4 id="常用解决方案">常用解决方案</h4>
<p>对于跨域请求有很多的解决方案，最常用的解决方案是在你的 web 服务器上面<strong>设置代理</strong>。在设置代理之前就通过，应用程序直接去请求另一个服务器下的数据；设置代理之后，应用程序从自己的 web 服务器中请求数据，再由代理去请求数据，这样 web 服务器拿到数据之后返回给应用程序即可。从浏览器角度看，就是从同一个服务器拿的数据，并没有进行跨域请求。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569413461355.gif" alt=""></figure>
<p>通俗易懂的说，你家的宠物狗不会吃别家的食物，因为它担心别人的食物会把自己给药死，所以你的狗狗只管找你要食物，你是它的主人，它绝对相信你，而你可以鉴别别人给的食物是不是安全的。类比，小狗就是浏览器，你就是代理。</p>
<h4 id="angular-中的解决办法">Angular 中的解决办法</h4>
<p>上面所说的解决方案在开发过程中不方便操作，每新发一个接口都到服务器中去配置一下，不仅麻烦而且效率低下。首先说一下在 Angular 中一个人比较常用的解决方法，默认你在使用<code>angular-cli</code>构建你的项目，我们可以创建一个代理配置文件<code>proxy.conf.json</code>（假设你的后端服务的访问地址为<code>10.121.163.10:8080</code>），代理配置文件如下：</p>
<pre><code class="language-json">{
  &quot;/api&quot;: {
    &quot;target&quot;: &quot;http://10.121.163.10:8080&quot;,
    &quot;secure&quot;: false
  }
}
</code></pre>
<p>然后修改<code>package.json</code>文件中的启动命令为<code>&quot;start&quot;: &quot;ng serve --proxy-config proxy.conf.json&quot;</code>，启动项目时使用<code>npm start</code>即可解决跨域请求问题。</p>
<p>上述解决方案仅在开发时使用，你当然可以使用 tomcat、nginx 配置代理，但是这很麻烦，需要打包代码部署，为了保证效率，我们想写完了立刻测试，同时也不想麻烦做后端的同学，在项目发布时，应该把代理配置到服务器中去；修改启动命令也不是必须的，你也可以选择每次使用 <code>ng serve --proxy-config proxy.conf.json</code>命令启动项目；示例代理配置文件内容可以有更多的属性，可以通过网络查阅相关资料。</p>
<h4 id="后端解决办法">后端解决办法</h4>
<p>我的后端是是用 tornado 实现的，然后我又写了一个单独的页面用于在大屏幕上展示相关数据，没有用 Angular 了，要通过 AJAX请求数据，又怎么解决跨域请求问题呢？这时就需要设置请求头了，让后端允许跨域请求。</p>
<p>这时需要了解一下<strong>简单请求</strong>和<strong>非简单请求</strong>了，简单请求就是只发送一次请求的请求；非简单请求会发送数据之前先发一次请求做<strong>预检</strong>，通过预检后才能再发送一次请求用于数据传输。</p>
<p>更清晰区别，满足下列两大条件的属于简单请求，而非简单请求就是请求方法为<code>PUT</code>或<code>DELETE</code>，或者 <code>Content-Type</code>字段是<code>application/json</code>的请求。</p>
<blockquote>
<p>1.请求方法为 GET、POST、HEAD之一<br>
2.HTTP头信息不超出字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type，并且 Content-Type 的值仅限于 application/x-www-form-urlencoded、multipart/form-data、text/plain。</p>
</blockquote>
<p>对于简单请求，只需要设置一下响应头就可以了。</p>
<pre><code class="language-python">class TestHandler(tornado.web.RequestHandler):
    def get(self):
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        # 可以把 * 写成具体的域名
        self.write('cors get success')
</code></pre>
<p>对于复杂请求，需要设置预检方法，如下所示：</p>
<pre><code class="language-python">class CORSHandler(tornado.web.RequestHandler):
    # 复杂请求方法put
    def put(self):
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        self.write('put success')
    # 预检方法设置
    def options(self, *args, **kwargs):
        #设置预检方法接收源
        self.set_header('Access-Control-Allow-Origin', &quot;*&quot;)
        #设置预复杂方法自定义请求头h1和h2
        self.set_header('Access-Control-Allow-Headers', &quot;h1,h2&quot;)
        #设置允许哪些复杂请求方法
        self.set_header('Access-Control-Allow-Methods', &quot;PUT,DELETE&quot;)
        #设置预检缓存时间秒,缓存时间内发送请求无需再预检
        self.set_header('Access-Control-Max-Age', 10)
</code></pre>
<p>本人不太懂前端知识，更多的前端跨域解决方案可以参考下面列出的文章，除第一篇外，其他都介绍了前端跨域解决方法。</p>
<p>参考资料及推荐文章</p>
<pre><code>标题：JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls
链接：https://developer.yahoo.com/javascript/howto-proxy.html?guccounter=1

标题：别慌，不就是跨域么!
链接：https://mp.weixin.qq.com/s/A0Oi-fUrmboRPPeNEjG3aw

标题：跨域资源共享 CORS 详解
链接：http://www.ruanyifeng.com/blog/2016/04/cors.html

标题：AJAX请求和跨域请求详解（原生JS、Jquery）
链接：http://www.cnblogs.com/tkqasn/p/5869175.html

标题：JavaScript跨域总结与解决办法
链接：http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阅读高于自己的作品，远离精神毒品]]></title>
        <id>https://mengxiaoxu.github.io//post/FoEH1GV6f</id>
        <link href="https://mengxiaoxu.github.io//post/FoEH1GV6f">
        </link>
        <updated>2019-09-25T12:06:54.000Z</updated>
        <content type="html"><![CDATA[<p>关于阅读与写作的重要性，可能每个人都多少有一些概念。阅读打开世界的大门，写作提升语言组织能力。</p>
<p>还在读大一大二的时候，我很崇拜那些随随便便就能做一个网站、写一个复杂算法的大神。那时候仅仅盯着技术，认为只要技术好，怎么样都行，因此在大二阶段，我没有读过一本技术之外的书籍，现在看来是眼界狭隘了。</p>
<p>专业能力是生存之本，但是其他方面的能力也同样重要，大学能交给我们的只是一个在社会上赖以生存的本领（实际上一部分连赖以生存的本领都没有从大学学到），其他的技能需要靠自己的主动学习。</p>
<p>阅读是一种了解知识的重要手段，但并不是所有的阅读都是有效的，甚至有的阅读是精神毒品。</p>
<p>阅读需要挑选高于自己的作品，要能仰视它，才能攀登。现在的生活节奏很快，碎片化阅读成了很多人的阅读方式；有人抨击碎片化阅读，也有人提倡碎片化阅读，每个人由不同的观点，我个人是赞同碎片化阅读的。</p>
<p>来自互联网的阅读内容和自己大多是平等的，每个人都在使用微信，但我相信很多人都有屏蔽一些人朋友圈的习惯，因为你会选择跟你脾气相同、你喜欢的、跟你水平接近内容去阅读；现在的 APP 也很多，而且很多首次注册都会让你选择自己感兴趣的内容，所以也就会失去挑战自我的机会。</p>
<p>阅读是提升认知的重要手段，人与人之间的根本差距在于认知，如果读了一本书之后能让自己的认知得到提升，那么这就没白读；当然，如果读完一本书或是一篇文章之后能让有很大程度的转变，那这种认知的提升我相信是宝贵的财富，而且认识是伴随终身的。能达到这样效果的好文章、好书肯定少之又少，对我个人影响的最大的一本书是《把时间当作朋友》，我很推荐这本书，接触这本书算我认知上的一个转折点。</p>
<p>也有一些阅读是日积月累对自己产生影响的。我曾经关注了近 150 个公众号，从里面精挑细选了一部分原创公众号留下，涉及技术、新闻、产品、理财等方面。我现在每天的阅读主要就是公众号阅读和付费加入的几个知识星球，以及得到上面的付费知识。</p>
<p>日积月累，我筛选有效信息的能力也更强了，我认为筛选信息能力在这个信息爆炸的时代是很重要的。</p>
<p>有一次听到朋友说：“文章太长了，我不想看”。我没说话，只给了一个无奈的眼神，因为他只想要一个结论，因为这可以很轻松的获得一种愉悦感，而且对大脑来说，也是最容易接受的，但是慢慢地，大脑就会失去独立思考的能力。</p>
<p>从产品角度讲，不得不佩服头条对人性的洞察，为了“懂你”，在自己的产品上加入推荐算法，但实际上是让你把时间花在他们产品的身上，把产品做到这种程度，不得不说是很牛的。</p>
<p>但是像抖音、快手、头条、微博这些产品我认为基本都是在浪费用户时间（我还没有用过快手和微博，评价它们有点冒昧了），他们无异于精神毒品，吞噬你的时间。我并不是讨厌这些产品，我自己也喜欢体验新的产品，我只是觉得把宝贵的时间放到更有价值的事情上去，那么就会比周边人更加优秀。</p>
<p>需要选择的是高于自己内容阅读，而不是把时间都花在那种不需要思考就能得到的愉悦上去；如果把大部分时间都花在轻易就能获得的愉悦感上，那么你应该正在一步步颓废。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录在南京大学的半天]]></title>
        <id>https://mengxiaoxu.github.io//post/aSkANU6p0</id>
        <link href="https://mengxiaoxu.github.io//post/aSkANU6p0">
        </link>
        <updated>2019-09-25T12:01:17.000Z</updated>
        <content type="html"><![CDATA[<p>因为工作需要，到南京出差了半个月，中间利用周末和最好的朋友疯了一天，之后自己又一个人到南京大学鼓楼校区逛了逛。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412914052.JPG" alt=""></figure>
<p>不会勾搭妹子的我总是能勾搭到老爷爷，到南大就勾搭了一个 86 岁高龄的老教授，他毕业于中山大学，年轻时候是做地质工作的。</p>
<p>我就像个熊孩子一样要爷爷给我讲有趣的故事，要听他讲我们这一代人或者是大部分人都不知道的历史。</p>
<p>爷爷虽然已经是快到耄耋之年的人了，但是对年轻时候的事记得很清楚，只是对最近的事记不起来。这篇文章仅仅是记录一下爷爷所讲的趣事。</p>
<p>爷爷年轻时候接到中科院的任务，前往内蒙古考察。在考察期间他们用汽车压死过一只狼，而且当时吃了狼肉，一行 30 多个人都吃过那匹狼的心，但是没有吃过狗肺。</p>
<p>据爷爷说，狼是很狡猾的动物，他们用汽车去追狼，狼就在原地不跑，等到你离它只有 10 来米的时候，突然拐弯跑了，这样的情况他们一共遇到了 6 次。这和《狼图腾》一书中的描写基本一致，狼有先进的军事文化。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412927749.JPG" alt=""></figure>
<p>爷爷告诉我，南大起源于金陵大学，南京大学的标志性建筑「北大楼」是个教堂的样子，金陵大学本来是个教会大学，现在的「北大楼」就是原来的「钟楼」。</p>
<p>南大的地下有隧道，是当年毛主席提倡「深挖洞、广积粮、不称霸」时挖的，目的是为了防空。后来被南京食品公司用来存放香蕉，就是那种没有熟的香蕉，在隧道里面放熟了，再拿出来卖。不过现在隧道所有的口都没堵上了，完全废弃了。</p>
<p>在南大，有一些楼中间有 5 层，然后到两遍就只有 3 层了，整体看来像是个三角形。实际上这些楼当年都是要修 8 层的，因为那时候没钱，建着建着发现没资金了，所以就封顶了。</p>
<p>但是南大计算中心那栋楼只有 3 层却不是因为没钱，而是因为它旁边是消防大队，本来也是要建 8 层的，消防队说建高了挡住了他们视线，不能及时发现火情。爷爷笑着对我说：“但是也没见他们在上面拿个望远镜望啊！”。</p>
<p>我们都知道「五四运动」，但是却很少有人知道「四五运动」，这个运动的起源就在南大，当时 300 多学生（我回来查资料说是 400）发起了这个运动，后来演变为全国性的运动，直接带动了半年后四人帮被粉碎。</p>
<p>那是爷爷是个老师，他说他们教职工是很支持这些学生的，但是不敢公开性的支持。学生们很聪明，把标语刷到火车上，但是所有出南京的火车都被四人帮用水把标语给冲刷掉了，学生们就用沥青往火车上面写，才通过火车把这项运动的信息带到了全国各地。</p>
<blockquote>
<p>我回来后查了一点资料，「四五运动」的起源是因为周恩来总理的去世，四人帮居然压制人民群众悼念周恩来，诬陷邓小平，而那时的毛主席也已经病到无法行动。</p>
</blockquote>
<blockquote>
<p>人们把花圈都放到人民英雄纪念碑前悼念周总理，却被四人帮给清理了，北京广大人民群众在“还我花圈，还我战友”的口号下行成了天安门广场大规模的群众抗议运动。</p>
</blockquote>
<blockquote>
<p>那也是一个诗意的年代，人们通过写诗来表达自己心中的愤怒，把小瓶子挂在树上，蕴意着期待邓小平的归来。那段时间四人帮应该是很难过的，从姚文元的日记就可以看出来。</p>
</blockquote>
<p>爷爷还给我讲了一点他们的研究，他们研究行政规划的很多人认为，中国现在的行政划分有很多缺点的，中国应该划分 50~80 个省级单位。现在中国的行政级别也有问题，宪法规定行政层级只有三级（这一点我没查），而现在很多地方县下面是镇，镇下面还有乡，严格讲这是违宪的。</p>
<p>快到午饭时间时，爷爷还教我写了一会儿字，有的简体字很难看，比如「龍飛鳳舞」用繁体字写出来很好看，但是用简体字写出来就特难看。要想练好毛笔字，把三个字写好了就行了，然而我现在只记得一个“飛”字了，这可能就是老师们常说的「你又还给我了」。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[告别囤干货，你才能真正进步]]></title>
        <id>https://mengxiaoxu.github.io//post/8-A2fl99e</id>
        <link href="https://mengxiaoxu.github.io//post/8-A2fl99e">
        </link>
        <updated>2019-09-25T11:52:46.000Z</updated>
        <content type="html"><![CDATA[<p>这两天，没事整理了自己的微信收藏和 QQ 收藏文件夹下面的文章。发现了一个在大多数人身上都存在的问题，那就是<strong>囤干货</strong>。</p>
<p>我使用微信的时间比较晚，从14年才开始，但是仅仅不到4年的时间，在微信收藏里面就有几百篇文章，有一些传授技能的文章，比如 word、ps 等简单教程；其他一些属于心灵鸡汤类文章（现在反倒不觉得这类文章值得看），还有一些搞笑的文章，当然里面也夹杂着些许的优秀视频。文章数量数 14 年和 15 年最多。</p>
<p>现在回头看，我当时就陷入了囤文章的陷阱了，或者说自己是在“假装阅读”。仔细一想，其实生活中大多数人都有类似的举动。早成起床、饭后的一段时间、晚上睡觉前，这些时间大多数人都习惯性的去翻翻公众号、朋友圈，这里面不乏有好文章、干货文章。然而没多少人会静下心来把文章读完，而是在大概读到一半的时候，选择收藏这篇文章，然后在心里告诉自己，明天要好好读一下这篇文章。到了明天，其实又是重复了今天的这样一个过程。</p>
<p>记得大概一年前也无意中看到大学认识的一位师弟发的说说，内容如下：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412401636.jpg" alt=""></figure>
<p>上面的图是我特地翻出来的，一年后这个师弟又发了一条说说，存满了两个云盘，应该是有 5000 G 左右的资源。</p>
<p>我认为这都是在假装学习，而且假装学习的人不计其数。为什么上学的时候，那些每天都静静的待在教室学习的同学，成绩反倒不是很好呢？而且大多数这样的学生在班级都是排在中等，而成绩好的学生却不是学习投入最多的人。背后的原因显而易见。</p>
<p>我囤课最严重的时间段是也是 14 年和 15 年，网上有不少干货资源，什么 Linux、各种项目实战、计算机网络等等培训视频不计其数。那时候干的第一件事就是，上百度云把这些资源下下来，而且一个资源往往要下一周甚至更久；然后告诉自己，下周开始每天看一段视频，但是最终的结果是过去了 N 个下周，依然没有去处理这些资源。</p>
<p>现在博客、公众号也有一些不知道是为了获取更多人的关注，还是仅仅是做公益，文章末尾会标注：关注公众号，回复“XXXXX”，即可获得多少多少G的资源，这个多少一般是在 500 以上。我个人现在是对这类文章没有什么兴趣的，因为几百 G 甚至上千 G 的东西，我是不可能看完的，我清楚自己的能力，我也不否认可能有人有毅力能看完，那肯定是凤毛菱角了，我一个普通人不与凤毛菱角对比。</p>
<p>当然，我现在的认识相比几年前，得到了一些提升，至少我现在不糊干囤课之类的事了，仅仅是把干货囤在那里，其时你还是昨天的自己，并没有进步。现在我都会把自己收藏的好文章在一周之内处理掉。</p>
<p>所以要想真正取得进步，首先就需要告别囤课的习惯，不能假装学习，如果学习是为了给比别人看，那还不如不学。文章仅是我个人的一点感悟，没有文采逻辑和言，总之希望与你共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么处理排序数组比未排序数组快]]></title>
        <id>https://mengxiaoxu.github.io//post/SpXxa8r-v</id>
        <link href="https://mengxiaoxu.github.io//post/SpXxa8r-v">
        </link>
        <updated>2019-09-25T11:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天在群里看到一个有意思的问题——为什么处理排序数组比处理没有排序的数组要快，这个问题来源于 <a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">StackoverFlow</a>，虽然我看到代码略微知道原因，但是模模糊糊不够清晰，搜了很多博客也讲的不够明白，所以就自己来总结了。</p>
<p>首先来看一下问题，下面是很简单的一段代码，随机生成一些数字，对其中大于 128 的元素求和，记录并打印求和所用时间。</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c &lt; arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i &lt; 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c &lt; arraySize; ++c)
            {
                if (data[c] &gt;= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println(&quot;sum = &quot; + sum);
    }
}
</code></pre>
<p>我的运行结果：分别在对数组排序和不排序的前提下测试，在不排序时所用的时间比先排好序所用时间平均要多 10 ms。这不是巧合，而是必然的结果。</p>
<p>问题就出在那个<code>if</code>判断上面，在旧文<a href="https://mp.weixin.qq.com/s/8WwJK0CfKz1o_bwefxBd5Q">顺序、条件、循环语句的底层解释</a>中其实已经提到了造成这种结果的原因，只是旧文中没有拿出具体的例子来说明。</p>
<p>为了把这个问题搞明白，需要先对<code>流水线</code>有一定的了解。计算机是指令流驱动的，执行的是一个一个的指令，而执行一条指令，又要经过<code>取指、译码、执行、访存、写回、更新</code>六个阶段（不同的划分方式所包含的阶段不一样）。</p>
<p>六个阶段使用的硬件基本是不一样的，如果一条指令执行完再去执行另一条指令，那么在这段时间里会有很多硬件处于空闲状态，要使计算机的速度变快，那么就不能让硬件停下来，所以有了流水线技术。</p>
<p>流水线技术通过将指令重叠来实现几条指令并行处理，下图表示的是三阶段指令时序，即把一个指令分为三个阶段。在第一条指令的 B 阶段，A 阶段相关的硬件是空闲的，于是可以将第二条指令的 A 阶段提前操作。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412133980.png" alt=""></figure>
<p>很明显，这种设计大幅提高了指令运行的效率，聪明的你可能发现问题了，要是不知道下一条指令是什么怎么办，那提前的阶段也就白干了，那样流水线不就失效了？没错，这就是导致开篇问题的原因。</p>
<p>让流水线出问题的情况有三种：1、<code>数据相关</code>，后一条指令需要用到前一条指令的运算结果；2、<code>控制相关</code>，比如无条件跳转，跳转的地址需要在译码阶段才能知道，所以跳转之后已经被取出的指令流水就需要清空；3、<code>结构相关</code>，由于一些指令需要的时钟周期长（比如浮点运算等），长时间占用硬件，导致之后的指令无法进入译码等阶段，即它们在争用同一套硬件。</p>
<p>代码中的<code>if (data[c] &gt;= 128)</code>翻译成机器语言就是跳转指令，处理器事先并不知道要跳转到哪个分支，那难道就等知道了才开始下一条指令的取指工作吗？处理器选择了假装知道会跳转到哪个分支（不是谦虚，是真的假装知道），如果猜中了是运气好，而没有猜中那就浪费一点时间重新来干。</p>
<p>没有排序的数组，元素是随机排列的，每次<code>data[c] &gt;= 128</code>的结果也是随机的，前面的经验就不可参考，所以下一次执行到这里理论上还是会有 50% 的可能会猜错，猜错了肯定就需要花时间来修改犯下的错误，自然就会浪费更多的时间。</p>
<p>对于排好序的数组，开始几次也需要靠猜，但是猜着猜着发现有规律啊，每次都是往同一个分支跳转，所以以后基本上每次都能猜中，当遍历到与 128 分界的地方，才会出现猜不中的情况，但是猜几次之后，发现这又有规律啊，每次都是朝着另外一个相同分支走的。</p>
<p>虽然都会猜错，但是在排好序的情况下猜错的几率远远小于未排序时的几率，最终呈现的结果就是处理排序数组比未排序数组快，其原因就是流水线发生了大量的控制相关现象，下面通俗一点，加深一下理解。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412222054.jpg" alt=""></figure>
<p>远在他方心仪多年的姑娘突然告诉你，其实她也喜欢你，激动的你三天三夜睡不着觉，决定开车前往她的城市，要和她待在一起，但是要去的路上有很多很多岔路，你只能使用的某某地图导航，作为老司机并且怀着立马要见到爱人心情的你，开车超快，什么样罚单都不在乎了。</p>
<p>地图定位已经跟不上你的速度了，为了尽快到达，遇到岔路你都是随机选一条路前进，遗憾的是，自己的选择不一定对（我们假设高速可以回退），走错路了就要重新回到分岔点，这就对应着未排序的情况。</p>
<p>现在岔路是有规律的，告诉你开始一直朝着一边走，到某个地点后会一直朝着另一边走，你只需要花点时间去探索一下开始朝左边还是右边，到了中间哪个地点会改变方向就可以了，相比之下就能节省不少时间了，尽快见到自己的爱人，这对应着排好序的情况。</p>
<blockquote>
<p>最后的故事改编自两个人的现实生活，一位是自己最好的朋友之一，谈恋爱开心的睡不着觉；另一位是微信上的一位好友，为了对方从北京裸辞飞到了深圳。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数调用与空间分配]]></title>
        <id>https://mengxiaoxu.github.io//post/cYbqHG1mh</id>
        <link href="https://mengxiaoxu.github.io//post/cYbqHG1mh">
        </link>
        <updated>2019-09-25T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们在编程序的时候，都会把某一个特定功能封装在一个函数里面，对外暴露一个接口，而隐藏了函数行为的具体实现，一个大型的复杂系统里面包含了很多这样的小函数，我们称之为<strong>过程</strong>。</p>
<p>过程是相对独立的小模块，系统的运行需要这些过程的紧密合作，这种合作就是函数调用。</p>
<p>在一个函数执行时调用别的函数，比如 P 调用 Q，需要执行一些特定的动作。<code>传递控制</code>，在调用 Q 之前，控制权在 P 的手里，既然要调用 Q，那么就需要把控制权交给 Q；<code>传递数据</code>，就是函数传参；<code>分配与释放内存</code>，在开始时，Q 可能需要位局部变量分配空间，结束时又必须释放这些存储空间。</p>
<p>大多数语言都使用栈提供的先进后出机制来管理内存，x86-64 可以通过通用寄存器传递最多 6 个整数值（整数或地址），如果超过 6 个，那就需要在栈中分配内存，并且通过栈传递参数时，所有数据的大小都要向 8 的倍数对齐。将控制权从 P 转交给 Q，只需要将 PC（程序计数器）的值置为 Q 代码的起始位置，并记录好 P 执行的位置，方便 Q 执行完了，继续执行 P 剩余的代码。</p>
<p>在函数的传参、执行中，多多少少都需要空间来保存变量，局部数据能保存在寄存器中就会保存在寄存器中，如果寄存器不够，将会保存在内存中。除了寄存器不够用的情况，还有数组、结构体和地址等局部变量都必须保存在内存中。分配内存很简单，只需要减小栈指针的值就行了，同样释放也只需要增加栈指针。</p>
<p>在函数执行过程中，处理栈指针<code>%rsp</code>，其它寄存器都被分类为<code>被调用者保存寄存器</code>，即当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。</p>
<p>所以递归也就不难理解了，初学算法总觉得递归有点奇妙，怎么自己调用自己，而实际上对于计算机来说，它和调用其它函数没什么区别，在计算机眼里，没有自身与其它函数的区别，所有被调用者都是其它人。</p>
<p>数组是编程中不可或缺的一种结构，“数组是分配在连续的内存中”这句话已经烂熟于心了，历史上，C 语言只支持大小在编译时就能确定的多维数组，这个多多少少有一些不便利，所以在<code>ISO C99</code>标准中就引入了新的功能，允许数组的维度是表达式。</p>
<pre><code class="language-c">int A[expr1][expr2]
</code></pre>
<p>因为数组是连续的内存，所以很容易就能访问到指定位置的元素，它通过首地址加上偏移量即可计算出对应元素的地址，这个偏移量一定意义上就是由索引给出。</p>
<p>比如现在有一个数组<code>A</code>，那么<code>A[i]</code>就等同于表达式<code>* (A + i)</code>，这是一个指针运算。C 语言的一大特性就是指针，既是优点也是难点，单操作符<code>&amp;</code>和<code>*</code>可以产生指针和简介引用指针，也就是，对于一个表示某个对象的表达式<code>expr</code>，<code>&amp;expr</code>给出该对象地址的一个指针，而对于一个表示地址的表达式<code>Aexpr</code>，<code>*Aexpr</code>给出该地址的值。</p>
<p>即使我们创建嵌套（多维）数组，上面的一般原则也是成立的，比如下面的例子。</p>
<pre><code class="language-c">int A[5][3];

// 上面声明等价于下面
typedef int row3_t[3];
row3_t A[5];
</code></pre>
<p>这个数组在内存的中就是下面那个样子的。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411935351.png" alt=""></figure>
<p>还有一个重要的概念叫做<code>数据对齐</code>，即很多计算机系统要求某种类型的对象的地址必须是某个值 K（一般是2、4 或 8）的倍数，这种限制简化了处理器和内存接口之间的设计，甚至有的系统没有进行数据对齐，程序就无法正常运行。</p>
<p>比如现在有一个如下的结构体。</p>
<pre><code class="language-c">struct S1 {
    int i;
    char c;
    int j;
}
</code></pre>
<p>如果编译器用最小的 9 字节分配，那么将是下面的这个样子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411921819.png" alt=""></figure>
<p>但是上面这种结构无法满足 i 和 j 的 4 字节对齐要求，所以编译器会在 c 和 j 之间插入 3 个字节的间隙。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411906634.png" alt=""></figure>
<p>在极客时间专栏中有这样一段代码。</p>
<pre><code class="language-c">int main(int argc, char *argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i &lt;= 3; i++){
        arr[i] = 0;
        printf(&quot;Hello world!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这段代码神奇的是在某种情况下会一直循环的输出<code>Hello world</code>，并不会结束，在<a href="https://mp.weixin.qq.com/s/BRRReU3akhqh8vgm59GNvA">计算机系统漫游（补充）</a>中也提到过。</p>
<p>造成上面这种结果是因为函数体内的局部变量存在栈中，并且是连续压栈，而 Linux 中栈又是从高向低增长。数组<code>arr</code>中是 3 个元素，加上 i 是 4 个元素，刚好满足 8 字节对齐（编译器 64 位系统下默认会 8 字节对齐），变量<code>i</code>在数组<code>arr</code>之前，即<code>i</code>的地址与<code>arr</code>相邻且比它大。</p>
<p>代码中很明显访问数组时越界了，当<code>i</code>为 3 时，实际上正好访问到变量<code>i</code>的地址，而循环体中又有一句<code>arr[i] = 0;</code>，即又把<code>i</code>的值设置为了 0，由此就导致了死循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[顺序、条件、循环语句的底层解释]]></title>
        <id>https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi</id>
        <link href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">
        </link>
        <updated>2019-09-25T11:19:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="顺序结构">顺序结构</h4>
<h5 id="数据传送指令">数据传送指令</h5>
<p>我们都清楚，绝大多数编译器都把汇编语言作为中间语言，把汇编语言程序变成可运行的二进制文件早就解决了，所以现在的高级语言基本上只需要把自己翻译成汇编语言就可以了。</p>
<p>汇编指令总共只有那么多，大多数指令都是对数据进行操作，比如常见的数据传送指令<code>mov</code>。不难理解，被操作数据无非有三种形式，<strong>立即数</strong>，即用来表示常数值；<strong>寄存器</strong>，此时的数据即存放在指定寄存器中的内容；<strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置。</p>
<p>需要注意的是，到了汇编层级，就不像高级语言那样随随便便<code>int</code>就能和<code>long</code>类型的数据相加减，他们在底层所占有的字节是不一样的，汇编指令是区分操作数据大小的，比如数据传送指令，就有下面这些品种（x86-64 对数据传送指令加了一条限制：两个操作数不能都指向内存位置）。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569410442560.png" alt=""></figure>
<h5 id="压栈与弹栈">压栈与弹栈</h5>
<p>对于栈，我想不必多讲，IT 行业的同学都清楚，它是一种线性数据结构，其中的数据遵循“先进后出”原则，寄存器<code>%rsp</code>保存着栈顶元素的地址，即栈顶指针。一个程序要运行起来，离不开栈这种数据结构。</p>
<p>栈使用最多的就是弹栈<code>popq</code>和压栈<code>pushq</code>操作。比如将一个四字值压入栈中，栈顶指针首先要减 8（栈向下增长），然后将值写到新的栈顶地址；而弹栈则需要先将栈顶数据读出，然后再将栈指针加 8。所以<code>pushq</code>和<code>popq</code>指令就可以表示为下面的形式。</p>
<pre><code class="language-c">// 压栈
subq $8, %rsp
movq %rbp, (%rsp)

// 弹栈
movq (%rsp), %rax
addq $8, %rsp
</code></pre>
<p>其他还有算术、逻辑、加载有效地址、移位等等指令，可以查阅相关文档了解，不作过多介绍，汇编看起来确实枯燥乏味。</p>
<h4 id="条件结构">条件结构</h4>
<p>前面讲的都是顺序结构，我们的程序中不可能只有顺序结构，条件结构是必不可缺的元素，那么汇编又是如何实现条件结构的呢？</p>
<p>首先你需要知道，除了整数寄存器，CPU 还维护着一组<strong>条件码寄存器</strong>，我们主要是了解如何把高级语言的条件结构转换为汇编语言，不去关注这些条件码寄存器，只需要知道汇编可以通过检测这些寄存器来执行条件分支指令。</p>
<h5 id="if-else-语句">if-else 语句</h5>
<p>下面是 C 语言中的<code>if-else</code>语句的通用形式。</p>
<pre><code class="language-c">if(test-expr){
    then-statement
}else{
    else-statement
}
</code></pre>
<p>汇编语言通常会将上面的 C 语言模板转换为下面的控制流形式，只要使用条件跳转和无条件跳转，这种形式的控制流就可以和汇编代码一一对应，我们以 C 语言形式给出。</p>
<pre><code class="language-c">    t = test-expr;
    if(!t){
        goto false;
    }
    then-statement;
    goto done;
false:
    else-statement;
done:
</code></pre>
<p>但是这种条件控制转移形式的代码在现代处理器上可能会很低效。原因是它无法事先确定要跳转到哪个分支，我们的处理器通过<strong>流水线</strong>来获得高性能，流水线的要求就是事先明确要执行的指令顺序，而这种形式的代码只有当条件分支求值完成后，才能决定走哪一个分支。即使处理器采用了非常精密的分支预测逻辑，但是还是有错误预测的情况，一旦预测错误，那将会浪费 15 ~ 30 个时钟周期，导致性能下降。</p>
<blockquote>
<p>在流水线中，把一条指令分为多个阶段，每个阶段只执行所需操作的一小部分，比如取指令、确定指令类型、读数据、运算、写数据以及更新程序计数器。流水线通过重叠连续指令的步骤来获得高性能，比如在取一条指令的同时，执行它前面指令的算术运算。所以如果事先不知道指令执行顺序，那么事先所做的预备工作就白干了。</p>
</blockquote>
<p>为了提高性能，可以改写成使用条件数据传送的代码，比如下面的例子。</p>
<pre><code class="language-c">v = test-expr ? then-expr : else-expr；

// 使用条件数据传送方法
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t){
    v = ve;
}
</code></pre>
<p>这样改写，就能提高程序的性能了，但是并不是所有的条件表达式都可以使用条件传送来编译，一般只有当两个表达式都很容易计算时，编译器才会采用条件数据传送的方式，大部分都还是使用条件控制转移方式编译。</p>
<h5 id="switch-语句">switch 语句</h5>
<p><code>switch</code>语句可以根据一个整数索引值进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。为了让<code>switch</code>的实现更加高效，使用了一种叫做<strong>跳转表</strong>的数据结构（Radis 也是用的跳表）。跳转表是一个数组，表项 i 是一个代码段的地址，当开关情况数量比较多的时候，就会使用跳转表。</p>
<p>我们举个例子，还是采用 C 语言的形式表是控制流，要理解的是执行<code>switch</code>语句的关键步骤就是通过跳转表来访问代码的位置。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
    long val = x;
    switch(n){
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
        case 103:
            val += 11;
            break;
        case 104:
        case 105:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
</code></pre>
<p>要注意的是，上面的代码中有的分支没有<code>break</code>，这种问题在笔试中会经常遇到，没有<code>break</code>会继续执行下面的语句，即变成了顺序执行。上面的代码会被翻译为下面这种控制流。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
        static void *jt[7] = {
            &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,
            &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,
            &amp;&amp;loc_D
        };
        unsigned long index = n - 100;
        long val;
        if(index &gt; 6){
            goto loc_def;
        }
        goto *jt[index];
    loc_A:
        val = x * 13;
        goto done;
    loc_B:
        x = x + 10;
    loc_C:
        val = x + 11;
        goto done;
    loc_D:
        val = x * x;
        goto done;
    loc_def:
        val = 0;
    done:
        *dest = val;
}
</code></pre>
<h4 id="循环结构">循环结构</h4>
<p>C 语言中有<code>do-while</code>、<code>while</code>和<code>for</code>三种循环结构，它们的通用形式一般都长下面那样。</p>
<pre><code class="language-c">// do-while
do
    body-statement
    while(test-expr);
    
// while
while(test-expr)
    body-statement
    
// for
for(init-expr; test-expr; update-expr)
    body-statement
</code></pre>
<p><code>do-while</code>的特点是<code>body-statement</code>一定会执行一次，所以我们可以将<code>do-while</code>翻译成下面的控制流形式，很容易就能联想到它的汇编形式。</p>
<pre><code class="language-c">loop:
    body-statement;
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p><code>while</code>循环我们给出两种形式的控制流，其中一种包含<code>do-while</code>形式，如下所示。</p>
<pre><code class="language-c">// 第一种形式
t = test-expr;
if(!t){
    goto done;
}
do
    body-statement;
    while(test-expr);
done:


// 第二种形式
    goto test;
loop:
    body-statement;
test:
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p>面试的时候，有的面试官会问你<code>for</code>循环的执行顺序，现在深入理解了三种循环的机制，再也不怕面试官啦。<code>for</code>循环可以转换成如下的<code>while</code>形式。</p>
<pre><code class="language-c">init-expr;
while(test-expr){
    body-statement;
    update-expr;
}
</code></pre>
<p>有了这种形式的<code>for</code>循环，我们只需要将其中的<code>while</code>部分再翻译一下就好了，前文给出了两种<code>while</code>翻译的方式，而具体采用哪种方式，取决于编译器优化的等级。</p>
<h4 id="总结">总结</h4>
<p>计算机就是用那么几条简简单单的指令就完成了各种复杂的操作，不得不折服于计算机科学家们的魅力。现在人工智能被炒的很火热，然后人是事件、情感驱动的，而计算机是控制流驱动的，所以从架构上就决定了，冯诺依曼体系计算机实现的都是弱人工智能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息的表示和处理]]></title>
        <id>https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li</id>
        <link href="https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li">
        </link>
        <updated>2019-09-24T17:02:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="字数据大小">字数据大小</h4>
<p>前面已经提到过<code>信息=位+上下文</code>，但是基本上的计算机都没有将位作为最小的可寻址单位，而是将字节作为了最小的可寻址单位，内存就是一个非常大的字节数组，它的的每个字节都由一个唯一的数字来标识（这个数字是不需要存的），所有可能的地址集合就是虚拟地址空间。</p>
<p>我们常说的 32 位、64 位指的是一台计算机的<strong>字长</strong>，用于指明指针数据的的标称大小。有的面试官在面试的时候会问这样一个问题：在 C/C++ 中指针的大小是多少？如果你一下就回答出来时多少个字节了，那基本上不必再问了，因为一个指针的大小取决于计算机的字长，所以应该分 32 位机还是 64 位机的情况。</p>
<p>字长还会决定一个极为重要的系统参数——<strong>虚拟地址空间</strong>。比如现在有一个 32 位机，每一位可以取值 1 或 总共 32 位，能组合的出局就有 2<sup>32</sup> 个，所以它能访问 2<sup>32</sup> 个地址，其大小也就是 4G，因此你如果给 32 位机装上 8G 的内存条，是起不了多大作用的。</p>
<p>我们平时所说的 32 位程序和 64 位程序并不是指机器的字长，它们的区别在于程序时如何编译的，而不是其运行的机器类型，高版本都应该做到向后兼容，所以 32 位程序一般都能运行在 64 位机器上，而 64 位程序时不能运行在 32 位机上面的。下面两种伪指令就分别用于编译 32 位程序和 64 位程序。</p>
<pre><code class="language-shell">gcc -m32 prog.c
gcc -m64 prog.c
</code></pre>
<p>C 语言在 32 位机和 64 位机上所表现的差别在于<code>long</code>数据类型，一般在 32 位机上是 4 个字节，而在 64 位机上是 8 个字节，而作为程序员要力图程序能在不同的机器上进行编译执行，要做到这一点就需要保证程序对不同数据类型的确切大小不敏感。</p>
<blockquote>
<p>曾经某运营商的一个基站版本因为数据范围的不同而造成了巨大的损失，在编程环境中使用的是 32 位机，而基站所使用的处理器没有 32 位，最后表现的效果就是大概每隔 40 天，基站就自动复位了。定位到这个问题都花费了巨大的财力和人力资源。</p>
</blockquote>
<h4 id="寻址及字节顺序">寻址及字节顺序</h4>
<p>上文已经提到，有很多的对象实际上不止占用一个字节，而是占用了多个字节，此时就涉及到如何排列这些字节了，以及如何存储这些字节。以<code>11001100 11001100</code>为例，它占用了两个字节，我们可以选择将这两个字节放在连续的内存中，也可以将两个字节分开放在不连续的内存中；另外我们可以将左边的字节当做起始位置，也可以将右边的字节当做起始位置（更专业的称为<strong>大端法和小端法</strong>）。</p>
<p>对于字节的排列，到底是用大端法还是小端法，没有技术上的争论，只有社会政治论题的争论，而且机器它对程序员是完全不可见的。几乎所有的机器都将多字节对象存储为连续的字节序列，所使用字节中最小的地址作为对象的地址。</p>
<p>那么什么时候需要注意字节的顺序规则呢，那就是编写网络应用程序的时候，试想你传输的数据是用大端法表示的，而用户的计算机采用的是小端法，那还会有用户使用你的产品吗。所以编写网络程序时需要遵循已经建立的关于字节顺序的规则。</p>
<h4 id="整数表示">整数表示</h4>
<p>程序员对二进制不会不知道，比如 <code>11111111</code>表示的是 255（不考虑补码），很容易就能转换为我们所熟悉的 10 进制数据。这种方式我们默认它是无符号数，如果要加入有符号数就开始变得有趣了。</p>
<p>几乎所有的计算机都是采用有<strong>补码</strong>来表示有符号整数的，它与无符号整数的区别在于最高位被解释为<strong>负权</strong>，举个例子：将<code>1111</code>看做补码的话，它的值就为：-2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -1。</p>
<p>在程序中不可避免的会使用强制类型转换，C 语言中强制类型转换并没有改变数据的位值，只是改变了解释这些位的方式。比如将无符号数（<code>unsigned</code>） 53191 转换为有符号数的结果为 -12345，它们的位值是完全没有相同的。</p>
<p>最容易入坑的地方是，对两个不同类型的数据进行运算时，C 语言将会隐式的将有符号数转换为无符号数，所以就有下面这样一个神奇的结果。</p>
<pre><code class="language-C">// u 代表无符号数
-1 &lt; 0u
// 结果为 0
// 因为 -1 的补码表示为：11...11
// 转换为无符号数后就是范围内最大的数
</code></pre>
<p>如果需要扩展一个数的位表示，那么放心的扩展就好了，小的数据类型都能安全的向大的数据类型转换，补码表示的数会在前面补上符号位，原码表示的直接在前面补上 0 即可，而需要注意的是从大往小转，这会不可避免的截断位，造成信息的丢失，所以千万不要这么干。</p>
<h4 id="加法-乘法运算">加法、乘法运算</h4>
<p>在编程入门的时候可能都知道两个正数相加的结果可能为负数，还有一个更奇怪的现象就是：<code>x &lt; y</code>和 <code>x - y &lt; 0</code>两个表达式可能会得出不一样的结果，这些神奇的结果都和计算机整数的底层表示和运算有着密切的关系。</p>
<p>C 语言中有无符号数与有符号数之分，而在 Java 中只有有符号数，下面的内容还是基于 C 语言进行说明，毕竟更 C 比 Java 更接近底层嘛。</p>
<h6 id="无符号加法">无符号加法</h6>
<p>假设我们使用 w 位来表示无符号数，那么两个加数取值范围即为：0 ≤ x, y ＜2<sup>w</sup>，理论上它们的和的范围为：0 ≤ sum ＜ 2<sup>w+1</sup>，因为只有 w 位表示无符号数（要把和表示出来就需要 w+1 位），所以超过 z<sup>w</sup>的部分就会造成溢出，如下图所示。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411732520.png" alt=""></figure>
<p>对于无符号数的溢出，计算机采用的处理方式是丢掉最高位，直观的结果就是，当发生溢出了，就将采用取模运算（或者说是减去 2<sup>w</sup>），举个例子。</p>
<p>只用 4 为来表示无符号数，即 w = 4，现在有 x [1001] 和 y [1100] 相加，其结果应为：[10101] ，但是没有 5 位用来表示，所以丢掉最高位的1，剩下的值为 5 [0101]，也就是 21 mod 16 = 5。</p>
<p>那么如何检测是否发生溢出呢？设求和结果为 s，对于加法有 x + y ≥ x 恒成立，即只要没有发生溢出，肯定有 s ≥ x。另一方面，如果确实发生溢出了，就有 s = x + y - 2<sup>w</sup>，又有 y - 2<sup>w</sup> ＜ 0，因此 s = x + y - 2<sup>w</sup> ＜ x。</p>
<h6 id="补码加法">补码加法</h6>
<p>和前面一样，对于两个给定范围的加数 - 2<sup>w-1</sup> ≤ x, y ≤ 2<sup>w-1</sup> - 1，它们的和的范围就在 - 2<sup>w</sup> ≤ sum ≤ 2<sup>w</sup> - 2。要想把整个和的范围表示出来，依旧需要 w+1 位才行，而现在只有 w 位，因此还是需要采用将溢出部分截断。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411746318.png" alt=""></figure>
<p>可以发现，当发生正溢出时，截断的结果是从和数中减去了 2<sup>w</sup>；而当发生负溢出时，截断结果是把和数加上 2<sup>w</sup>。</p>
<p>那么对于补码加法如何检测溢出结果呢？通过分析可以发现，当且仅当 x ＞ 0, y ＞ 0，但和 s ≤ 0 时为正溢出；当且仅当 x ＜ 0, y ＜ 0，但 s ≥ 0 时发生负溢出。</p>
<h6 id="无符号乘法">无符号乘法</h6>
<p>有了前面的基础，乘法就变得简单一些了，对于溢出情况，计算机仍然采用的是求模，比如 0 ≤ x, y ≤ 2<sup>w</sup> - 1，它们乘积的范围为 0 到 2<sup>2w</sup> - 2<sup>w+1</sup> + 1 之间，这可能需要 2w 位来表示，溢出部分直接截掉，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411758041.png" alt=""></figure>
<h6 id="补码乘法">补码乘法</h6>
<p>对于补码，两个乘数的范围为：- 2<sup>w-1</sup> ≤ x, y ≤ 2<sup>w-1</sup> + 1，那么其乘积表示范围就为 - 2<sup>2w-2</sup> + 2<sup>w-1</sup> 到 2<sup>2w-2</sup> 之间，补码乘法和无符号乘法基本是一样的，只是在无符号基础上多加了一步转换，即将无符号数转换为补码。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569411788683.png" alt=""></figure>
<h6 id="乘以常数">乘以常数</h6>
<p>我们知道，计算机做加减法、位级运算的速度最快（1 个指令周期），而做乘除法很慢（10 个甚至更多指令周期），平时编写的程序中常常会乘以一个常数，为了使程序运行的更快，编译器可能会帮我们做一些处理。</p>
<p>首先我们考虑常数是 2 的幂。x * 2<sup>1</sup> 可以表示为 <code>x &lt;&lt; 1</code>，x * 2<sup>2</sup> 可以表示为 <code>x &lt;&lt; 2</code>，依次类推即可。</p>
<p>对于不是 2 的幂的常数，比如 x * 14 可以表示为：<code>(x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)</code>，因为 14 = 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup>；聪明的你可能发现 14 还有另一种表示方法，即 14 = 2<sup>4</sup> - 2<sup>1</sup>，这种表示比前一种表示方法又少了运算量，所以 x * 14 还可以表示为：<code>(x&lt;&lt;4) - (x&lt;&lt;1)</code>。</p>
<p>实际上，这里有一个通用的解决方案，对于任何一个常数 K，其二进制可以表示为一组 0 和 1 交替的序列：[(0...0)(1...1)(0...0)(1...1)]，14可以表示为：[(0...0)(111)(0)]，考虑一组从位位置 n 到位位置 m 的连续的 1 （n ≥ m），（对于 14 有 n = 3，m = 1）可以有两种形式来计算位对乘积的影响。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569411804705.png" alt=""></figure>
<p>这个优化不是一定的，大多数编译器只在需要少量移位、加减法就足够的时候才使用这种优化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机系统漫游]]></title>
        <id>https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you</id>
        <link href="https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you">
        </link>
        <updated>2019-09-24T16:34:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="计算机中的信息">计算机中的信息</h4>
<p>对于程序员来说，HelloWorld 程序再熟悉不过了，下面是 C 语言写的 HelloWorld 程序。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main()
{
	printf(&quot;hello, world\n&quot;);
	return 0;
}
</code></pre>
<p>这段程序很简单，仅仅是在屏幕上输出<code>hello world</code>，对于程序员很容易阅读，但是从计算机的角度来看，也是这么简单吗？</p>
<p>我们都知道，计算机的世界只有 0 和 1组成的位（比特），这对于人类来说太不友好了，因此计算机科学家们设计了 ASCⅡ 码来表示现实世界的符号。每 8 个位构成一个组（称为一个字节），用一个组来表示一个符号，上面的 C 程序用 ASCⅡ 表示就是下面的样式。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569342929650.jpg" alt=""></figure>
<p>因此对于计算机来说，所有的数据都是由一串比特表示的，要区分这些数据对象的唯一方法就是读到它们时的<strong>上下文</strong>。</p>
<pre><code>信息 = 位 + 上下文
</code></pre>
<p>那么什么是上下文呢？举个例子来讲。在磁盘中有一段二进制数据<code>1010010111010010</code>，如果有一段程序将其当做整数读出来（不考虑补码），那么它的值就是 42450，如果把它当做浮点数读出来将是另一个结果，而JVM 将其当做字节码读出来的话，那又是完全不同的结果。只有把位放在具体的程序、环境中（即上下文）才会有意义，单个位是没有意义的。</p>
<h4 id="源程序编译">源程序编译</h4>
<p>虽然我们把 C 语言程序编写完成了，但是它并不能运行，因为它目前还仅仅是由 ASCⅡ 字符构成的文本文件，计算机并不能运行文本文件。</p>
<p>想要得到 HelloWorld 的可执行文件，需要经过预处理、编译、汇编、链接四个阶段。</p>
<p>预处理阶段，预处理器会根据以字符<code>#</code>开头的命令去修改源程序，预处理器去读取系统头文件<code>stdio.h</code>中的内容，并将其直接插入程序文本中，结果就得到了另一个 C 程序—— hello.i。</p>
<p>编译阶段，编译器会把 hello.i 程序翻译成汇编语言程序 hello.s，汇编语言本质上就是机器语言，此时的程序仍然是文本文件。</p>
<p>汇编阶段，汇编器会将 hello.s 翻译成机器语言指令，保存在 hello.o 文件中，此时得到的就是二进制文件了。</p>
<p>程序中使用了 printf 函数，这是由编译器提供的标准 C 库中的函数，它存储在 printf.o 文件中，链接器会将这个文件合并到 hello.o 中，结果就得到一个可执行的 hello 文件，存储于磁盘中。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569342980915.jpg" alt=""></figure>
<h4 id="系统组成及程序运行">系统组成及程序运行</h4>
<p>在运行可执行文件 hello 文件之前，应该先了解一下系统的硬件组成，一个典型系统的硬件组织如下图所示。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569343008278.jpg" alt=""></figure>
<p>为了运行 hello 程序，我们需要在 shell 中输入指令<code>./hello</code>，指令通过键盘经 I/O 总线 --&gt; I/O 桥 --&gt; 总线接口 --&gt; 寄存器 --&gt; I/O 桥存于主存中，当敲击回车键时，等于告诉 shell 程序，命令的属于已经结束， shell 将会执行一系列指令来加载 hello 文件。</p>
<p>利用**直接存取（DMA）**技术，hello 文件不需要通过寄存器就能到达主存，当目标文件 hello 到达主存中，处理器就开始执行 hello 程序的机器指令。其指令即将 &quot;hello, world\n&quot; 字符串的字节从主存复制到寄存器，再从寄存器复制到显示设备中，最终显示在屏幕上面。</p>
<p>我们发现这个简单的 HelloWorld 程序会让系统花费大量的时间把信息从一个地方挪到另一个地方，而我们都清楚，寄存器、主存、磁盘之间的访问速度是相互差了好几个数量级的，而这种复制的开销会严重减慢程序的运行，为了加快这些复制操作的速度，系统设计者就引入了<strong>高速缓存</strong>。</p>
<h4 id="抽象的重要性">抽象的重要性</h4>
<p>计算机科学中最为重要的概念之一就是<strong>抽象</strong>，指令集提供了对硬件处理器的抽象，操作系统同样通过进程、虚拟内存、文件（磁盘、键盘、网络都可以看成文件）这几个抽象概念为应用程序提供简单一致的机制来控制低级硬件设备，同时防止硬件被失控的应用程序滥用。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569343504770.jpg" alt=""></figure>
<p>进程是对正在运行的程序的抽象，在一个系统上可以同时运行多个进程，但是每个进程看起来都好像在独占的使用硬件，CPU 看上去是在并发的执行多个进程，这就需要操作系统进行上下文切换。</p>
<p>在我们还没有输入<code>./hello</code>之前，只有 shell 进程在运行，当我们让其运行 hello 程序时，shell 会通过系统调用来执行我们的请求。操作系统首先保存 shell 进程的上下文（PC、寄存器等信息），然后创建一个新的 hello 进程，并将控制权转交给 hello 进程。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569343051098.jpg" alt=""></figure>
<h4 id="并发和并行">并发和并行</h4>
<p><strong>并发</strong>是一个通用的概念，指同时具有多个活动的系统；<strong>并行</strong>是指用并发来使一个系统运行的更快，人类都是很懒的，不仅想要计算机能做的更多，还想它效率更高，这样的想法一致促进着技术的前进。</p>
<p>编程的人都知道，为了使程序运行的更快，我们可以编写多线程程序（虽然多线程程序有些难调），在一个进程里面执行多个控制流，线程级的并发可以让计算机运行的更快。</p>
<p>再向底层看看，在计算机体系结构的课堂上都会做<strong>流水线</strong>实验，通过将一条指令划分成不同的步骤，一条指令的执行时间能够从原来的 3~10 个时钟周期，缩短为接近于 1 个时钟周期，这是<strong>指令级的并行</strong>。条件判断和循环结构又会增加指令执行的时钟周期，如果能对这部分知识作深入了解，你编写的程序应该会高一个档次。</p>
<p>除了上面两种并行，还可以使用特殊的硬件，这种硬件可以允许一条指令产生多个可以并行执行的操作，称为<strong>单指令、多数据并行</strong>。</p>
]]></content>
    </entry>
</feed>