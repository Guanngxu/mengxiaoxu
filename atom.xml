<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2020-01-07T14:40:32.090Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[2019 年总结]]></title>
        <id>https://mengxiaoxu.github.io//post/2019-nian-zong-jie</id>
        <link href="https://mengxiaoxu.github.io//post/2019-nian-zong-jie">
        </link>
        <updated>2020-01-05T16:00:47.000Z</updated>
        <content type="html"><![CDATA[<p>写总结的习惯是从 2015 年开始的，我的大学学费是县政协资助的，叔叔阿姨们唯一的要求就是每年给他们写个总结汇报一下学习情况，毕业后敦促我写总结的人则从外力转为内心。</p>
<h4 id="一点感动">一点感动</h4>
<p>上半年我还很年轻，那时候还会经常使用 QQ、Soul、同桌、一罐 等等社交产品，无意结识了一个还在读高中的同性恋女孩子，我没学过心理学不知道用什么专业名词描述她的情况，反正就是心理上有严重的问题，玻璃心、想自杀等等。几次拼了我老命陪她聊到半夜两三点，现在完完全全能正视自己的情况了。</p>
<p>让我感动的是有次她问我在干啥，我随便拍了一张自己的被汗水打湿衣服发给她，告诉她自己正在打羽毛球。小姑娘给我说我穿的衣服不好看，说我才多大穿的衣服太老了，我也就随口一说叫她给我这个老年人推荐推荐衣服，因为她要上课后面就一直没有回我消息。</p>
<p>第二天早上睡醒了看到了小姑娘的几十条消息，是半夜两点多发的，给我挑了好几件衣服裤子，还给我画了几张示意图（如下），瞬间收获一份小感动。我也遵从小姑娘的意见买了两件上班穿穿，结果一到部门就是众目睽睽之下给我说穿的好酷，穿几次了都还是会引来大家不一样的目光，个性低调的我还是选择走大众程序员路线，老就老吧。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1578240118299.jpg" alt=""></figure>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1578240130505.jpg" alt=""></figure>
<p>前几天小姑娘给我发了她暗恋的小姐姐的照片，虽然极少时候还是会上课偷偷玩手机，但也在努力的备战高考。我做的不好的就是她多次给我讲自己在龙岗，我每次都把她当成龙华的，希望写了这篇总结之后不再记错吧。</p>
<h4 id="赚钱理财">赚钱理财</h4>
<p>这个小标题起的有点大，仅说说我自己的实际情况吧。凭着运气，2019 年的银行理财收益在 4.5% 左右，基金收益在 7% 左右。我没有去玩股票，网上各种理财课程可能都会给你讲股票的收益多么多么高，但是他们从来不会给你说玩股票的风险有多高，更不可能给你讲玩股票会严重影响自己的心情，可能连自己的本职工作都会搞砸，所以我不建议职场新人进入股市。</p>
<p>房东忙的时候我会帮他带房客看房，他也给了我小几千块钱的介绍费，加上每个月没交网费直接用他的，还时不时蹭蹭房东的饭局，也给自己省下来周末出去散步的费用了。上半年也给别人分享过两三个课程，在群里分享过一点小技能，大家给发了点红包，交个朋友、图个开心。</p>
<p>总的来讲，理财这方面做得很差，没有花什么时间去学习，我们的大学也没有教给学生一点金融知识，这一年只读了几本写给小白的理财书，今年在这个领域要多花一点功夫，希望能入得了门吧。</p>
<h4 id="写书失败">写书失败</h4>
<p>快要毕业的时候和电子工业出版社签了一份合同，合同内容就是我要写一本叫做《知识图谱：自顶向下方法》，这本书的计划内容是我的毕业设计，已经写了一百多页的内容了，但现在确定以失败告终。</p>
<p>一者我手里现有的数据属于机密数据，没办法拿来直接使用；二来书中有很大一部分内容涉及到网络爬虫，上半年网上曝了很多因为抓数据而入狱的案例，出版社和我都害怕；三者知识图谱所需要的数据量很大，而且我写的那个领域又是中国特有的经济责任审计领域，大量数据都得从政府网站来，更害怕了；最重要的原因是自己懒，写书的那几个月确实非常的累，想想自己都还是个菜鸟呐，有啥资本教给别人知识，心里给了自己后退的理由。</p>
<p>小时候曾夸下海口说要给父亲写个传记，也不知道有没有那么一丢丢可能性实现，写<a href="https://mp.weixin.qq.com/s/3dpKtLW44PXcPfWO8v4SiA">家里的狗</a>时，发现写这样的内容会增加我的多巴胺分泌，以后不开心了就写这样的小故事。</p>
<h4 id="运动健身">运动健身</h4>
<p>在深圳校友会骑行社师兄师姐们的带领下，同时也得益于一起入职的小伙伴送了我一辆 MERIDA，我喜欢上了骑行这项运动，基本上每周五都会出去骑几十公里，中间还参加了环漓江骑行和 TREK100 骑行，锻炼的同时也见到了美丽的风景。深圳对自行车是不太友好的，基本没有什么自行车道，所以我们大部分时间都是等到晚上车少，交警下班了之后才开始骑行。</p>
<p>除了骑行每周一也会打两小时羽毛球，谈不上专业，但至少打的不再是广场球了。偶尔也会出去爬爬山啥的，身体确实比上学时候要好很多，而且多锻炼能让自己的精神面貌更好，精气神好也能稍稍掩盖长得丑的缺点。以前每年再怎么也会因为感冒一类的问题进几次医院，19 年仅一次因为智齿发炎去过医院。</p>
<h4 id="削减迷茫">削减迷茫</h4>
<p>大概在四五月份的时候吧，几乎天天失眠，经常夜里只睡了三四个小时，有时甚至通宵未眠，心里很清楚是因为迷茫了，大概就是「晚上想了千条路，早上醒来走原路」的状态。好在自己的调节能力还不算差，同时也有楼下的叔叔、自己的好朋友能唠唠嗑，差不多两个月就回归正常状态了。</p>
<p>从几个比我晚入职半年的小伙伴那里了解到，他们现在的情况和我四五月份的情况差不多，我想绝大部分普通人都会经历这个迷茫期吧，大部分人也都能通过时间调节过来，调节不过来的那部分人就成为了媒体比较喜欢的人。</p>
<p>现在迷茫的雾气已经没有那么浓了，初入社会肯定有很多的不成熟，但谁不是这样过来的呢？更何况我并不像多数程序员那样交友严重同质化，周末也不会死宅在家里不出去，猜测我应该比大多数人更潇洒自在的，嘿嘿。</p>
<h4 id="新的思想">新的思想</h4>
<p>大家基本都是看着金庸武侠小说（相关影视作品）长大的，没有人写武侠小说能超过金庸。偶然一天在推特上刷到一条评论，大意是：没有人写武侠小说能超过金庸不正代表着社会的进步吗？金庸的成就如此巨大，一个很重要的历史背景是那时候大家没有那么多小说可看呀，哪里像今天遍地的网络小说。咱们没必要去争论这个观点的对错，重要的是它告诉了我们一个不一样的角度去看待问题。</p>
<p>上面只是一个特例，思维方式是一点一点改变的，认知水平是一点一点提升的，一年时间修正了不少我此前狭隘的观点，这样的修正还在继续，我也会让这样的修正持续下去。</p>
<h4 id="写在最后">写在最后</h4>
<p>巴黎圣母院被烧、凉山火灾、女排十连冠、NBA 事件、无锡高架桥倒塌......等等发生在 2019 年的大事，不知道还有多少朋友会记起来。时间从来不会等谁，网友也都是不长记性的，成熟的一部分无非是经历的多了，失望的多了，然后变得更耐操一点，总之生活依旧得继续，人总会亦悲亦喜，那为啥不把悲缩小喜放大呢？</p>
<p>成功没有银弹、没有捷径，<a href="https://mp.weixin.qq.com/s/j1MtPn_2YwPhiLCJHZ4GYQ">少讲大道理，多解决小问题</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB 聚合入门]]></title>
        <id>https://mengxiaoxu.github.io//post/mongodb-ju-he-ru-men</id>
        <link href="https://mengxiaoxu.github.io//post/mongodb-ju-he-ru-men">
        </link>
        <updated>2020-01-04T11:16:29.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.mongodb.com/manual/core/aggregation-pipeline">MongoDB 聚合官方文档</a></p>
<p>聚合管道是一个基于数据处理管道概念建模的数据聚合框架，文档进入一个多阶段的处理管道，该管道最终将其转换为聚合后的结果。</p>
<p>下面的例子来源于官方文档。第一阶段，<code>$match</code>按<code>status</code>字段来过滤文档，并把<code>status</code>字段值为<code>A</code>的文档传递到下一阶段；第二阶段，<code>$group</code>将文档按<code>cust_id</code>进行分组，并针对每一组数据对<code>amount</code>进行求和。</p>
<pre><code class="language-js">db.orders.aggregate([
   { $match: { status: &quot;A&quot; } },
   { $group: { _id: &quot;$cust_id&quot;, total: { $sum: &quot;$amount&quot; } } }
])
</code></pre>
<h3 id="管道">管道</h3>
<figure data-type="image" tabindex="1"><img src="https://uploader.shimo.im/f/3DCQfjzI6LQQvbtQ.png" alt=""></figure>
<p>聚合管道包含很多步骤，每一步都会将输入的文档进行转换，但并不是每个阶段都一定需要对每个输入文档生成一个输出文档，比如某些阶段可能生成新的文档或者过滤掉文档。</p>
<p>除了<code>$out</code>、<code>$merge</code>、<code>$geoNear</code>外，其它的阶段都可以在管道中多次出现，更加详细的内容可以查看 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-operator-reference">Aggregation Pipeline Stages</a>。</p>
<figure data-type="image" tabindex="2"><img src="https://uploader.shimo.im/f/kbeipyqZVvUtruaT.jpeg" alt=""></figure>
<h3 id="管道表达式">管道表达式</h3>
<p>一些管道阶段采用表达式作为操作元，管道表达式指定了要应用到输入文档的转换，表达式自己是一个文档结构（JSON），表达式也可以包含其它的表达式。</p>
<p>表达式仅提供文档在内存中的转换，即管道表达式只能对管道中的当前文档进行操作，不能引用来自其他文档的数据。</p>
<p>写聚合表达式式建议直接参考<a href="https://docs.mongodb.com/manual/core/aggregation-pipeline">官方文档</a>，下面列出一些我收集的案例，供深入理解使用。</p>
<h3 id="案例一将对象数组转换为单个文档">案例一：将对象数组转换为单个文档</h3>
<pre><code class="language-json">// 转换前
{
    &quot;_id&quot;: &quot;10217941&quot;,
    &quot;data&quot;: [
        {
            &quot;count&quot;: 2,
            &quot;score&quot;: &quot;0.5&quot;
        },
        {
            &quot;count&quot;: 6,
            &quot;score&quot;: &quot;0.3&quot;
        },
        {
            &quot;count&quot;: 5,
            &quot;score&quot;: &quot;0.8&quot;
        }
    ]
}

// 转换后
{
    &quot;_id&quot;: &quot;10217941&quot;,
    &quot;0.3&quot;: 6,
    &quot;0.5&quot;: 2,
    &quot;0.8&quot;: 5
}
</code></pre>
<p>需要说明的是，如果上面<code>data</code>属性中的数据格式为<code>{&quot;k&quot;: &quot;0.6&quot;, &quot;v&quot;: 5}</code>，那么下面的聚合表达式就不需要<code>$map</code>，这一点可以查看 <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/arrayToObject">$arrayToObject</a>。这个案例的难点在于<code>score</code>中有小数点，这个小数点会让聚合表达式懵逼的。</p>
<pre><code class="language-js">db.collection.aggregate([
    {
        &quot;$addFields&quot;: {
            &quot;data&quot;: {
                &quot;$arrayToObject&quot;: {
                    &quot;$map&quot;: {
                        &quot;input&quot;: &quot;$data&quot;,
                        &quot;as&quot;: &quot;item&quot;,
                        &quot;in&quot;: {
                            &quot;k&quot;: &quot;$$item.score&quot;,
                            &quot;v&quot;: &quot;$$item.count&quot;
                        }
                    }
                }
            }
        }
    },
    {
        &quot;$addFields&quot;: {
            &quot;data._id&quot;: &quot;$_id&quot;
        }
    },
    {
        &quot;$replaceRoot&quot;: {
            &quot;newRoot&quot;: &quot;$data&quot;
        }
    }
]);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户关注而程序员不关注的事]]></title>
        <id>https://mengxiaoxu.github.io//post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi</id>
        <link href="https://mengxiaoxu.github.io//post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">
        </link>
        <updated>2019-12-15T13:04:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="https://instadeq.com/blog/posts/things-end-users-care-about-but-programmers-dont/">Things end users care about but programmers don't</a></p>
</blockquote>
<h3 id="色彩">色彩</h3>
<ul>
<li>改变元素的颜色</li>
<li>漂亮的默认调色板</li>
<li>使用我喜欢的调色板</li>
<li>导入/导出颜色主题</li>
<li>一些标识符、关键字等应该始终具有特定的颜色</li>
<li>同一事物在任何地方都应颜色一致</li>
<li>具有适宜的对比度</li>
<li>切换深色/浅色背景时，自动调整对比度以适应当前背景</li>
<li>自动生成大量颜色
<ul>
<li>所有的颜色都属于同一个系列</li>
<li>不生成不易辨别的颜色</li>
<li>相似的颜色不要放在一起</li>
<li>不要将背景色用在元素上</li>
</ul>
</li>
</ul>
<h3 id="格式">格式</h3>
<ul>
<li>将基本格式应用于文本</li>
<li>文本对齐</li>
<li>使用我在 office 中使用的字体</li>
<li>类似于 Word 中的 WYSIWYG 编辑器</li>
<li>数字对齐</li>
<li>数字/日期自动根据语言环境设置格式</li>
<li>小数设置为右边有固定小数位</li>
<li>在任何地方都没有奇怪的 .0000004 格式</li>
<li>整数后面不应该有 .00</li>
<li>支持 Emoji</li>
</ul>
<h3 id="主题">主题</h3>
<ul>
<li>深色主题</li>
<li>我的主题</li>
<li>公司品牌</li>
<li>将 logo 放在合适的位置</li>
<li>在登录页面有 logo</li>
</ul>
<h3 id="系统整合">系统整合</h3>
<ul>
<li>与账户系统整合</li>
<li>使用 Active Directory 中的账户/权限</li>
<li>导入 Excel/CSV</li>
<li>从电子邮件附件导入</li>
<li>导出为 Excel</li>
<li>导出为 PDF/图像</li>
<li>录制短片
<ul>
<li>制作 gif</li>
</ul>
</li>
<li>作为邮件发送
<ul>
<li>定期发送邮件</li>
<li>以 PDF 附件形式发送邮件</li>
</ul>
</li>
<li>导入/附加图像
<ul>
<li>上传前裁剪</li>
<li>压缩</li>
<li>变更格式</li>
</ul>
</li>
<li>使用图像作为背景，并且以正确的方式拉伸</li>
<li>APP 上的通知
<ul>
<li>在手机的应用程序上</li>
<li>通过短信</li>
<li>在我们的系统上</li>
<li>在我的邮箱</li>
</ul>
</li>
</ul>
<h3 id="用户体验">用户体验</h3>
<ul>
<li>良好的错误处理</li>
<li>简洁的错误描述
<ul>
<li>翻译错误信息</li>
</ul>
</li>
<li>告诉我如何做才能解决错误</li>
<li>在我点击前告诉我会发生什么</li>
<li>支持手势和鼠标</li>
<li>快捷键
<ul>
<li>支持自定义</li>
</ul>
</li>
<li>任何时间都可以撤销</li>
<li>支持多次撤销</li>
<li>恢复已被删除的东西</li>
<li>在删除前给提示</li>
<li>复制与粘贴</li>
<li>模板</li>
<li>详细的用户指南，并且每一步都有截图与重点标注
<ul>
<li>在视频中</li>
<li>截图随着产品的发布保持更新</li>
<li>与我正在使用的版本同步</li>
<li>适应我的自定义设置</li>
</ul>
</li>
<li>最新的详细文档</li>
<li>自动翻译为我的语言（国际化）</li>
<li>任何地方都支持排序
<ul>
<li>自然排序</li>
<li>根据多个条件排序</li>
</ul>
</li>
<li>任何地方都支持过滤器
<ul>
<li>模糊匹配</li>
<li>大小写敏感/不敏感过滤</li>
<li>按多个复杂条件筛选</li>
</ul>
</li>
<li>记录历史操作，在我删除时给出警告</li>
<li>可选的级联删除</li>
<li>在每个平台本机都提供简单的日期选择器</li>
<li>对列表/已经项排序（按标签）
<ul>
<li>自然排序</li>
</ul>
</li>
<li>带有过滤功能的下拉菜单</li>
<li>预览</li>
<li>一致的按钮排序/标签</li>
<li>一致的大小写</li>
<li>慢速操作显示进度条</li>
<li>缓慢操作时 UI 可以快速响应</li>
<li>响应缓慢时禁用按钮</li>
<li>处理应单击元素的双击事件</li>
<li>明确指示可以单击的内容</li>
</ul>
<h3 id="兼容性">兼容性</h3>
<ul>
<li>可在其它系统部署</li>
<li>可在旧的/不支持的版本上部署</li>
<li>在我拥有的任何系统上都可部署</li>
<li>不需要网络就可部署</li>
<li>处理 Excel, CSV, JSON, XML
<ul>
<li>处理以上所有格式不正确的版本</li>
</ul>
</li>
<li>处理（猜测）没有时区的日期</li>
<li>处理模糊的/被更改的日期格式</li>
<li>可与过时的软件混合</li>
<li>可以在旧安卓的浏览器工作</li>
<li>编码
<ul>
<li>处理具有未知和可变编码的输入</li>
</ul>
</li>
</ul>
<h3 id="操作">操作</h3>
<ul>
<li>易安装</li>
<li>易更新</li>
<li>易备份</li>
<li>易恢复</li>
<li>可与我们所使用的的数据库版本一起工作</li>
<li>可以挂载在非根路径</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-12-15）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi">
        </link>
        <updated>2019-11-18T14:14:27.000Z</updated>
        <content type="html"><![CDATA[<p>利用周末时间到成都走了走，见到了四五年没见的三个高中同桌，心中甚是欢喜。在去往成都的途中，与我挨着的乘客是一个彝族同胞，她在东莞的一个纺织厂做衣服，这次请了两个月的假，回家与家人团聚过年。彝族的「年」叫做「库斯」，现在定在每年的 11 月 20 日，出于对不了解文化的好奇，我加了小姑娘的微信，天天都能看到他们的村民盛装举办各种活动，让我明年此时到凉山州走一走的想法愈发强烈。</p>
<p>四五年的时间让我和同学产生了很大的差异，他们做菜都超级棒，而我做的菜可能也只有自己才能忍着吃下去，找到了两点原因。一者成都的房子大部分都很适合做饭，空间很大，给了足够大的舞台让你展现厨艺，同等配置的房子在深圳需要成都两到三倍的租金；二者成都加班时间远比深圳少的多，同学说他有时候会加班到七点，而深圳大部分公司七点应该算正常下班时间，因此在成都的超市我看到了很多年轻人在买菜也就不足为奇了。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1574088668252.gif" alt=""></figure>
<p>前两天在微信朋友圈看到一篇<a href="https://mp.weixin.qq.com/s/0L8llYRQMklp-L9qcpHj9g">《香港问题和世界真相》</a>，以前也看到过类似标题的一些文章，那时候还会花些时间去读一读，最近愈发觉得微信公众号咋这么多人才呢？不管多么深奥的问题都能在公众号上找到答案，还引经据典讲的神乎其神，一篇公众号文章就能把科学家解决不了的问题全给解决了，实乃圣人也，我更愿意做一个俗人！</p>
<p>微信公众号可能是国内在保护原创这块做的最好的平台，但是其缺点也并不少。现在能看到很多作者变成了公众号平台的写作苦力，在微信公众号的机制下，你需要一直更新才能积累人气，很少有人持续输出高质量的内容，那些还没毕业或是刚毕业几年的小孩子更加不可能做到。</p>
<p>公众号是一个封闭的平台，搜索引擎无法检索到公众号的文章，这一点和互联网开放共享的思想是相违背的。公众平台提供的改几个错别字功能，远远不够纠正文章中引入的错误。以前我把公众号当个记事本，但是有一次因为说了不该说的话，直接给我封号了，连自己的历史文章都看不了，好在最后给解封了，赶紧把文章都备份下来。</p>
<p>去年十月份有个那么一周很多公众号都在推荐一个写作课，是几个 90 后开的写作课，其中一个的微信昵称是「九爷」，课程内容大致就是自媒体写作赚钱；而最近我微信朋友圈莫名出现了一个昵称为「宝藏女孩买买提」的人天天发京东各种商品的抢购链接，点进去看才发现这就是去年的那个「九爷」，心想这女生变得也太快了吧，何况我还不能百分百确定是女生，还是赶紧删掉好！</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1574088668252.gif" alt=""></figure>
<p>上面两个片段已经写完一个多月了，这一个多月没有找到什么片段可以凑到这里来，那就水一把说自己经历的一个小事吧。学长是做体育赛事直播的，他们公司举办了一个 2-4 岁儿童的骑跑比赛，我被学长抓壮丁去帮他在现场奖品和完赛纪念品，有一个家长给我的印象非常深刻。</p>
<p>一位妈妈在我这里领完纪念品后，一下扔到地上气冲冲的走了，孩子的表情我形容不出来，自己去把纪念品捡起来，但也没有去追妈妈。我本以为是我们哪里做的不对致使她那么大火气，结果一了解才知道是因为孩子比赛成绩太差了，自己家孩子赶不上别家孩子给气的。</p>
<p>上面那件事情不作评论，毕竟这一个片段是用来凑字数的，那就得有凑字数的样子。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 中的零拷贝技术]]></title>
        <id>https://mengxiaoxu.github.io//post/linux-zhong-de-ling-kao-bei-ji-zhu</id>
        <link href="https://mengxiaoxu.github.io//post/linux-zhong-de-ling-kao-bei-ji-zhu">
        </link>
        <updated>2019-11-18T13:43:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="https://lwn.net/Articles/178199/">Two new system calls: splice() and sync_file_range()</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/index.html">Linux 中的零拷贝技术1</a><br>
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/index.html">Linux 中的零拷贝技术2</a><br>
<a href="https://www.linuxjournal.com/article/6345">Zero Copy I: User-Mode Perspective</a><br>
<a href="http://man7.org/linux/man-pages/man2/splice.2.html">Linux man-pages splice()</a></p>
</blockquote>
<p>此前在<a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua/">Nginx 文件操作优化</a>中有提到零拷贝技术，它可以有效的改善数据传输的性能，但是由于存储体系结构非常复杂，而且网络协议栈有时需要对数据进行必要的处理，所以零拷贝技术有可能会产生很多负面影响，甚至会导致零拷贝技术自身的优点完全丧失。</p>
<p>零拷贝就是一种避免 CPU 将一块存储拷贝到另一块存储的技术。它可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率，而且零拷贝技术也减少了内核态与用户态之间切换所带来的开销。进行大量的数据拷贝操作是一件简单的任务，从操作系统的角度来看，如果 CPU 一直被占用着去执行这项简单的任务，是极其浪费资源的。如果是高速网络环境下，很可能就出现这样的场景。</p>
<h3 id="零拷贝技术分类">零拷贝技术分类</h3>
<p>现在的零拷贝技术种类很多，也并没有一个适合于所有场景的零拷贝零拷贝技术，概括起来总共有下面几种：</p>
<ul>
<li>
<p><strong>直接 I/O</strong>：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统只是辅助数据传输，这类零拷贝技术可以让数据在应用程序空间和磁盘之间直接传输，不需要操作系统提供的页缓存支持。关于直接 I/O 可以参看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html">Linux 中直接 I/O 机制的介绍</a>。</p>
</li>
<li>
<p><strong>避免数据在内核态与用户态之间传输</strong>：在一些场景中，应用程序在数据进行传输的过程中不需要对数据进行访问，那么将数据从页缓存拷贝到用户进程的缓冲区是完全没有必要的，Linux 中提供的类似系统调用主要有<code>mmap()</code>、<code>sendfile()</code>和<code>splice()</code>。</p>
</li>
<li>
<p><strong>对数据在页缓存和用户进程之间的传输进行优化</strong>：这类零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统页缓存之间的拷贝操作，此类方法延续了传统的通信方式，但是更加灵活。在 Linux 中主要利用了「写时复制」技术。</p>
</li>
</ul>
<p>前两类方法的目的主要是为了避免在用户态和内核态的缓冲区间拷贝数据，第三类方法则是对数据传输本身进行优化。我们知道硬件和软件之间可以通过 DMA 来解放 CPU，但是在用户空间和内核空间并没有这种工具，所以此类方法主要是改善数据在用户地址空间和操作系统内核地址空间之间传递的效率。</p>
<h3 id="避免在内核与用户空间拷贝">避免在内核与用户空间拷贝</h3>
<p>Linux 主要提供了<code>mmap()</code>、<code>sendfile()</code>、<code>splice()</code>三个系统调用来避免数据在内核空间与用户空间进行不必要的拷贝，在<a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua/">Nginx 文件操作优化</a>对<code>sendfile()</code>已经做了比较详细的介绍了，这里就不再赘述了，下面主要介绍<code>mmap()</code>和<code>splice()</code>。</p>
<h4 id="mmap">mmap()</h4>
<p>当调用<code>mmap()</code>之后，数据会先通过 DMA 拷贝到操作系统的缓冲区，然后应用程序和操作系统共享这个缓冲区，这样用户空间与内核空间就不需要任何数据拷贝了，当大量数据需要传输的时候，这样做就会有一个比较好的效率。</p>
<p>但是这种改进是需要代价的，当对文件进行了内存映射，然后调用<code>write()</code>系统调用，如果此时其它进程截断了这个文件，那么<code>write()</code>系统调用将会被总线错误信号<code>SIGBUG</code>中断，因为此时正在存储的是一个错误的存储访问，这个信号将会导致进程被杀死。</p>
<p>一般可以通过文件租借锁来解决这个问题，我们可以通过内核给文件加读或者写的租借锁，当另外一个进程尝试对用户正在进行传输的文件进行截断时，内核会给用户发一个实时<code>RT_SIGNAL_LEASE</code>信号，这个信号会告诉用户内核破坏了用户加在那个文件上的写或者读租借锁，<code>write()</code>系统调用就会被中断，并且进程会被<code>SIGBUS</code>信号杀死。需要注意的是文件租借锁需要在对文件进行内存映射之前设置。</p>
<h4 id="splice">splice()</h4>
<p>和<code>sendfile()</code>类似，<code>splice()</code>也需要两个已经打开的文件描述符，并且其中的一个描述符必须是表示管道设备的描述符，它可以在操作系统地址空间中整块地移动数据，从而减少大多数数据拷贝操作。适用于可以确定数据传输路径的用户应用程序，不需要利用用户地址空间的缓冲区进行显示的数据传输操作。</p>
<p><code>splice()</code>不局限于<code>sendfile()</code>的功能，也就是说<code>sendfile()</code>是<code>splice()</code>的一个子集，在 Linux 2.6.23 中，<code>sendfile()</code>这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过内部已经使用了<code>splice()</code>这种机制来实现了。</p>
<h3 id="写时复制">写时复制</h3>
<p>在某些情况下，Linux 操作系统内核中的页缓存可能会被多个应用程序所共享，操作系统有可能会将用户应用程序地址空间缓冲区中的页面映射到操作系统内核地址空间中去。如果某个应用程序想要对这共享的数据调用<code>write()</code>系统调用，那么它就可能破坏内核缓冲区中的共享数据，传统的<code>write()</code>系统调用并没有提供任何显示的加锁操作，Linux 中引入了写时复制这样一种技术用来保护数据。</p>
<p>写时复制的基本思想是如果有多个应用程序需要同时访问同一块数据，那么可以为这些应用程序分配指向这块数据的指针，在每一个应用程序看来，它们都拥有这块数据的一份数据拷贝，当其中一个应用程序需要对自己的这份数据拷贝进行修改的时候，就需要将数据真正地拷贝到该应用程序的地址空间中去，也就是说，该应用程序拥有了一份真正的私有数据拷贝，这样做是为了避免该应用程序对这块数据做的更改被其他应用程序看到。这个过程对于应用程序来说是透明的，如果应用程序永远不会对所访问的这块数据进行任何更改，那么就永远不需要将数据拷贝到应用程序自己的地址空间中去。这也是写时复制的最主要的优点。</p>
<p>写时复制的实现需要 MMU 的支持，MMU 需要知晓进程地址空间中哪些特殊的页面是只读的，当需要往这些页面中写数据的时候，MMU 就会发出一个异常给操作系统内核，操作系统内核就会分配新的物理存储空间，即将被写入数据的页面需要与新的物理存储位置相对应。它最大好处就是可以节约内存，不过对于操作系统内核来说，写时复制增加了其处理过程的复杂性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vim 常用命令快速查询]]></title>
        <id>https://mengxiaoxu.github.io//post/vim-chang-yong-ming-ling-kuai-su-cha-xun</id>
        <link href="https://mengxiaoxu.github.io//post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
        </link>
        <updated>2019-10-31T16:02:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容<br>
<a href="http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html">Learning Vim The Pragmatic Way</a><br>
《鸟哥的 Linux 私房菜》</p>
</blockquote>
<p>Vim 可以认为是 Vi 的高级版本，Vim 可以用颜色或下划线的方式来显示一些特殊信息，您可以认为 Vi 是一个文本处理工具，而 Vim 是一个程序开发工具，现在大部分 Linux 的发行版都以 Vim 替换 Vi 了。在 Linux 命令行模式下有很多编辑器，但是 Vi 文本编辑器是所有 Unix-like 系统都会内置的，因此学会 Vi/Vim 的使用时非常有必要的，对于 Vi 的三种模式（命令模式、编辑模式、命令行模式）这里就不在做说明了，下面是一些比较常用的命令。</p>
<h3 id="一般命令模式下">一般命令模式下</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h、j、k、l</td>
<td>与键盘的方向键一一对应，分别为左、下、上、右，在键盘上着几个字母是排在一起的</td>
</tr>
<tr>
<td>Ctrl+f、Ctrl+b</td>
<td>分别对应键盘的「Page Down」、「Page Up」，我更习惯于这两个键，而不是前面的组合键</td>
</tr>
<tr>
<td>0、$</td>
<td>分别对应键盘的「Home」、「End」，即移动到该行的最前面/后面字符处</td>
</tr>
<tr>
<td>n&lt;Enter&gt;</td>
<td>n 为数字，光标向下移动 n 行</td>
</tr>
<tr>
<td>/word、?word</td>
<td>向光标之上/下寻找一个字符串名称为 word 的字符串</td>
</tr>
<tr>
<td>n、N</td>
<td>如果我们刚刚执行了上面上面的 /word 或 ?word 查找操作，那么 n 则表示重复前一个查找操作，可以简单理解为向下继续查找下一个名称为 word 的字符串，N 则与 n 刚好相反</td>
</tr>
<tr>
<td>:n1,n2s/word1/word2/g</td>
<td>在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将这个字符串替换为 word2，如果前面的 n1,n2 使用 1,$ 代替则表示从第一行到最后一行，最后的 g 后面可以加个 c，即 :1,$s/word1/word2/gc，这样就会在替换钱显示提示字符给用户确认（confirm）</td>
</tr>
<tr>
<td>x、X</td>
<td>分别对应键盘的「Del」、「Backspace」键</td>
</tr>
<tr>
<td>dd、yy</td>
<td>删除/复制光标所在的那一整行</td>
</tr>
<tr>
<td>p、P</td>
<td>p 将已复制的数据在光标下一行粘贴，P 粘贴在光标上一行</td>
</tr>
<tr>
<td>u</td>
<td>恢复前一个操作，类似于 Windows 下的 Ctrl+Z</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做上一个操作</td>
</tr>
<tr>
<td>.</td>
<td>小数点，重复上一个操作</td>
</tr>
</tbody>
</table>
<h3 id="命令行模式下">命令行模式下</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>将编辑的数据写入硬盘中</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为只读，强制写入该文件，不过到底能不能写入，还是跟文件权限有关系</td>
</tr>
<tr>
<td>:q、:q!</td>
<td>与 w 一样，q 为关闭的意思</td>
</tr>
<tr>
<td>:r [filename]</td>
<td>在编辑的数据中读入另一个文件的数据，即将[filename]这个文件的内容追加到光标所在行的后面</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据保存为另一个文件</td>
</tr>
<tr>
<td>:set nu/nonu</td>
<td>显示/不显示行号</td>
</tr>
</tbody>
</table>
<h3 id="编辑模式下">编辑模式下</h3>
<table>
<thead>
<tr>
<th>组合键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+n</td>
<td>通过目前正在编辑的这个文件的内容文字作为关键字，予以自动补全</td>
</tr>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+f</td>
<td>以当前目录内的文件名作为关键字补全</td>
</tr>
<tr>
<td>[ctrl]+x -&gt; [ctrl]+o</td>
<td>以扩展名作为语法补充，以 Vim 内置的关键字予以补全</td>
</tr>
</tbody>
</table>
<p>当我们在使用 Vim 编辑器的时候，Vim 会在与被编辑的文件目录下再建立一个名为<code>.filename.swp</code>的文件，我们对文件的操作都会记录到这个 swp 文件中去，如果系统因为某些原因掉线了，就可以利用这个 swp 文件来恢复内容。如果存在对应的 swp 文件，那么 Vim 就会主动判断当前这个文件可能有问题，会给出相应的提示。</p>
<p>我们也可以给 Vim 环境设置一些个性化的参数，虽然在命令行模式下可以使用<code>:set</code>来设置，但是这样每次设置实在是太麻烦，因此我们可以设置一些全局的参数。Vim 的整体设置值一般放在<code>/etc/vimrc</code>中，我们一般通过修改<code>~/.vimrc</code>这个文件（默认不存在）来设置一些自己的参数，比如：</p>
<pre><code class="language-vim">&quot; 该文件的双引号是注释
set nu &quot;在每一行的最前面显示行号
set autoindent &quot; 自动缩进
set ruler &quot; 可显示最后一行的状态
set bg=dark &quot; 显示不同的底色色调
syntax on &quot;进行语法检验，颜色显示，比如 C 语言等
</code></pre>
<p>最后附上一张命令速查卡，此图来源于<a href="http://jrmiii.com/">Learning Vim The Pragmatic Way</a>，PDF 版下载链接在<a href="http://jrmiii.com/attachments/Vim.pdf">这里</a>。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1572670913809.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-10-28）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
        </link>
        <updated>2019-10-27T17:13:22.000Z</updated>
        <content type="html"><![CDATA[<p>分享一个视频：<a href="https://twitter.com/williamwoo7/status/1186498521408647168">施利伦法，利用折射率的不同使肉眼不可见的物质可视化</a>，我把它下下来了，如下：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/bDK1UfMQfqs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>在一位做酱香酒的朋友那里学了个鉴别真伪飞天茅台的方法，我不会喝酒所以没什么研究，实用性还请读者大人自行判断，反正我喝茅台的感觉与喝二锅头差不多，到嘴里都是一个味。</p>
<p>方法一：如果「酒」字里面的那一横，是图一的那个样子，那是真酒；而如果是图二的样子则是假酒。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1572196530821.png" alt=""></figure>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1572196539935.png" alt=""></figure>
<p>方法二：在如图左边仙女标红圈那个位置，如果线条的交汇点是穿出去的，则为真，反之为假。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1572196549838.jpg" alt=""></figure>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1572196558785.png" alt=""></figure>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>看了<a href="https://www.bilibili.com/video/av73524393?from=search&amp;seid=12678980801438574288">2019·菠萝科学奖颁奖典礼</a>，一个沙雕、严谨、有趣......的节目，处处都透漏着尴尬又不失礼貌的微笑，永远向好奇心致敬。我个人认为这个节目最大的优点就是把常人眼里那种无趣、严谨的科学以一种有趣的方式呈现出来，这可以让大多数人更喜欢科学，让科学家在科研的道路上坚持的更久。</p>
<p>在<a href="https://mp.weixin.qq.com/s/-aHGec_9wiIYsT0F4z4LMg">怎样才能开开心心的呢</a>中有提到过降低对事物的期望值，这里再详细谈一下降低期望值对学习的促进作用。以这两年大量冒出来的线上英语阅读打卡为例，只要打卡多少天就有小礼物，全勤甚至可以返还学费，这么一想那公司还怎么赚钱呢？原因就在于绝大部分人都只能坚持短短的几天，和健身卡的套路基本一致。</p>
<p>我想读者大人肯定都知道复利曲线，其实并不需要给自己定多么多么高远的目标，只需要每天坚持花一点时间一直去做，就能达到复利曲线的效果。之所以坚持不下去无非是因为学习很痛苦，而如果把学习变成像玩游戏一样有趣，那你肯定不会拒绝学习。比如上面说的英语学习，每天去背单词没几个人坚持的下来，那如果是每天看一集美剧呢？</p>
<p>人是需要被成就感驱动的，给自己一下定的目标太高很容易就气馁了，降低自己的期望值，把目标定小一点点，说不定每天都可以获得满满的成就感，配上一些有趣的方式、方法，学习这件事做起来简直妙不可言，其它事情也是一样的道理。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>最近取关了很多公众号，互联网时代不得不承认网上的好文不少，但是大部分人都没有那么多精力去读完，与其走马观花的读一遍，我更愿意精读一篇文章后再从中挖掘信息。之前一直不肯取关一些公众号，总是觉得某天会有个重要信息从那里得到，<a href="http://mindhacks.cn/">刘未鹏</a>老师说这是源于人「不肯关上一扇门」的心理，而实际关上一扇门可能增大我们的收益，注意力不至于被滑不到底的信息流骚扰。读过了却不一定领悟了，愈发赞同人与人学习的差距不在资质上，而在于花在思考上的时间与思考的深度。</p>
<p>同样为了不让太多事物让自己分心，我周末也花了些时间把很久没用的东西，很久没有穿的衣物等等都扔了，屋子一下显得宽敞了许多，忘记此前在哪里看到一篇文章有讲太多的家具会让自己分心，不过当时是找了一圈没舍得扔，因为每一件物品我好像总能想到它在某个场景下的作用，而现实情况是那些场景可能是我幻想出来的，或者当那个场景出现的时候，对应的物品也因为放的太久而无法使用了，还不如扔了算了。</p>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1572196424138.gif" alt=""></figure>
<p>下面是一些比较有意思的文章。</p>
<p><a href="https://tylervigen.com/spurious-correlations">tylervigen.com</a> 专门收集那些看起来高度相关但实际上毫不相关的数据，比如美国在科学、太空、技术方面的投入，与采用上吊、勒死、窒息方式自杀的案例，这两组数据之间的相关性高达 99.79% 。</p>
<p><a href="https://bruno-simon.com/">https://bruno-simon.com</a> 是一个超酷的网站主页，网站的源码在 <a href="https://github.com/brunosimon/folio-2019">Github</a>。页面用到了 3D 导航，你可以像玩游戏一样在里面探索，也可以把这个网页当成一个减压神器。</p>
<p><a href="https://daquan.tv/collections/funny/this-will-make-you-look-at-history-very-differently?stid=0&amp;utm_campaign=tw_daquan_look_history_us_dt_yo&amp;utm_medium=9949&amp;utm_source=1005&amp;utm_content=tw_daquan_look_history_us_dt_yo_i4">一些可能会颠覆你对世界的认识的照片</a> 文章里面列举了大量可能颠覆你认知的照片，比如世界上第一张自拍花了 30 秒，即保持一个姿势 30 秒不动。</p>
<p>Youtube 上最近有个视频火了：美国加州某地的微波传输站失灵了，技术人员在微波天线罩里面发现了 300磅（136公斤）的橡子，大家都认为是松鼠干的，根据美国「国家地理」的文章 <a href="https://www.nationalgeographic.com/news/2015/11/151113-antenna-cache-acorn-woodpecker-california/">Meet the Bird that Filled an Antenna With Acorns</a> 介绍，在微波天线罩里藏橡子的很可能不是松鼠，而是橡子啄木鸟。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 文件操作优化]]></title>
        <id>https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua</id>
        <link href="https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua">
        </link>
        <updated>2019-10-19T11:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="http://www.178linux.com/54790">Nginx AIO 机制与 sendfile 机制</a><br>
<a href="https://segmentfault.com/q/1010000003055006/a-1020000003064578">sendfile 适用场景</a><br>
<a href="http://xiaorui.cc/2015/06/24/%E6%89%AF%E6%B7%A1nginx%E7%9A%84sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5/">扯淡 Nginx 的 sendfile 零拷贝的概念</a><br>
<a href="https://www.jianshu.com/p/fad3339e3448">浅析 Linux 中的零拷贝技术</a><br>
<a href="http://man7.org/linux/man-pages/man2/sendfile.2.html">Linux man-pages sendfile</a></p>
</blockquote>
<p>今天在看 Nginx 配置的时候，看到了一个<code>sendfile</code>配置项，它可以配置在<code>http、server、location</code>三个块中，出于好奇就去查了一下<code>sendfile</code>的作用。</p>
<p>文件下载是服务器的基本功能，其基本流程就是循环的从磁盘读取文件内容到缓冲区，再将缓冲区内容发送到<code>socket</code>文件，程序员基本都会写出类似下面看起来比较高效的程序。</p>
<pre><code class="language-c">while((n = read(diskfd, buf, BUF_SIZE)) &gt; 0)
    write(sockfd, buf , n);
</code></pre>
<p>上面程序中我们使用了<code>read</code>和<code>write</code>两个系统调用，看起来也已经没有什么优化空间了。这里的<code>read</code>和<code>write</code>屏蔽了系统内部的操作，我们并不知道操作系统做了什么，现实情况却是由于 Linux 的 I/O 操作默认是缓冲 I/O，上面的程序发生了多次不必要的数据拷贝与上下文切换。</p>
<p>上述两行代码执行流程大致可以描述如下：</p>
<ol>
<li>系统调用<code>read</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>DMA 执行拷贝（现在都是 DMA 了吧！），把文件数据拷贝到内核缓冲区；</li>
<li>文件数据从内核缓冲区拷贝到用户缓冲区；</li>
<li><code>read</code>调用返回，从内核态切换为用户态；</li>
<li>系统调用<code>write</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>把步骤 3 读到的数据从用户缓冲区拷贝到 Socket 缓冲区；</li>
<li>系统调用<code>write</code>返回，从内核态切换到用户态；</li>
<li>DMA 从 Socket 缓冲区把数据拷贝到协议栈。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1571580838587.png" alt=""></figure>
<p>可以看到两行程序共发生了 4 次拷贝和 4 次上下文切换，其中 DMA 进行的数据拷贝不需要 CPU 访问数据，所以整个过程需要 CPU 访问两次数据。很明显中间有些拷贝和上下文切换是不需要的，<code>sendfile</code>就是来解决这个问题的，它是从 2.1 版本内核开始引入的，这里放个 2.6 版本的<a href="http://lxr.linux.no/linux+v2.6.36/fs/read_write.c#L809">源码</a>。</p>
<p>系统调用<code>sendfile</code>是将<code>in_fd</code>的内容发送到<code>out_fd</code>，描述符<code>out_fd</code>在 Linux 2.6.33 之前，必须指向套接字文件，自 2.6.33 开始，<code>out_fd</code>可以是任何文件；<code>in_fd</code>只能是支持<code>mmap</code>的文件（<code>mmap</code>是一种内存映射方法，在被调用进程的虚拟地址空间中创建一个新的指定文件的映射）。</p>
<p>所以当 Nginx 是一个静态服务器时，开启<code>sendfile</code>配置项是可以大大提高 Nginx 性能的，但是当把 Nginx 作为一个反向代理服务器时，<code>sendfile</code>则没有什么用，因为当 Nginx 时反向代理服务器时，<code>in_fd</code>就是一个套接字，这不符合<code>sendfile</code>的参数要求。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1571580849307.png" alt=""></figure>
<p>可以看到现在我们只需要一次拷贝就可以完成功能了，但是能否把这一次拷贝也省略掉呢？我们可以借助硬件来实现，仅仅需要把缓冲区描述符和文件长度传过去，这样 DMA 直接将缓冲区的数据打包发送到网络中就可以了。</p>
<p>这样就实现了零拷贝技术，需要注意的是这里所说的零拷贝是相对操作系统而言的，即在内核空间不存在冗余数据。数据的实际走向是从硬盘到内存，再从内存到设备。</p>
<p>Nginx 中还有一个<code>aio</code>配置，它的作用是启用内核级别的异步 I/O 功能，要使<code>aio</code>生效需要将<code>directio</code>开启（<code>directio</code>对大文件的读取速度有优化作用），<code>aio</code>很适合大文件的传送。需要注意的是<code>sendfile</code>和<code>aio</code>是互斥的，不可同时兼得二者，因此我们可以设置一个文件大小限制，超过该阀值使用<code>aio</code>，低于该阀值使用<code>sendfile</code>。</p>
<pre><code class="language-nginx">location /video/ {
    sendfile on;
    sendfile_max_chunk 256k; 
    aio threads;
    directio 512k;
    output_buffers 1 128k;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 高级知识技巧]]></title>
        <id>https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao</id>
        <link href="https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao">
        </link>
        <updated>2019-10-13T15:02:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象">对象</h2>
<p>Js 共有<code>number、string、boolean、null、undefined、object</code>六种主要类型，除了<code>object</code>的其它五中类型都属于基本类型，它们本身并不是对象。但是<code>null</code>有时会被当做对象处理，其原因在于不同的对象在底层都表示为二进制，在 js 中二进制前三位都为 0 的话就会被判定为<code>object</code>类型，而<code>null</code>的二进制表示全是 0， 所以使用<code>typeof</code>操作符会返回<code>object</code>，而后续的 Js 版本为了兼容前面埋下的坑，也就没有修复这个 bug。</p>
<p><code>&quot;I'm a string&quot;</code>本身是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度、访问某个字符等，那就需要将其转换为<code>String</code>类型，在必要的时候 js 会自动帮我们完成这种转换，也就是说我们并不需要用<code>new String('I'm a string')</code>来显示的创建一个对象。类似的像使用<code>42.359.toFixed(2)</code>时，引擎也会自动把数字转换为<code>Number</code>对象。</p>
<p><code>null</code>和<code>undefined</code>没有对应的构造形式，它们只有文字形式。相反，<code>Date</code>只有构造，没有文字形式。对于<code>Object、Array、Function</code>和<code>RegExp</code>（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</p>
<h2 id="array-类型">Array 类型</h2>
<p>数组类型有一套更加结构化的值存储机制，但是要记住的是，数组也是对象，所以有趣的是你也可以给数组添加属性。</p>
<pre><code class="language-javascript">var myArray = [&quot;foo&quot;, 42, &quot;bar&quot;];
myArray.baz = &quot;baz&quot;;
myArray.length; // 3
myArray.baz; // &quot;baz&quot;
</code></pre>
<p>数组类型的<code>length</code>属性是比较有特点的，它的特点在于不是只读的，也就是说你可以修改它的值。因此可以通过设置这个属性从数组末尾删除或添加新的项。</p>
<pre><code class="language-javascript">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
colors.length = 2;
console.info(colors[2]); // undefined
colors.length = 4;
console.info(colors[4]); // undefined
// 向后面追加元素
colors[colors.length] = &quot;black&quot;;
</code></pre>
<p>数组还有一些很方便的迭代方法，比如every()、filter()、forEach()、map()、some()，这些方法都不会修改数组中包含的值，传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。</p>
<h2 id="function-类型">Function 类型</h2>
<p>在 ECMAScript 中，每个函数都是<code>Function</code>类的实例，而且都与其它引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>在函数的内部有两个特殊的对象，<code>this</code>和<code>arguments</code>。<code>arguments</code>对象有<code>callee</code>和<code>caller</code>属性。<code>caller</code>用来指向调用它的<code>function</code>对象，若直接在全局环境下调用，则会返回<code>null</code>；<code>callee</code>用来指向当前执行函数，所以我们可以通过下面的方式来实现阶乘函数。</p>
<pre><code class="language-javascript">function factorial(num) {
    if (num &lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
</code></pre>
<p>每个函数都包含两个非继承而来的方法，<code>apply()</code>和<code>call()</code>，这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。首先，<code>apply()</code>方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是<code>Array</code>的实例，也可以是<code>arguments</code>对象。<code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅仅在于接收参数的方式不同，在使用<code>call()</code>方法时必须逐个列举出来。</p>
<pre><code class="language-javascript">window.color = &quot;red&quot;;
var o = {color: &quot;blue&quot;};
function sayColor() {
    console.info(this.color);
}
sayColor(); // red
sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
sayColor.apply(o); // blue
</code></pre>
<p>需要注意的是，在严格模式下未指定环境对象而调用函数，则<code>this</code>值不会转型为<code>window</code>，除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>。</p>
<h2 id="安全的类型检查">安全的类型检查</h2>
<p>Js 内置的类型检查机制并不是完全可靠的，比如在 Safari（第5版前），对正则表达式应用<code>typeof</code>操作符会返回<code>function</code>；像<code>instanceof</code>在存在多个全局作用域（包含 frame）的情况下，也会返回不可靠的结果；前文提到的 Js 一开始埋下的坑也会导致类型检查出错。</p>
<p>我们可以使用<code>toString()</code>方法来达到安全类型检查的目的，在任何值上调用<code>Object</code>原生的<code>toString()</code>方法都会返回一个<code>[object NativeConstructorName]</code>格式的字符串，下面以检查数组为例。</p>
<pre><code class="language-javascript">Object.prototype.toString.call([]); // &quot;[object Array]&quot;
function isArray(val) {
    return Object.prototype.toString.call(val) == &quot;[object Array]&quot;;
}

</code></pre>
<h2 id="作用域安全的构造函数">作用域安全的构造函数</h2>
<p>构造函数其实就是一个使用<code>new</code>操作符调用的函数，当使用<code>new</code>操作符调用时，构造函数内用到的<code>this</code>对象会指向新创建的对象实例，比如我们有下面的构造函数。</p>
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
</code></pre>
<p>现在的问题在于，要是我们不使用<code>new</code>操作符呢？会发生什么！</p>
<pre><code class="language-javascript">let person = Person('name', 23);
console.info(window.name); // name
console.info(window.age); // 23
</code></pre>
<p>很明显，这里污染了全局作用域，原因就在于没有使用<code>new</code>操作符调用构造函数，此时它就会被当作一个普通的函数被调用，<code>this</code>就被解析成了<code>window</code>对象。我们需要将构造函数修改为先确认this是否是正确类型的实例，如果不是则创建新的实例并返回。</p>
<pre><code class="language-javascript">function Person(name, age) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
    } else {
        return new Person(name, age);
    }
}
</code></pre>
<h2 id="高级定时器">高级定时器</h2>
<p>大部分人都知道使用<code>setTimeout()</code>和<code>setInterval()</code>可以方便的创建定时任务，看起来好像 Js 也是多线程的一样，实际上定时器仅仅是计划代码在未来的某个时间执行，但是执行时机是不能保证的。因为在页面的生命周期中，不同时间可能有其它代码控制着 JavaScript 进程。</p>
<p>这里需要注意一下<code>setInterval()</code>函数，仅当没有该定时器的任何其他代码实例时，Js 引起才会将定时器代码添加到队列中。这样可以避免定时器代码可能在代码再次被添加到队列之前还没有完成执行，进而导致定时器代码连续运行好几次的问题。但是这也导致了另外的问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。</p>
<p>假设某个<code>click</code>事件处理程序使用<code>setInterval()</code>设置了一个 200ms 间隔的重复定时器。如果这个事件处理程序花了 300ms 多的时间完成，同时定时器代码也花了差不多了的时间，就会同时出现跳过间隔切连续运行定时器代码的情况。</p>
<p>为了避免<code>setInterval()</code>的重复定时器的这两个缺点，我们可以使用如下模式的链式<code>setTimeout()</code>，代码一看就懂什么意思了。</p>
<pre><code class="language-javascript">setTimeout(function() {
    // 处理中
    setTimeout(arguements.callee, interval);
}, interval)
</code></pre>
<h2 id="消息队列与事件循环">消息队列与事件循环</h2>
<p>如下图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1570979103039.png" alt=""></figure>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。<br>
JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>来看个例子：执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt; 5s）后，再点击两下，整个过程的输出结果是什么？</p>
<pre><code class="language-javascript">setTimeout(function(){
    for(var i = 0; i &lt; 100000000; i++){}
    console.log('timer a');
}, 0)
for(var j = 0; j &lt; 5; j++){
    console.log(j);
}
setTimeout(function(){
    console.log('timer b');
}, 0)
function waitFiveSeconds(){
    var now = (new Date()).getTime();
    while(((new Date()).getTime() - now) &lt; 5000){}
    console.log('finished waiting');
}
document.addEventListener('click', function(){
    console.log('click');
})
console.log('click begin');
waitFiveSeconds();
</code></pre>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达 5s。然后，在 Js 引擎线程执行的时候，<code>'timer a'</code>对应的定时器产生的回调、<code>'timer b'</code>对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于 Js 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务，最后，5s 后的两次 click 事件被放入消息队列，由于此时 Js 引擎线程空闲，便被立即执行了。因此会产生下面的输出顺序。</p>
<pre><code class="language-text">0
1
2
3
4
click begin
finished waiting
click
click
timer a
timer b
click
click
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[家里的狗]]></title>
        <id>https://mengxiaoxu.github.io//post/jia-li-de-gou</id>
        <link href="https://mengxiaoxu.github.io//post/jia-li-de-gou">
        </link>
        <updated>2019-10-12T14:18:04.000Z</updated>
        <content type="html"><![CDATA[<p>为了防止晚上有人来家里偷东西，几乎家家户户都至少会养一只狗。在我的记忆中，我家一开始是没有狗的。</p>
<p>忘记是哪一年夏天的一个清晨，天还没有大亮，我隐约看见在牛棚后面的空地有个黑影，走近一点仔细一看，原来是一只不知道从哪里来的一只黑狗。</p>
<p>它惊恐的看着我，眼神中夹杂着恐惧与无助，佝偻的身子比弓还要弯，倒是很像一个活着的牛轭。他的身子还没有草高，露水把全身的毛都打湿了，还沾着一些不知名的植物种子。我和它对视着，恐惧慢慢填满了它的眼球，我害怕吓到它，赶紧走开去告诉妈。</p>
<p>妈远远看了一眼，让我别管它。随后妈把装着昨晚剩饭的猪食瓢放到牛棚后面的一块石头上，黑狗看见妈带着武器走近早就跑了，我吃早饭时还不时去望望它在不在，有没有吃妈给放在那里的饭。</p>
<p>妈已经把猪喂完准备下地干活了，仍旧没有再次发现黑狗的踪影，也没见猪食瓢有什么变化，我心里有一点点的失落，黑狗应该是已经逃走了吧。</p>
<p>晚上吃完饭妈去拿猪食瓢，告诉我里面的饭已经被吃的一粒不剩，我心里开始期待和它的再次见面。第二天早晨果然见到它了，身上已经没有昨天那么湿了，显然没有前一天来这里时钻的草丛多，妈依旧用猪食瓢装着米饭和米汤放在牛棚后的那个石头上。</p>
<p>就这样过了几日，黑狗走进了我家的屋檐，它的样子实在太丑了。每一根肋骨都清晰的扎眼，看起来爸的手指都比它的小腿粗，感觉下一秒它就会死去。</p>
<p>我并不喜欢它，甚至还有些讨厌它，我实在找不到更丑的词来形容它，不过是出于心里的怜悯与对生命的敬畏，会在吃饭的时候给它丢几个我不吃的肥肉，被烟熏黑的那一层肉边我也丢给它......</p>
<p>有一次同村的一个人路过家门口时，看见那只黑狗吓的赶紧往妈身后躲。“有我在，它不敢咬。”，妈说。邻居夸夸妈说：“这个狗儿喂得好肥”。妈自豪的告诉那个人这只狗每天还送林儿（我）上学。</p>
<p>是的，我也不知道什么时候我已经和大黑狗变得如此亲密了，它每天早上会把我送到山顶的学校，我每天下午回家做完作业会和它一起到田间追逐。在学校也常常会给同学们说大黑狗胸前的那长成了“人”字的一片白毛，我一直相信“人”字是老天爷特地印在它身上，用来告诉我大黑狗是他派来的使者。</p>
<p>大黑狗来我家时已经很老很老了，是我读三年级的某一天，它像往常一样把我送到学校，但是我下午回家却不见它的踪影，一直等到晚上都没有见它回来。那些天我放学回家第一件事就是朝我和它常去的那些地方大声的唤它。</p>
<p>不到一个月后的一天早晨，像大黑狗第一次来我家附近时的场景一样，湿漉漉的身子带着些杂草种子，不同的是它身旁还跟着一只背部有些黑毛的小黄狗，小黄狗胸前也有一个很明显的“人”字。我赶紧去用猪食瓢盛满饭放在它面前，它吃了几口就又走了。</p>
<p>就这样，大黑狗离开了我，给我留下了一只小小的黄奶狗。我不知道它是去找它原来的主人去了，还是觉得自己老了，不愿意让我看见它倒下的样子，反正它就是再也没有回来过。</p>
<p>小黄狗长成了大黄狗，我对这只大黄狗的印象很浅，只记得爸妈把这只黄狗送给了外婆家附近的亲戚，我们留下了它生的一只小黄狗。外婆知道我们把大黄狗送人，还狠狠的批评了爸妈，说自己来家里的狗不能送人。</p>
<p>自然小黄狗很快就长成了大黄狗，我像以前一样也偷偷给大黄狗吃肉，逐渐开始懂事的妹妹也会背着爸妈给它肉吃，我和妹都会夹几片我们压根就不吃的肥肉，离开饭桌假装是到外面吃饭，实际上是给大黄狗送肉去了。</p>
<p>我到离家 30 多公里的镇上读高中，每个月才回家一次。每次离家大黄狗都会送我到集市去赶车，我会在寒暑假的黄昏和它到新修的公路去追逐，带它去它自己一个人不敢去探索的地方。</p>
<p>上大学后和大黄狗相处的时间更少了，听爸妈说它会经常跑到外婆家，外婆好吃好喝的招待它，招呼都不打一声就又跑回来了。还经常和邻居家的狗到麦子地打闹，要把一大片麦子弄倒才肯回家。</p>
<p>每学期回家在离家还有四五百米的地方都会听到它的吠叫，因为它把我当陌生人了。但是只要我大喊一声，它就会立刻停止吠叫，飞奔到我这里，兴奋的往我身上爬，把它的前爪往我身上搭；我努力不让它碰到我的衣服，然而每次到家时我都带着一身泥巴做的狗爪印。</p>
<p>现在大黄狗已经 10 多岁了，它就像大黑狗当年送我一样每天送我妹上学。我也已经走入职场开始工作，待在家里的时间更少了，我不知道它还能活多久，生怕哪次爸妈打电话时会给我说大黄狗死了，只要爸妈没有在电话中提及大黄狗，我都是非常开心的，因为那就代表着它依旧健健康康的活着。</p>
]]></content>
    </entry>
</feed>