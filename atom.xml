<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-10-19T11:33:41.279Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[Nginx 文件操作优化]]></title>
        <id>https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua</id>
        <link href="https://mengxiaoxu.github.io//post/nginx-wen-jian-cao-zuo-you-hua">
        </link>
        <updated>2019-10-19T11:21:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="http://www.178linux.com/54790">Nginx AIO 机制与 sendfile 机制</a><br>
<a href="https://segmentfault.com/q/1010000003055006/a-1020000003064578">sendfile 适用场景</a><br>
<a href="http://xiaorui.cc/2015/06/24/%E6%89%AF%E6%B7%A1nginx%E7%9A%84sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5/">扯淡 Nginx 的 sendfile 零拷贝的概念</a><br>
<a href="https://www.jianshu.com/p/fad3339e3448">浅析 Linux 中的零拷贝技术</a></p>
</blockquote>
<p>今天在看 Nginx 配置的时候，看到了一个<code>sendfile</code>配置项，它可以配置在<code>http、server、location</code>三个块中，出于好奇就去查了一下<code>sendfile</code>的作用。</p>
<p>文件下载是服务器的基本功能，其基本流程就是循环的从磁盘读取文件内容到缓冲区，再将缓冲区内容发送到<code>socket</code>文件，程序员基本都会写出类似下面看起来比较高效的程序。</p>
<pre><code class="language-c">while((n = read(diskfd, buf, BUF_SIZE)) &gt; 0)
    write(sockfd, buf , n);
</code></pre>
<p>上面程序中我们使用了<code>read</code>和<code>write</code>两个系统调用，看起来也已经没有什么优化空间了。这里的<code>read</code>和<code>write</code>屏蔽了系统内部的操作，我们并不知道操作系统做了什么，现实情况却是由于 Linux 的 I/O 操作默认是缓冲 I/O，上面的程序发生了多次不必要的数据拷贝与上下文切换。</p>
<p>上述两行代码执行流程大致可以描述如下：</p>
<ol>
<li>系统调用<code>read</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>DMA 执行拷贝（现在都是 DMA 了吧！），把文件数据拷贝到内核缓冲区；</li>
<li>文件数据从内核缓冲区拷贝到用户缓冲区；</li>
<li><code>read</code>调用返回，从内核态切换为用户态；</li>
<li>系统调用<code>write</code>产生一个上下文切换，从用户态切换到内核态；</li>
<li>把步骤 3 读到的数据从用户缓冲区拷贝到 Socket 缓冲区；</li>
<li>系统调用<code>write</code>返回，从内核态切换到用户态；</li>
<li>DMA 从 Socket 缓冲区把数据拷贝到协议栈。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1571484140766.png" alt=""></figure>
<p>可以看到两行程序共发生了 4 次拷贝和 4 次上下文切换，很明显中间有些拷贝和上下文切换是不需要的，<code>sendfile</code>就是来解决这个问题的，它是从 2.1 版本内核开始引入的，这里放个 2.6 版本的<a href="http://lxr.linux.no/linux+v2.6.36/fs/read_write.c#L809">源码</a>。</p>
<p>系统调用<code>sendfile</code>是将<code>in_fd</code>的内容发送到<code>out_fd</code>，描述符<code>out_fd</code>必须指向套接字文件，而<code>in_fd</code>只能是文件句柄。所以当 Nginx 是一个静态服务器时，开启<code>sendfile</code>配置项是可以大大提高 Nginx 性能的，但是当把 Nginx 作为一个反向代理服务器时，<code>sendfile</code>则没有什么用，因为当 Nginx 时反向代理服务器时，<code>in_fd</code>就是一个套接字，这不符合<code>sendfile</code>的参数要求。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1571484451529.png" alt=""></figure>
<p>可以看到现在我们只需要一次拷贝就可以完成功能了，但是能否把这一次拷贝也省略掉呢？我们可以借助硬件来实现，仅仅需要把缓冲区描述符和文件长度传过去，这样 DMA 直接将缓冲区的数据打包发送到网络中就可以了。</p>
<p>这样就实现了零拷贝技术，需要注意的是这里所说的零拷贝是相对操作系统而言的，即在内核空间不存在冗余数据。数据的实际走向是从硬盘到内存，再从内存到设备。</p>
<p>Nginx 中还有一个<code>aio</code>配置，它的作用是启用内核级别的异步 I/O 功能，要使<code>aio</code>生效需要将<code>directio</code>开启（<code>directio</code>对大文件的读取速度有优化作用），<code>aio</code>很适合大文件的传送。需要注意的是<code>sendfile</code>和<code>aio</code>是互斥的，不可同时兼得二者，因此我们可以设置一个文件大小限制，超过该阀值使用<code>aio</code>，低于该阀值使用<code>sendfile</code>。</p>
<pre><code class="language-nginx">location /video/ {
    sendfile on;
    sendfile_max_chunk 256k; 
    aio threads;
    directio 512k;
    output_buffers 1 128k;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 高级知识技巧]]></title>
        <id>https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao</id>
        <link href="https://mengxiaoxu.github.io//post/javascript-gao-ji-zhi-shi-ji-qiao">
        </link>
        <updated>2019-10-13T15:02:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象">对象</h2>
<p>Js 共有<code>number、string、boolean、null、undefined、object</code>六种主要类型，除了<code>object</code>的其它五中类型都属于基本类型，它们本身并不是对象。但是<code>null</code>有时会被当做对象处理，其原因在于不同的对象在底层都表示为二进制，在 js 中二进制前三位都为 0 的话就会被判定为<code>object</code>类型，而<code>null</code>的二进制表示全是 0， 所以使用<code>typeof</code>操作符会返回<code>object</code>，而后续的 Js 版本为了兼容前面埋下的坑，也就没有修复这个 bug。</p>
<p><code>&quot;I'm a string&quot;</code>本身是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度、访问某个字符等，那就需要将其转换为<code>String</code>类型，在必要的时候 js 会自动帮我们完成这种转换，也就是说我们并不需要用<code>new String('I'm a string')</code>来显示的创建一个对象。类似的像使用<code>42.359.toFixed(2)</code>时，引擎也会自动把数字转换为<code>Number</code>对象。</p>
<p><code>null</code>和<code>undefined</code>没有对应的构造形式，它们只有文字形式。相反，<code>Date</code>只有构造，没有文字形式。对于<code>Object、Array、Function</code>和<code>RegExp</code>（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</p>
<h2 id="array-类型">Array 类型</h2>
<p>数组类型有一套更加结构化的值存储机制，但是要记住的是，数组也是对象，所以有趣的是你也可以给数组添加属性。</p>
<pre><code class="language-javascript">var myArray = [&quot;foo&quot;, 42, &quot;bar&quot;];
myArray.baz = &quot;baz&quot;;
myArray.length; // 3
myArray.baz; // &quot;baz&quot;
</code></pre>
<p>数组类型的<code>length</code>属性是比较有特点的，它的特点在于不是只读的，也就是说你可以修改它的值。因此可以通过设置这个属性从数组末尾删除或添加新的项。</p>
<pre><code class="language-javascript">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
colors.length = 2;
console.info(colors[2]); // undefined
colors.length = 4;
console.info(colors[4]); // undefined
// 向后面追加元素
colors[colors.length] = &quot;black&quot;;
</code></pre>
<p>数组还有一些很方便的迭代方法，比如every()、filter()、forEach()、map()、some()，这些方法都不会修改数组中包含的值，传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。</p>
<h2 id="function-类型">Function 类型</h2>
<p>在 ECMAScript 中，每个函数都是<code>Function</code>类的实例，而且都与其它引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>在函数的内部有两个特殊的对象，<code>this</code>和<code>arguments</code>。<code>arguments</code>对象有<code>callee</code>和<code>caller</code>属性。<code>caller</code>用来指向调用它的<code>function</code>对象，若直接在全局环境下调用，则会返回<code>null</code>；<code>callee</code>用来指向当前执行函数，所以我们可以通过下面的方式来实现阶乘函数。</p>
<pre><code class="language-javascript">function factorial(num) {
    if (num &lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
</code></pre>
<p>每个函数都包含两个非继承而来的方法，<code>apply()</code>和<code>call()</code>，这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。首先，<code>apply()</code>方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是<code>Array</code>的实例，也可以是<code>arguments</code>对象。<code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅仅在于接收参数的方式不同，在使用<code>call()</code>方法时必须逐个列举出来。</p>
<pre><code class="language-javascript">window.color = &quot;red&quot;;
var o = {color: &quot;blue&quot;};
function sayColor() {
    console.info(this.color);
}
sayColor(); // red
sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
sayColor.apply(o); // blue
</code></pre>
<p>需要注意的是，在严格模式下未指定环境对象而调用函数，则<code>this</code>值不会转型为<code>window</code>，除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>。</p>
<h2 id="安全的类型检查">安全的类型检查</h2>
<p>Js 内置的类型检查机制并不是完全可靠的，比如在 Safari（第5版前），对正则表达式应用<code>typeof</code>操作符会返回<code>function</code>；像<code>instanceof</code>在存在多个全局作用域（包含 frame）的情况下，也会返回不可靠的结果；前文提到的 Js 一开始埋下的坑也会导致类型检查出错。</p>
<p>我们可以使用<code>toString()</code>方法来达到安全类型检查的目的，在任何值上调用<code>Object</code>原生的<code>toString()</code>方法都会返回一个<code>[object NativeConstructorName]</code>格式的字符串，下面以检查数组为例。</p>
<pre><code class="language-javascript">Object.prototype.toString.call([]); // &quot;[object Array]&quot;
function isArray(val) {
    return Object.prototype.toString.call(val) == &quot;[object Array]&quot;;
}

</code></pre>
<h2 id="作用域安全的构造函数">作用域安全的构造函数</h2>
<p>构造函数其实就是一个使用<code>new</code>操作符调用的函数，当使用<code>new</code>操作符调用时，构造函数内用到的<code>this</code>对象会指向新创建的对象实例，比如我们有下面的构造函数。</p>
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
</code></pre>
<p>现在的问题在于，要是我们不使用<code>new</code>操作符呢？会发生什么！</p>
<pre><code class="language-javascript">let person = Person('name', 23);
console.info(window.name); // name
console.info(window.age); // 23
</code></pre>
<p>很明显，这里污染了全局作用域，原因就在于没有使用<code>new</code>操作符调用构造函数，此时它就会被当作一个普通的函数被调用，<code>this</code>就被解析成了<code>window</code>对象。我们需要将构造函数修改为先确认this是否是正确类型的实例，如果不是则创建新的实例并返回。</p>
<pre><code class="language-javascript">function Person(name, age) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
    } else {
        return new Person(name, age);
    }
}
</code></pre>
<h2 id="高级定时器">高级定时器</h2>
<p>大部分人都知道使用<code>setTimeout()</code>和<code>setInterval()</code>可以方便的创建定时任务，看起来好像 Js 也是多线程的一样，实际上定时器仅仅是计划代码在未来的某个时间执行，但是执行时机是不能保证的。因为在页面的生命周期中，不同时间可能有其它代码控制着 JavaScript 进程。</p>
<p>这里需要注意一下<code>setInterval()</code>函数，仅当没有该定时器的任何其他代码实例时，Js 引起才会将定时器代码添加到队列中。这样可以避免定时器代码可能在代码再次被添加到队列之前还没有完成执行，进而导致定时器代码连续运行好几次的问题。但是这也导致了另外的问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。</p>
<p>假设某个<code>click</code>事件处理程序使用<code>setInterval()</code>设置了一个 200ms 间隔的重复定时器。如果这个事件处理程序花了 300ms 多的时间完成，同时定时器代码也花了差不多了的时间，就会同时出现跳过间隔切连续运行定时器代码的情况。</p>
<p>为了避免<code>setInterval()</code>的重复定时器的这两个缺点，我们可以使用如下模式的链式<code>setTimeout()</code>，代码一看就懂什么意思了。</p>
<pre><code class="language-javascript">setTimeout(function() {
    // 处理中
    setTimeout(arguements.callee, interval);
}, interval)
</code></pre>
<h2 id="消息队列与事件循环">消息队列与事件循环</h2>
<p>如下图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1570979103039.png" alt=""></figure>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。<br>
JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>来看个例子：执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt; 5s）后，再点击两下，整个过程的输出结果是什么？</p>
<pre><code class="language-javascript">setTimeout(function(){
    for(var i = 0; i &lt; 100000000; i++){}
    console.log('timer a');
}, 0)
for(var j = 0; j &lt; 5; j++){
    console.log(j);
}
setTimeout(function(){
    console.log('timer b');
}, 0)
function waitFiveSeconds(){
    var now = (new Date()).getTime();
    while(((new Date()).getTime() - now) &lt; 5000){}
    console.log('finished waiting');
}
document.addEventListener('click', function(){
    console.log('click');
})
console.log('click begin');
waitFiveSeconds();
</code></pre>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达 5s。然后，在 Js 引擎线程执行的时候，<code>'timer a'</code>对应的定时器产生的回调、<code>'timer b'</code>对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于 Js 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务，最后，5s 后的两次 click 事件被放入消息队列，由于此时 Js 引擎线程空闲，便被立即执行了。因此会产生下面的输出顺序。</p>
<pre><code class="language-text">0
1
2
3
4
click begin
finished waiting
click
click
timer a
timer b
click
click
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[家里的狗]]></title>
        <id>https://mengxiaoxu.github.io//post/jia-li-de-gou</id>
        <link href="https://mengxiaoxu.github.io//post/jia-li-de-gou">
        </link>
        <updated>2019-10-12T14:18:04.000Z</updated>
        <content type="html"><![CDATA[<p>为了防止晚上有人来家里偷东西，几乎家家户户都至少会养一只狗。在我的记忆中，我家一开始是没有狗的。</p>
<p>忘记是哪一年夏天的一个清晨，天还没有大亮，我隐约看见在牛棚后面的空地有个黑影，走近一点仔细一看，原来是一只不知道从哪里来的一只黑狗。</p>
<p>它惊恐的看着我，眼神中夹杂着恐惧与无助，佝偻的身子比弓还要弯，倒是很像一个活着的牛轭。他的身子还没有草高，露水把全身的毛都打湿了，还沾着一些不知名的植物种子。我和它对视着，恐惧慢慢填满了它的眼球，我害怕吓到它，赶紧走开去告诉妈。</p>
<p>妈远远看了一眼，让我别管它。随后妈把装着昨晚剩饭的猪食瓢放到牛棚后面的一块石头上，黑狗看见妈带着武器走近早就跑了，我吃早饭时还不时去望望它在不在，有没有吃妈给放在那里的饭。</p>
<p>妈已经把猪喂完准备下地干活了，仍旧没有再次发现黑狗的踪影，也没见猪食瓢有什么变化，我心里有一点点的失落，黑狗应该是已经逃走了吧。</p>
<p>晚上吃完饭妈去拿猪食瓢，告诉我里面的饭已经被吃的一粒不剩，我心里开始期待和它的再次见面。第二天早晨果然见到它了，身上已经没有昨天那么湿了，显然没有前一天来这里时钻的草丛多，妈依旧用猪食瓢装着米饭和米汤放在牛棚后的那个石头上。</p>
<p>就这样过了几日，黑狗走进了我家的屋檐，它的样子实在太丑了。每一根肋骨都清晰的扎眼，看起来爸的手指都比它的小腿粗，感觉下一秒它就会死去。</p>
<p>我并不喜欢它，甚至还有些讨厌它，我实在找不到更丑的词来形容它，不过是出于心里的怜悯与对生命的敬畏，会在吃饭的时候给它丢几个我不吃的肥肉，被烟熏黑的那一层肉边我也丢给它......</p>
<p>有一次同村的一个人路过家门口时，看见那只黑狗吓的赶紧往妈身后躲。“有我在，它不敢咬。”，妈说。邻居夸夸妈说：“这个狗儿喂得好肥”。妈自豪的告诉那个人这只狗每天还送林儿（我）上学。</p>
<p>是的，我也不知道什么时候我已经和大黑狗变得如此亲密了，它每天早上会把我送到山顶的学校，我每天下午回家做完作业会和它一起到田间追逐。在学校也常常会给同学们说大黑狗胸前的那长成了“人”字的一片白毛，我一直相信“人”字是老天爷特地印在它身上，用来告诉我大黑狗是他派来的使者。</p>
<p>大黑狗来我家时已经很老很老了，是我读三年级的某一天，它像往常一样把我送到学校，但是我下午回家却不见它的踪影，一直等到晚上都没有见它回来。那些天我放学回家第一件事就是朝我和它常去的那些地方大声的唤它。</p>
<p>不到一个月后的一天早晨，像大黑狗第一次来我家附近时的场景一样，湿漉漉的身子带着些杂草种子，不同的是它身旁还跟着一只背部有些黑毛的小黄狗，小黄狗胸前也有一个很明显的“人”字。我赶紧去用猪食瓢盛满饭放在它面前，它吃了几口就又走了。</p>
<p>就这样，大黑狗离开了我，给我留下了一只小小的黄奶狗。我不知道它是去找它原来的主人去了，还是觉得自己老了，不愿意让我看见它倒下的样子，反正它就是再也没有回来过。</p>
<p>小黄狗长成了大黄狗，我对这只大黄狗的印象很浅，只记得爸妈把这只黄狗送给了外婆家附近的亲戚，我们留下了它生的一只小黄狗。外婆知道我们把大黄狗送人，还狠狠的批评了爸妈，说自己来家里的狗不能送人。</p>
<p>自然小黄狗很快就长成了大黄狗，我像以前一样也偷偷给大黄狗吃肉，逐渐开始懂事的妹妹也会背着爸妈给它肉吃，我和妹都会夹几片我们压根就不吃的肥肉，离开饭桌假装是到外面吃饭，实际上是给大黄狗送肉去了。</p>
<p>我到离家 30 多公里的镇上读高中，每个月才回家一次。每次离家大黄狗都会送我到集市去赶车，我会在寒暑假的黄昏和它到新修的公路去追逐，带它去它自己一个人不敢去探索的地方。</p>
<p>上大学后和大黄狗相处的时间更少了，听爸妈说它会经常跑到外婆家，外婆好吃好喝的招待它，招呼都不打一声就又跑回来了。还经常和邻居家的狗到麦子地打闹，要把一大片麦子弄倒才肯回家。</p>
<p>每学期回家在离家还有四五百米的地方都会听到它的吠叫，因为它把我当陌生人了。但是只要我大喊一声，它就会立刻停止吠叫，飞奔到我这里，兴奋的往我身上爬，把它的前爪往我身上搭；我努力不让它碰到我的衣服，然而每次到家时我都带着一身泥巴做的狗爪印。</p>
<p>现在大黄狗已经 10 多岁了，它就像大黑狗当年送我一样每天送我妹上学。我也已经走入职场开始工作，待在家里的时间更少了，我不知道它还能活多久，生怕哪次爸妈打电话时会给我说大黄狗死了，只要爸妈没有在电话中提及大黄狗，我都是非常开心的，因为那就代表着它依旧健健康康的活着。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[怎样才能开开心心的呢？]]></title>
        <id>https://mengxiaoxu.github.io//post/o9IjztOrR</id>
        <link href="https://mengxiaoxu.github.io//post/o9IjztOrR">
        </link>
        <updated>2019-09-08T13:53:11.000Z</updated>
        <content type="html"><![CDATA[<p>好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。</p>
<p>说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。</p>
<p>媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。</p>
<p>包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”</p>
<p>像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。</p>
<p>我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。</p>
<p>很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。</p>
<p>这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。</p>
<p>于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。</p>
<p>当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。</p>
<p>当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。</p>
<p>举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。</p>
<p>我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。</p>
<p>另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569419637197.png" alt=""></figure>
<p>我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。</p>
<p>周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？</p>
<p>凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量提升与作用域]]></title>
        <id>https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu</id>
        <link href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu">
        </link>
        <updated>2019-08-08T14:29:11.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考内容：<br>
<a href="https://www.crifan.com/lhs_rhs_meaning/">lhs rhs是啥意思</a><br>
《Javasript 高级程序设计（第三版）》<br>
《你不知道的 JavaScript（上卷）》</p>
</blockquote>
<p>几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为<strong>作用域</strong>。</p>
<h3 id="编译原理">编译原理</h3>
<p>我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。</p>
<p>传统语言在执行之前会经历三个步骤：<strong>分词/词法分析、解析/语法分析、代码生成</strong>，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。</p>
<p>我们需要先了解三个名词。<strong>引擎</strong>：从头到尾负责整个 js 程序的编译及执行过程；<strong>编译器</strong>：负责词法分析及代码生成；<strong>作用域</strong>：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
<p><code>var a = 2;</code>，我们以这段程序为例，它首先声明了变量<code>a</code>，然后将<code>2</code>赋值给变量<code>a</code>。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。</p>
<p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>
<h3 id="变量提升">变量提升</h3>
<p>用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码</p>
<pre><code class="language-javascript">console.log(a);
var a = 2;
</code></pre>
<p>上述代码在<code>a</code>声明之前访问了变量<code>a</code>，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是<code>undefined</code>。</p>
<p>回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，<strong>包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理</strong>。所以我们前面列出来的代码实际上会变成下面这个样子。</p>
<pre><code class="language-javascript">var a;
console.log(a);
a = 2;
</code></pre>
<p>这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。</p>
<pre><code class="language-javascript">foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}
</code></pre>
<p>这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。</p>
<pre><code class="language-javascript">function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};
</code></pre>
<p>可以看到，虽然<code>var foo</code>出现在<code>function foo()</code>之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。</p>
<h3 id="lhs-和-rhs-查询">LHS 和 RHS 查询</h3>
<p>LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是<strong>赋值操作符的左侧和右侧</strong>。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。</p>
<p>RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。</p>
<p><code>console.info(a);</code>我们深入研究一下这句代码。这里对<code>a</code>的引用是 RHS 引用，因为这里<code>a</code>并没有赋予任何值，相应的需要查找并取得<code>a</code>的值，这样才能传递给<code>console.info()</code>。</p>
<p><code>a = 2;</code>对<code>a</code>的引用则是一个 LHS 引用，因为实际上我们并关心<code>a</code>当前的值是什么，只是想为<code>= 2</code>这个赋值操作找到一个目标。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a);
}
foo(2);
</code></pre>
<p>为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行<code>foo()</code>函数的调用需要对<code>foo</code>进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给<code>foo()</code>函数时，2 会被分配给参数<code>a</code>，为了给参数<code>a</code>（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了<code>a = 2</code>的语句。</p>
<p>前文已经说过了<code>console.info(a);</code>会对<code>a</code>进行一次 RHS 查询，需要注意的是<code>console.info()</code>本身也需要一个引用才能执行，因此会对<code>console</code>对象进行 RHS 查询，并检查得到的值中是否有一个<code>log</code>方法。</p>
<h3 id="为什么区分-lhs-和-rhs">为什么区分 LHS 和 RHS</h3>
<p>我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。</p>
<pre><code class="language-javascript">function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);
</code></pre>
<p>第一次对<code>b</code>进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。</p>
<p>引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<blockquote>
<p>需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。</p>
</blockquote>
<p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。</p>
<h3 id="作用域链">作用域链</h3>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是<code>window</code>对象，因此所有的全局变量和函数都是作为<code>window</code>对象的属性和方法创建的。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。</p>
<p>当代码在环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function changeColor() {
    var anotherColor = &quot;red&quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();
</code></pre>
<p>下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。</p>
<pre><code class="language-text">window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor
</code></pre>
<p>作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：</p>
<pre><code class="language-javascript">var color = &quot;blue&quot;;

function getColor() {
    var color = &quot;red&quot;;
    return color;
}

console.info(getColor()); // &quot;red&quot;
</code></pre>
<p>在<code>getColor()</code>中沿着作用域链在局部环境中已经找到了<code>color</code>，所以搜索就停止了，也就是说任何位于局部变量<code>color</code>的声明之后的代码，如果不使用<code>window.color</code>都无法访问全局<code>color</code>变量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[惰性载入函数]]></title>
        <id>https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu</id>
        <link href="https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu">
        </link>
        <updated>2019-08-06T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考资料：<br>
《JavaScript 高级程序设计（第三版）》<br>
<a href="https://github.com/mqyqingfeng/Blog/issues/44">JavaScript专题之惰性函数</a><br>
<a href="https://xiaohuochai.site/JS/ECMA/types/LazyFunction.html">深入理解javascript函数进阶之惰性函数</a></p>
</blockquote>
<p>因为不同厂商的浏览器相互之间存在一些行为上的差异，很多 js 代码包含了大量的<code>if</code>语句，将执行引导到正确的分支代码中去，比如下面的例子。</p>
<pre><code class="language-javascript">function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != 'undefined') {
        if (typeof arguments.callee.activeXString != 'string') {
            var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
            var i, len;
            for (i = 0, len = versions.length; i &lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (e) {
                    // skip
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error('No XHR object available.');
    }
}
</code></pre>
<p>我们可以发现，在浏览器每次调用<code>createXHR()</code>的时候，它都要对浏览器所支持的能力仔细检查，但是很明显当第一次检查之后，我们就应该知道浏览器是否支持我们所需要的能力，因此除第一次之外的检查都是多余的。即使只有一个<code>if</code>语句也肯定要比没有<code>if</code>语句慢，所以<code>if</code>语句不必每次都执行，那么代码可以运行的更快一些，<strong>惰性载入</strong>就是用来解决这种问题的技巧。</p>
<h3 id="函数重写">函数重写</h3>
<p>要理解惰性载入函数的原理，我们有必要先理解一下函数重写技术，由于一个函数可以返回另一个函数，因此可以在函数内部用新的函数来覆盖旧的函数。</p>
<pre><code class="language-javascript">function sayHi() {
    console.info('Hi');
    sayHi = function() {
        console.info('Hello');
    }
}
</code></pre>
<p>我们第一次调用<code>sayHi()</code>函数时，控制台会打印出<code>Hi</code>，全局变量<code>sayHi</code>被重新定义，被赋予了新的函数，从第二次开始之后的调用都会打印出<code>Hello</code>。惰性载入函数的本质就是函数重写，惰性载入的意思就是函数执行的分支只会发生一次。</p>
<h3 id="惰性载入">惰性载入</h3>
<p>我们来看一个例子（例子来源于<a href="https://github.com/mqyqingfeng">冴羽</a>所写的<a href="https://github.com/mqyqingfeng/Blog/issues/44">JavaScript专题之惰性函数</a>）。现在需要写一个<code>foo</code>函数，这个函数返回首次调用时的<code>Date</code>对象，注意是首次。</p>
<h5 id="方案一">方案一</h5>
<pre><code class="language-javascript">var t;
function foo() {
    if (t) return t;
    t = new Date()
    return t;
}
// 此方案存在两个问题，一是污染了全局变量
// 二是每次调用都需要进行一次判断
</code></pre>
<h5 id="方案二">方案二</h5>
<pre><code class="language-javascript">var foo = (function() {
    var t;
    return function() {
        if (t) return t;
        t = new Date();
        return t;
    }
})();
// 使用闭包来避免污染全局变量，
// 但是还是没有解决每次调用都需要进行一次判断的问题
</code></pre>
<h5 id="方案三">方案三</h5>
<pre><code class="language-javascript">function foo() {
    if (foo.t) return foo.t;
    foo.t = new Date();
    return foo.t;
}
// 函数也是一种对象，利用这个特性也可以解决
// 和方案二一样，还差一个问题没有解决
</code></pre>
<h5 id="方案四">方案四</h5>
<pre><code class="language-javascript">var foo = function() {
    var t = new Date();
    foo = function() {
        return t;
    };
    return foo();
};
// 利用惰性载入技巧，即重写函数
</code></pre>
<p>惰性载入函数有两种实现方式，第一种是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一种按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行分支了。</p>
<p>第二种实现方式是在声明函数时就指定适当的函数。这样第一次调用时就不会损失性能了，而是在代码首次加载时会损失一点性能，即是利用闭包写一个自执行的函数。</p>
<h3 id="改进-createxhr">改进 createXHR</h3>
<p>有了上面的基础，我们就可以将<code>createXHR()</code>改进为下列形式，这样就不用每次调用都进行判断了。</p>
<pre><code class="language-javascript">// 第一种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        createXHR = function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != 'undefined') {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != 'string') {
                var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
                var i, len;
                for (i = 0, len = versions.length; i &lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error('No XHR object available.');
        }
    }
}

// 第二种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != 'undefined') {
        return function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != 'undefined') {
        return function() {
            if (typeof arguments.callee.activeXString != 'string') {
                var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];
                var i, len;
                for (i = 0, len = versions.length; i &lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error('No XHR object available.');
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[非设计师需要知道的四个设计原则]]></title>
        <id>https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze</id>
        <link href="https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">
        </link>
        <updated>2019-06-22T14:33:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>作者：Anna 4erepawko Mészáros，UI/UX 设计师。<br>
关注作者：<a href="https://medium.com/@4erepawko"> Medium</a>、<a href="https://twitter.com/4erepawko">Twitter</a></p>
</blockquote>
<p>这篇文章是写给无力邀请专业设计师的所有内容创作者的，以及设计师异常忙碌的团队的非设计师们。如果您按照这些简单的步骤进行操作，我保证您的设计会变得更好。</p>
<p>这些 Tips 来源于我对身边非设计朋友的多年观察，家人与同事在日常生活中也需要设计他们的东西。比如简历、作品集，Facebook 和 Instagram 上帖子要使用的图片，YouTube 视频的缩略图等。</p>
<p>所有这些人都向我寻求帮助与建议，希望能让他们的东西看起来更好。我坚信「授人以鱼不如授人以渔」，所以我试图提供更有价值的建议，以便他们在未来也能解决类似的问题。</p>
<p>随着时间的推移，我意识到我一直在给所有人提供相同的建议，虽然每次所使用的措辞不同，但我所有的建议都可以提炼为以下四个原则。</p>
<p>这些 Tips 会帮您创造出美丽动人的设计吗？答案是不会！它们只会帮您创造出色、清晰且易于理解的设计。是每个人都可以轻松理解和互动吗？那当然，所以不多说废话，下面我就向您逐一展示。</p>
<h3 id="对比">对比</h3>
<p>确保所有元素之间有足够的对比度。为什么？因为那些略有差异但是又不够不同东西，创造了一种恐怖谷。人类的眼睛会排斥它们，对它们感到厌恶、难以理解。我们不希望它们出现在我们的设计中，难道不是吗？</p>
<blockquote>
<p>恐怖谷理论，是一个关于人类对机器人和非人类物体的感觉的假设。如果一个非人类实体不够拟人，那么它身上的人类特征会很容易辨认；而当它足够拟人时，他身上的非人类特征则会变得很容易辨认。因此会在人类观察者眼中产生一种古怪的感觉，想想您看到病患者或者尸体时的感觉。</p>
</blockquote>
<p>因此您设计的元素要么完全相同，要么具有显著差异。</p>
<p>您可以从下面四个方面来突出对比：</p>
<p><em><strong>1、颜色：浅色上使用暗色，反之亦然</strong></em></p>
<p><strong>示例：</strong> 切勿在浅蓝色上使用浅灰色或浅粉红色等灰色组合，它们会造成阅读/互动上的极大困难。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569508466579.jpg" alt=""></figure>
<p><em><strong>2、大小：相邻元素要么大小完全相同，要么大小区别很大</strong></em></p>
<p><strong>示例：</strong> 不要将 32pt 和 36pt 的文本放在一起；18pt 和 36pt 放在一起会显得更加协调。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569508508617.jpg" alt=""></figure>
<p><em><strong>3、粗细：与大小一样，相邻元素的粗细要么完全相同，要么有明显的区别</strong></em></p>
<p><strong>示例：</strong> 不要将相同字体的粗体与黑体放在一起，因为它们看起来太相似了；将黑体与细体放在一起会显得很协调。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569508538231.jpg" alt=""></figure>
<p><em><strong>4、风格：不要将一个斜体类型放在另一个斜体类型旁边，或者在一个衬线字体旁边放置另一个衬线字体。应该组合不同的东西。</strong></em></p>
<p><strong>示例：</strong> 不要将 Times New Roman 与 Georgia 放在一起，它们看起来太相似了，应该组合完全不同的风格。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569508569075.jpg" alt=""></figure>
<h3 id="一致性">一致性</h3>
<p>确保相似的元素以相似的方式出现。为什么呢？首先，通过确保确保事物一致性，您可以让用户将注意力集中在设计的重要方面，而不是被随时变化的元素分散注意力。</p>
<p>其次，一致性也增加了用户对您的信任，使事物看起来实际上是设计的，而不是简单快速拼凑出来的。</p>
<p>一旦你选择了具体的风格，就要毫不犹豫的坚持下去，这里所说的风格包括字体、颜色、阴影、栅格、对齐、装饰风格等等。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569508599900.jpg" alt=""></figure>
<p>当您处理许多相邻的不同部分时（比如 YouTube 的视频缩略图或是中型文章的封面），您应该为所有部分选择一种整体风格，并坚持使用。</p>
<h3 id="奥卡姆剃刀-减少视觉噪音">奥卡姆剃刀 减少视觉噪音</h3>
<p>在您的设计中，使用的元素越少越好。为什么呢？因为人类的大脑很难在输入过载的情况下处理信息并作出决策。您应该使用尽可能少的装饰元素（字体、颜色、阴影、图标等等）。</p>
<p>将奥卡姆剃刀应用于所有内容。如果只需要两个元素就能满足需求，那么就不要使用 3 个元素；如果 10 个元素实现所需的功能，那么就不要用 20 个元素。</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569508627847.jpg" alt=""></figure>
<p>如果您不喜欢古老的英国哲学家风格，更喜欢您在 Netflix（一家美国流媒体提供商）上看到的东西。请将<a href="https://zh.wikipedia.org/wiki/%E6%80%A6%E7%84%B6%E5%BF%83%E5%8A%A8%E7%9A%84%E4%BA%BA%E7%94%9F%E6%95%B4%E7%90%86%E9%AD%94%E6%B3%95">怦然心动的人生整理魔法</a>应用到您的设计中。</p>
<blockquote>
<p>《怦然心动的人生整理魔法》是美国流媒体提供商Netflix于2019年1月1日首播的一档真人实境秀节目。节目由日本“整理咨询顾问” 近藤麻理惠主创。她在每集节目中拜访一个家庭，帮助他们整理自己的房间。<br>
近藤麻理惠认为整理房间时应当将物品分为五类：衣物、书籍、纸张文件、杂物和情感纪念品；在整理时拿起每件物品，如果能使自己“怦然心动”则留下，如果不能则要感谢物品的贡献然后与其告别。</p>
</blockquote>
<h3 id="间距">间距</h3>
<p>元素的位置会发送关于其含义的元级别消息。为什么这很重要？因为了解如何放置元素以及在它们周围预留了多少空间有助于降低设计的复杂性，因此会使人更加愉悦，并且更容易交互。</p>
<p>在您的设计中使用间距来传达下面 3 个方面的信息：</p>
<p><em><strong>1、接近度 = 相关性</strong></em></p>
<p>与其它元素相比，彼此更接近的事物被认为它们有更强的相关性。这是最重要的，因为我觉得它常常容易被忽视。</p>
<p>它可以以很多不同的方式应用，比如行与行之间应该有一定的间距，而不是一行中每个单词之间的间距那么小；同样不同段落之间的空间也比段落内的行空间要大。</p>
<p><img src="https://mengxiaoxu.github.io//post-images/1569508662741.jpg" alt=""><br>
元素之间的间距应该小于元素与组合边缘之间的间距。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569508700468.jpg" alt=""></figure>
<p>标签和支撑信息应该位于其相关元素附近。</p>
<figure data-type="image" tabindex="8"><img src="https://mengxiaoxu.github.io//post-images/1569508720176.jpg" alt=""></figure>
<p><em><strong>2、留白</strong></em></p>
<p>结合奥卡姆剃刀，给您的设计尽可能留白，去整理它们，使它们的意义更加明显。</p>
<p>如果把太多元素放在有限的空间里，就像同时听三首不同的哥，很难理解别人在说什么。</p>
<figure data-type="image" tabindex="9"><img src="https://mengxiaoxu.github.io//post-images/1569508742018.jpg" alt=""></figure>
<p><em><strong>3、重要性与顺序</strong></em></p>
<p>这是一个很普通的常识，但是我还是要在这里提到它。</p>
<p>最重要的事情放在第一位，使它们占据最大的空间，用一系列的事物来传达秩序。</p>
<h3 id="结束语">结束语</h3>
<p>恭喜您！如果您按照这些 Tips 进行设计，那么按照行业标准，它可能看起来非常好。</p>
<p><strong>For everything else, there is always a designer.</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刘小绪同学随笔（2019-05-12）]]></title>
        <id>https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-05-12</id>
        <link href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-05-12">
        </link>
        <updated>2019-05-12T14:32:47.000Z</updated>
        <content type="html"><![CDATA[<p>最近机缘巧合和几个中年大叔聊天，从眼神里面能看出来他们是讲的真心话，平时也非常反感长辈们给自己讲的一些大而空的道理，但仔细想想这些话其实并不是完全没用。</p>
<p>不管对方是世俗眼光中的成功人士还是失败人士，他们都会有自己没有实现的理想愿望，成功人士没有好好陪家人孩子，他们可能喜欢特地找个时间，不管接收方是否感动，但至少他自己已经得到心灵的慰藉了；失败人士没有给到家人足够富裕的生活，这时候他们都很喜欢看<code>努力</code>、<code>奋斗</code>、<code>自强不息</code>......一类词汇堆砌的文章。而老人的精神世界已经不是奋斗了，而是<code>人这一生......</code>，所以如果陪老人说话，你只需要把话题引入到佛身上，然后静静的听就可以了。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>忘了啥时候无意中加了一个高中生，目前正在读高二，与大多数人不同的是，她属于双性恋人群，并且更偏爱小姐姐，出口成脏，上课偷偷玩手机，宛然一个大家脑中所构想的问题少年。</p>
<p>但是几个月前突然变了，一下子变得有礼貌起来了，我问她是因为什么变了，她告诉我是因为我说的一句话：不说脏话是对人起码的尊重。这句话让她想明白了，我在这里偷偷说一句，我也不知道当时说的这句话对不对，其实就是随口一说，让一个小娃娃变好了，那也好。</p>
<p>在我的循序诱惑下，小姑娘已经不藏手机了，每周日自觉的把手机交上去，每周五手机发下来再玩，所以我和她的聊天记录现在基本上变成了，周日我发一句“加油”，周五下午我会收到一句“突然出现”。</p>
<p>小姑娘自己是同性恋的事情不敢给爸妈说，我想这是不是因为父母与孩子天然就有一种屏障，以至于无法与他们进行心灵上的沟通，要想能够得到孩子的信任，父母应该多站在孩子角度考虑考虑问题，尽量不要拿「我都是为你好」去搪塞孩子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>最近上饶杀熊孩子案很火，女生父亲杀人当然是不对对，但是对于这种校园霸凌这件事，校方与男生家长都摆出无所谓的态度，才导致悲剧的发生，其实校园霸凌的核心不在熊孩子身上，而是在熊家长身上。</p>
<p>吴军在其《大学之路》上有写道：“在我的印象中，父母晚上从来不参加应酬，甚至不看什么电视剧，总是非常有规律的学习，我的母亲现在快 80 岁了，依然每天坚持学习，父母们并不知道，他们在对我们兄弟的教育上最成功之处，是以他们的行为潜移默化地影响了我们，让我们渐渐养成了终身学习的习惯”。借句公益广告词——父母是最好的老师。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>最近一个很搞笑的新闻，法国一所小学为了拯救学校不被关闭，招了 15 只羊作为新生。简单来说就是，根据法国政策，当学生数量少于 261 时，学校将被迫停办，而法国人在抗议上也很有创意，反正规定上又没有写招生的物种必须是人，正好我们家有许多只适龄绵羊，都送去上学吧！</p>
<p>牧民说到做到，这周二就和校长及家长达成一致，带领着自己家50只绵羊赶到学校招生办公室报道，招生办的老师热情的接待了羊以及送羊报道的牧羊犬们，在检查了所有绵羊的出生证后，最终有15只年龄在3-6岁之间的适龄绵羊顺利通过合法注册，成为小学的一年级新生，让这所小学不至于被停学。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>我们常常把体育锻炼与健身、减肥挂钩，前段时间杭州程序员小伙伴突然精神崩溃，引发了一大波人关注，在校大学生跳楼也是常有的事，但是去细细看一下，是不是很少会看到体育生跳楼。</p>
<p>大学生跳楼无非是意志力脆弱、心理自我调节能力差等方面影响的，而体育锻炼恰恰会无意中去缩短了这些短板，我主要不是想说体育锻炼有多么多么好，因为这是大家都知道的，而是想说一件事的作用范围可能比你想象的要大的多。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>今天是母亲节，无意中突然记起了初中的一篇阅读理解——《那支枯萎的康乃馨》，读者大人可以去搜搜读读，从另一个角度看看母亲节送礼这件事，不知道现在的朋友圈孝子还多不多。</p>
<p>同样今天是 5.12 汶川地震纪念日，地震发生时我还在读 6 年级，记得整个床都摇的快要倒了，房子上面的瓦片蹭蹭的往下掉，但是学生中间没有一个害怕了，原因只是因为我们并不知道地震这个词。</p>
<p>去年的 5.28 日，吉林松原发生了一次小的地震，哈尔滨有震感，作为也算经历过地震的人，自然异常的敏感，熟睡中的我一下就惊醒了，立刻意识到地震了，然后在那三四秒的时间里面，时间好像停住了一样，我都数不清那几秒时间脑海里滑过了多少记忆，我体会到了面对死亡的感觉，几秒过后，根据汶川地震的经验，本次只是小地震，所以我又躺下睡觉了，然后室友们都跑出去了。</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>出来工作也有大半年了，之前以为第一份工作是学习技术的，现在才发现第一份工作首先应该学习的是做事态度，在学校如果某件事不想做或者太困难，那么完全可以选择不做，但是在企业不行，一些恶心的事情必须有人得去做，学生总是缺乏应有的责任感，但责任感是优秀员工的基本条件。</p>
<p>我之前在公司怼过两次领导，怼完领导之后他反倒对我更好了，给我解决问题的速度超快，现在回想起来可能自己实际上做错了，为啥不能心平气和的去解释，而采取暴力沟通，今后我也要学习怎么做一个圆滑的俗人。</p>
<p>保持一个虚心的学习态度是异常重要的，认清自己资质平平的现实。一些人在公司认为经理是个傻逼，总监是个马屁精，董事长屁股决定脑袋，那不过是因为你没到那个位置，没办法理解他们考虑问题的角度而已。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569767623293.png" alt=""></figure>
<p>最后，放个图，开心一下！！！</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g2yp4ldad4g308c05ynp4.jpg" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅析浏览器缓存机制]]></title>
        <id>https://mengxiaoxu.github.io//post/qCt13nLLT</id>
        <link href="https://mengxiaoxu.github.io//post/qCt13nLLT">
        </link>
        <updated>2019-04-26T12:29:29.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。</p>
<h4 id="http-报文">HTTP 报文</h4>
<p>HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。</p>
<h4 id="缓存概述">缓存概述</h4>
<p>浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569414647062.png" alt=""></figure>
<p>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有<strong>强制缓存</strong>和<strong>协商缓存</strong>两类，也有人把协商缓存叫对比缓存。</p>
<h4 id="强制缓存">强制缓存</h4>
<p>我们先自己想一下，使用缓存是不是会有下面几种情况出现。</p>
<ul>
<li>
<p>存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；</p>
</li>
<li>
<p>存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；</p>
</li>
<li>
<p>不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。</p>
</li>
</ul>
<p>控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，并且<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<h6 id="expires">Expires</h6>
<p><code>Expires</code>是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于<code>Expires</code>值，就直接使用缓存数据。到了 HTTP/1.1，<code>Expires</code>已经被<code>Cache-Control</code>替代了。</p>
<p><code>Expires</code>被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。</p>
<h6 id="cache-control">Cache-Control</h6>
<p><code>Cache-Control</code>是 HTTP/1.1 中最重要的规则，主要取值为：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与<code>private</code>一样。</td>
</tr>
<tr>
<td><code>private</code></td>
<td>所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认值。</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存内容将在 xxx 秒后失效</td>
</tr>
</tbody>
</table>
<p>我们可以看看下面这个例子，可以从截图中看到<code>Expires</code>是一个绝对值，而<code>Cache-Control</code>是一个相对值，此处为<code>max-age=3600</code>，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，<code>Cache-Control</code>相比于<code>Expires</code>是更好的选择，所以同时存在时只有<code>Cache-Control</code>生效。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569414685538.png" alt=""></figure>
<h4 id="协商缓存">协商缓存</h4>
<p>协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569414775602.png" alt=""></figure>
<p>上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，所以同时存在时只有<code>Etag / If-None-Match</code>生效。</p>
<h6 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h6>
<p>你可以往上翻一翻，看一下那张响应报文截图，其中有一个<code>Last-Modified</code>字段，它的值是该资源文件在服务器最后被修改的时间。</p>
<p><code>If-Modified-Since</code>则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值。服务器收到该请求后，发现该请求头有<code>If-Modified-Since</code>字段，则会将<code>If-Modified-Since</code>与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569414811322.png" alt=""></figure>
<h6 id="etag-if-none-match">Etag / If-None-Match</h6>
<p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。</p>
<p><code>If-None-Match</code>则是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569414845179.png" alt=""></figure>
<h4 id="disk-cache-与-memory-cache">disk cache 与 memory cache</h4>
<p>我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569414871028.png" alt=""></figure>
<p>猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。</p>
<p>内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。</p>
<p>浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。</p>
<h4 id="总结">总结</h4>
<p>到这里偷懒一下子了，找到人家画的一张图，看图就行了。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569414915648.png" alt=""></figure>
<blockquote>
<p>参考内容：<br>
<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a><br>
<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 进阶及常用命令]]></title>
        <id>https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling</id>
        <link href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling">
        </link>
        <updated>2019-04-18T14:43:54.000Z</updated>
        <content type="html"><![CDATA[<p>如果你只是想查看 Git 常用命令可以选择直接到文章底部「Git 常用命令」阅读，文章大部分内容是 Git 进阶知识，均是自己的读书笔记，如果还想在此基础上再上一层楼，那可以直接看 <a href="https://git-scm.com/book/zh/v2">Pro Git book</a>。</p>
<h4 id="git-历史">Git 历史</h4>
<p>版本控制器是一种记录一个或若干文件内容变化，以便将来查阅特定版本的修订情况。也就是说，版本控制器记录了一个可供考证的历史数据，通过该数据可以知道文件是怎么一步一步发展到今天这个样子的。</p>
<p>最初 Linux 项目使用 BitKeeper 来管理和维护代码，但是到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。那 Linux 开源社区的解决方案就是自己搞一个版本控制器，所以就有了 Git。</p>
<p>简单说就是 Linus 被逼的去开发了这一款叫做 Git 的版本控制器，因为 Linus 本身就是内核专家与文件专家，所以 Git 也就自然而然具备了非凡的存储能力与性能。</p>
<h4 id="安装">安装</h4>
<p>关于如何安装 git 可以查看 <a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Pro Git book</a>，安装完成后需要进行一些必要的配置，比如用户信息、文本编辑器、差异分析工具等等，我们可以通过<code>git config --list</code>来查看配置信息。比如我们要配置用户和邮箱，就可以像下面这样输入命令。</p>
<pre><code class="language-shell">$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
</code></pre>
<h4 id="git-原理">Git 原理</h4>
<p>Git 和大多数版本控制器有一个重要的区别，就是它<strong>直接记录快照，而非差异比较</strong>，其它大部分系统以文件变更列表的方式存储信息，而 Git 则存储每个文件与初始版本的差异。换句话说，只要你的文件有改动，那么 Git 就会将该文件复制一份，正因为 Git 的这个特性，所以 Git 仓库很容易就变得非常大；为了高效，如果文件没有修改，那么 Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p>
<p>Git 有三个区，分别为：仓库、工作目录、暂存区。基本的 Git 流程为：1）在工作目录中修改文件；2）暂存文件，将文件的快照放入暂存区域；3）提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。那么相应的 Git 就有三种状态：已提交（committed）、已修改（modified）和已暂存（staged），你的文件可能处于其中之一。</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9hcmVhcy5wbmc?x-oss-process=image/format,png" alt="image"></figure>
<h4 id="git-基础">Git 基础</h4>
<p>工作目录中的文件不外乎处于两种状态：已跟踪或未跟踪。已跟踪是指那些纳入了版本控制的文件，在上一次快照中有它们的记录；工作目录中除了已跟踪文件以外的所有文件都属于未跟踪文件，们既不存在于上次快照的记录中，也没有放入暂存区。</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9saWZlY3ljbGUucG5n?x-oss-process=image/format,png" alt="image"></figure>
<h6 id="查看文件状态">查看文件状态</h6>
<p>如果需要查看哪些文件处于什么状态，可以使用<code>git status</code>命令，这个命令显示的信息十分详细，如果你喜欢简洁一点的信息，那么可以在其后添加一个<code>-s</code>，其报告格式类似于下面这样。</p>
<pre><code class="language-shell">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre>
<p><code>??</code>表示新添加的未跟踪文件；修改过的文件前面有<code>M</code>标记，右边的表示还没有放入暂存区，左边的表示已经放入暂存区了。当然你可能不希望每个文件都出现在未跟踪列表中，比如编译过程临时创建的文件、日志文件等等，所以可以通过创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式，它支持标准的<code>glob</code>模式匹配（shell 所使用的简化了的正则表达式），在 <a href="https://github.com/github/gitignore">gitignore</a> 中有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表。</p>
<p><code>git status</code>对于具体修改显示的过于模糊，如果想查看具体修改了什么地方，可以使用<code>git diff</code>命令，比如<code>git diff README.md</code>。需要注意的是<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动，如果需要查看已经暂存起来的变化，则要加上<code>--staged</code>或者<code>--cached</code>，比如<code>git diff --cached README.md</code>。</p>
<h6 id="删除文件">删除文件</h6>
<p>当然我们不可避免的需要删除某个文件，如果你仅仅是简单的从工作目录中手工删除文件，那它并没有真正的从 Git 中删除，Git 会将这次删除识别为一次改动。更好的方式是使用<code>git rm</code>命令来完成删除文件的工作，比如<code>git rm README.md</code>就会从已跟踪文件中删除，并且连带从工作目录中删除指定文件。</p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。这时就需要使用<code>--cached</code>选项了，比如<code>git rm --cached README</code>。</p>
<h6 id="查看历史">查看历史</h6>
<p>我们或许因为某种原因需要回顾一下提交历史，这时<code>git log</code>就派上用场了，默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code>提供的选项很多，更详细的内容可以查看 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">Git 基础 - 查看提交历史</a>。除了不带选项的命令，我个人更常用的命令还有另外两个，分别为：<code>git log --pretty=oneline</code>它将每个提交放在一行显示，在查看的提交数很大时非常有用；<code>git log --graph</code>或者<code>git log --pretty=oneline --graph</code>用于显示 ASCII 图形表示的分支合并历史。</p>
<h6 id="撤销操作">撤销操作</h6>
<p>在任何一个阶段我们都可能有想要撤销的操作，我们只需要掌握几个基本的撤销操作就能够应对日常的工作了。</p>
<p>第一种情况：取消上一次提交。有时候当我们提交完之后才发现漏掉了几个文件没有添加，或者是提交信息写错了，此时可以使用带<code>--amend</code>选项的提交命令尝试重新提交，即<code>git commit --amend</code>。这个命令会将暂存区的文件全部提交，如果自上次提交以来你还没一做任何修改（比如，在上次提交后马上执行了此命令），那么快照将会保持不变，而所修改的只是提交信息。</p>
<p>第二种情况：取消暂存的文件。假设你修改了两个文件并且想要将它们作为两次独立提交，但是却不小心输入了<code>git add *</code>暂存了它们两个，如何取消其中一个暂存呢？其实在运行<code>git status</code>时已经给出提示了。</p>
<pre><code class="language-shell">$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md
</code></pre>
<p>所以如果我们想要取消<code>CONTRIBUTING.md</code>的暂存，那么就可以用<code>git reset HEAD CONTRIBUTING.md</code>命令来完成。</p>
<p>第三种情况：撤销对文件的修改。有时候我们可能并不想保留对某个（若干）文件的修改，<code>git status</code>也给出了详细的提示，告诉我们如何将文件还原成上次提交时的样子，即<code>git checkout -- &lt;file&gt;</code>，比如输入命令<code>git checkout -- CONTRIBUTING.md</code>，就会将<code>CONTRIBUTING.md</code>重置到上一次提交时的样子。</p>
<p>需要注意的是<code>git checkout -- &lt;file&gt;</code>是一个比较危险的命令，因为它仅仅是拷贝了另一个文件来覆盖当前文件，所以你对那个文件的所有修改都会消失，而且不可恢复。</p>
<h6 id="远程仓库">远程仓库</h6>
<p>前面我们都是在讲本地操作，远程仓库的使用是必不可少的技能。可以使用<code>git remote</code>命令查看每一个远程服务器的简写，对于已经克隆的仓库，它至少会包含一个<code>origin</code>，这是 Git 给克隆仓库服务器取的默认名字，它和其它服务器并没有什么区别，只是很少人会去修改这个默认名字而已。</p>
<p>如果想要给一个远程仓库重新取一个简写名，那么可以运行<code>git remote rename</code>来完成，比如<code>git remote rename pb paul</code>就是将<code>pb</code>重命名为<code>paul</code>。值得注意的是这样同样也会修改你的远程分支名字，那些过去引用<code>pb/master</code>的现在全引用<code>paul/master</code>。</p>
<p>当想要将自己的成果分享给他人时，就需要将其推送到上游，使用<code>git push [remote-name] [branch-name]</code>即可，比如你想要将<code>master</code>分支推送到<code>origin</code>服务器时，就可以运行<code>git push origin master</code>。</p>
<p>除了分享自己的成果，我们也需要获取他人的成果，即从仓库拉取自己没有的信息，比如<code>git fetch origin</code>，需要注意的是<code>git fetch</code>命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作，所以你还需要<code>git merge</code>来合并分支，实际上有一个<code>git pull</code>命令可以帮我们把这两个步骤都做了，你可以简单的将<code>git pull</code>理解为<code>git fetch</code>后面紧接着一个<code>git merge</code>。</p>
<h4 id="分支管理">分支管理</h4>
<p>Git 的分支模型是它的必杀技特性，它处理分支的方式是难以置信的轻量，创建分支几乎是在一瞬间完成，而且在不同分支间的切换也非常的便捷，要理解 Git 的分支，我们必须要再次回顾 Git 是如何保存数据的。</p>
<p>下图是我们的一个工作流，可以看到所谓的分支实际上就是一个可以移动的指针而已，<code>master</code>、<code>v1.0</code>都仅仅是一个指针，而创建分支、切换分支等操作也都只是对指针的操作，因此就不奇怪为什么 Git 这么快了。<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9icmFuY2gtYW5kLWhpc3RvcnkucG5n?x-oss-process=image/format,png" alt="image"></p>
<p>那么 Git 又是如何知道当前在哪一个分支上呢？它仅仅是用了一个名为<code>HEAD</code>的特殊指针，你可以将<code>HEAD</code>想象为当前分支的别名，<code>HEAD</code>指向哪个分支，就表示当前处于哪个分支。</p>
<h6 id="分支创建与切换">分支创建与切换</h6>
<p>我们可以使用<code>git branch [branch-name]</code>来创建一个新的分支，比如<code>git branch testing</code>；如果使用不带选项的<code>git branch</code>，那么它会列出当前所有的分支，这里需要注意的是<code>master</code>分支也不是特殊分支，它是运行<code>git init</code>时自动创建的默认分支，因为大家都懒得去改它，所以它就好像变得特殊了一样。</p>
<p><code>git branch [branch-name]</code>只是创建了一个新分支，并不会切换到这个分支上面去，分支的切换说白了就是移动<code>HEAD</code>指针，我们只需要使用<code>git checkout testing</code>就可以切换到<code>testing</code>分支上去了。</p>
<p>当然我们可以使用<code>git checkout -b [branch-name]</code>来创建一个分支并同时切换到这个分支，把这个命令与<code>git commit -a -m</code>来对比，你就会发现它们的类似之处。</p>
<h6 id="分支的合并与删除">分支的合并与删除</h6>
<p>当我们零时在一个新分支上解决了问题后，需要将其合并到<code>master</code>分支，只需要切换到<code>master</code>再运行<code>git merge</code>命令即可，Git 会自动找到这两个分支的共同祖先，然后做一个简单的三方合并。</p>
<p>当然理想情况下是直接合并成功，但是不免会遇到合并冲突的情况，一旦遇到冲突了，Git 会像下面这样来标记冲突内容，你需要做的是选择由<code>=======</code>分割的令部分的其中一个或者自行合并，当<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行被完全删除了，你需要对每个文件使用<code>git add</code>将其标记为冲突已解决。</p>
<pre><code class="language-html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id=&quot;footer&quot;&gt;
 please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; testing:index.html
</code></pre>
<p>当合并完分支后，之前的分支一般就不会再要了，这时你可以运行<code>git branch -d [branch-name]</code>来删除指定分支，比如使用<code>git branch -d testing</code>来删除<code>testing</code>分支。</p>
<h6 id="远程分支">远程分支</h6>
<p>远程分支以<code>(remote)/(branch)</code>的形式来命名。如下图所示，如果你克隆一个仓库下来，那么这个仓库除了会有一个本地的分支指针，还会有一个远程分支指针。如果你在本地的<code>master</code>分支做了一些工作，但是你并没有与<code>origin</code>服务器连接，那么你的<code>origin/master</code>指针就不会移动。</p>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL2ltYWdlcy9yZW1vdGUtYnJhbmNoZXMtMS5wbmc?x-oss-process=image/format,png" alt="image"></figure>
<p>在这之前我们已经讲过通过推送分享自己的成果，在运行<code>git push origin master</code>命令时，Git 会自动的将<code>master</code>分支名字展开为<code>refs/heads/master:refs/heads/master</code>，即意味着<strong>推送本地的<code>master</code>分支来更新远程仓库上的<code>master</code>分支</strong>，所以你也可以运行<code>git push origin master:testing</code>来做类似的事，如果远程仓库没有<code>testing</code>分支，那它会自己创建一个新的<code>testing</code>分支。</p>
<p>我们肯定需要创建一个跟踪远程仓库的其它分支，最简单的就是运行<code>git checkout -b [new-branch] [remote-name]/[branch]</code>，该命令会以远端<code>[branch]</code>分支的内容来创建本地的<code>[new-branch]</code>分支，Git 也对该命令做了一个简化，<code>git checkout --track [remote-name]/[branch]</code>，该命令就会在本地创建一个<code>[branch]</code>分支用于跟踪远端的<code>[branch]</code>分支。</p>
<p>当然，我们还需要了解一个删除远程分支的命令<code>git push origin --delete [branch]</code>，需要注意的是这个命令基本上只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h4 id="git-常用命令">Git 常用命令</h4>
<p>挑了一些比较重要 Git 命令，我把个人常用的命令使用代码块标记出来了。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>将一个目录转变成一个 Git 仓库</td>
</tr>
<tr>
<td>git clone</td>
<td>从远程克隆一个仓库到本地，它是<a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">多个命令的组合</a>，</td>
</tr>
<tr>
<td><code>git add</code></td>
<td>将内容从工作目录添加到暂存区</td>
</tr>
<tr>
<td><code>git commit</code></td>
<td>将暂存区文件在数据库中创建一个快照，然后将分支指针移到其上</td>
</tr>
<tr>
<td><code>git commit -a -m [msg]</code></td>
<td><code>git add``和</code>git commit```的组合</td>
</tr>
<tr>
<td>git status</td>
<td>展示工作区及暂存区域中不同状态的文件</td>
</tr>
<tr>
<td><code>git status -s</code></td>
<td>比<code>git status</code>展示的内容更加简洁</td>
</tr>
<tr>
<td><code>git diff</code></td>
<td>对比工作目录文件和暂存区快照之间的差异</td>
</tr>
<tr>
<td>git diff --cached</td>
<td>对比已暂存的差异</td>
</tr>
<tr>
<td><code>git reset</code></td>
<td>根据你传递给动作的参数来执行撤销操作</td>
</tr>
<tr>
<td><code>git rm</code></td>
<td>从工作区，或者暂存区移除文件</td>
</tr>
<tr>
<td>git clean</td>
<td>从工作区中移除不想要的文件的命令</td>
</tr>
<tr>
<td><code>git checkout</code></td>
<td>切换分支，或者检出内容到工作目录</td>
</tr>
<tr>
<td>git branch</td>
<td>列出你所有的分支、创建新分支、删除分支及重命名分支</td>
</tr>
<tr>
<td><code>git checkout -b [branch]</code></td>
<td>创建新分支并切换到该分支</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>展示历史记录</td>
</tr>
<tr>
<td><code>git log --pretty=oneline</code></td>
<td>简洁版历史记录</td>
</tr>
<tr>
<td><code>git merge</code></td>
<td>合并一个或者多个分支到已检出的分支中</td>
</tr>
<tr>
<td><code>git stash</code></td>
<td>临时地保存一些还没有提交的工作</td>
</tr>
<tr>
<td><code>git pull</code></td>
<td>git fetch 和 git merge 命令的组合体</td>
</tr>
<tr>
<td><code>git push</code></td>
<td>将本地工作内容推送到远程仓库</td>
</tr>
<tr>
<td><code>git push origin local_branch:remote_branch</code></td>
<td>比<code>git push</code>更加详细的推送</td>
</tr>
<tr>
<td><code>git checkout --track [remote-name]/[branch]</code></td>
<td>在本地创建一个分支用于跟踪远程同名分支</td>
</tr>
</tbody>
</table>
<blockquote>
<p>参考内容：<a href="https://git-scm.com/book/zh/v2">Pro Git book</a></p>
</blockquote>
]]></content>
    </entry>
</feed>