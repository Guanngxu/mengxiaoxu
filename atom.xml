<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengxiaoxu.github.io/</id>
    <title>刘小绪同学的博客</title>
    <updated>2019-09-25T11:50:48.862Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengxiaoxu.github.io/"/>
    <link rel="self" href="https://mengxiaoxu.github.io//atom.xml"/>
    <subtitle>正在学习写代码的码农</subtitle>
    <logo>https://mengxiaoxu.github.io//images/avatar.png</logo>
    <icon>https://mengxiaoxu.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 刘小绪同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[为什么处理排序数组比未排序数组快]]></title>
        <id>https://mengxiaoxu.github.io//post/SpXxa8r-v</id>
        <link href="https://mengxiaoxu.github.io//post/SpXxa8r-v">
        </link>
        <updated>2019-09-25T11:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>今天在群里看到一个有意思的问题——为什么处理排序数组比处理没有排序的数组要快，这个问题来源于 <a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">StackoverFlow</a>，虽然我看到代码略微知道原因，但是模模糊糊不够清晰，搜了很多博客也讲的不够明白，所以就自己来总结了。</p>
<p>首先来看一下问题，下面是很简单的一段代码，随机生成一些数字，对其中大于 128 的元素求和，记录并打印求和所用时间。</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c &lt; arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i &lt; 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c &lt; arraySize; ++c)
            {
                if (data[c] &gt;= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println(&quot;sum = &quot; + sum);
    }
}
</code></pre>
<p>我的运行结果：分别在对数组排序和不排序的前提下测试，在不排序时所用的时间比先排好序所用时间平均要多 10 ms。这不是巧合，而是必然的结果。</p>
<p>问题就出在那个<code>if</code>判断上面，在旧文<a href="https://mp.weixin.qq.com/s/8WwJK0CfKz1o_bwefxBd5Q">顺序、条件、循环语句的底层解释</a>中其实已经提到了造成这种结果的原因，只是旧文中没有拿出具体的例子来说明。</p>
<p>为了把这个问题搞明白，需要先对<code>流水线</code>有一定的了解。计算机是指令流驱动的，执行的是一个一个的指令，而执行一条指令，又要经过<code>取指、译码、执行、访存、写回、更新</code>六个阶段（不同的划分方式所包含的阶段不一样）。</p>
<p>六个阶段使用的硬件基本是不一样的，如果一条指令执行完再去执行另一条指令，那么在这段时间里会有很多硬件处于空闲状态，要使计算机的速度变快，那么就不能让硬件停下来，所以有了流水线技术。</p>
<p>流水线技术通过将指令重叠来实现几条指令并行处理，下图表示的是三阶段指令时序，即把一个指令分为三个阶段。在第一条指令的 B 阶段，A 阶段相关的硬件是空闲的，于是可以将第二条指令的 A 阶段提前操作。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569412133980.png" alt=""></figure>
<p>很明显，这种设计大幅提高了指令运行的效率，聪明的你可能发现问题了，要是不知道下一条指令是什么怎么办，那提前的阶段也就白干了，那样流水线不就失效了？没错，这就是导致开篇问题的原因。</p>
<p>让流水线出问题的情况有三种：1、<code>数据相关</code>，后一条指令需要用到前一条指令的运算结果；2、<code>控制相关</code>，比如无条件跳转，跳转的地址需要在译码阶段才能知道，所以跳转之后已经被取出的指令流水就需要清空；3、<code>结构相关</code>，由于一些指令需要的时钟周期长（比如浮点运算等），长时间占用硬件，导致之后的指令无法进入译码等阶段，即它们在争用同一套硬件。</p>
<p>代码中的<code>if (data[c] &gt;= 128)</code>翻译成机器语言就是跳转指令，处理器事先并不知道要跳转到哪个分支，那难道就等知道了才开始下一条指令的取指工作吗？处理器选择了假装知道会跳转到哪个分支（不是谦虚，是真的假装知道），如果猜中了是运气好，而没有猜中那就浪费一点时间重新来干。</p>
<p>没有排序的数组，元素是随机排列的，每次<code>data[c] &gt;= 128</code>的结果也是随机的，前面的经验就不可参考，所以下一次执行到这里理论上还是会有 50% 的可能会猜错，猜错了肯定就需要花时间来修改犯下的错误，自然就会浪费更多的时间。</p>
<p>对于排好序的数组，开始几次也需要靠猜，但是猜着猜着发现有规律啊，每次都是往同一个分支跳转，所以以后基本上每次都能猜中，当遍历到与 128 分界的地方，才会出现猜不中的情况，但是猜几次之后，发现这又有规律啊，每次都是朝着另外一个相同分支走的。</p>
<p>虽然都会猜错，但是在排好序的情况下猜错的几率远远小于未排序时的几率，最终呈现的结果就是处理排序数组比未排序数组快，其原因就是流水线发生了大量的控制相关现象，下面通俗一点，加深一下理解。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569412222054.jpg" alt=""></figure>
<p>远在他方心仪多年的姑娘突然告诉你，其实她也喜欢你，激动的你三天三夜睡不着觉，决定开车前往她的城市，要和她待在一起，但是要去的路上有很多很多岔路，你只能使用的某某地图导航，作为老司机并且怀着立马要见到爱人心情的你，开车超快，什么样罚单都不在乎了。</p>
<p>地图定位已经跟不上你的速度了，为了尽快到达，遇到岔路你都是随机选一条路前进，遗憾的是，自己的选择不一定对（我们假设高速可以回退），走错路了就要重新回到分岔点，这就对应着未排序的情况。</p>
<p>现在岔路是有规律的，告诉你开始一直朝着一边走，到某个地点后会一直朝着另一边走，你只需要花点时间去探索一下开始朝左边还是右边，到了中间哪个地点会改变方向就可以了，相比之下就能节省不少时间了，尽快见到自己的爱人，这对应着排好序的情况。</p>
<blockquote>
<p>最后的故事改编自两个人的现实生活，一位是自己最好的朋友之一，谈恋爱开心的睡不着觉；另一位是微信上的一位好友，为了对方从北京裸辞飞到了深圳。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数调用与空间分配]]></title>
        <id>https://mengxiaoxu.github.io//post/cYbqHG1mh</id>
        <link href="https://mengxiaoxu.github.io//post/cYbqHG1mh">
        </link>
        <updated>2019-09-25T11:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>我们在编程序的时候，都会把某一个特定功能封装在一个函数里面，对外暴露一个接口，而隐藏了函数行为的具体实现，一个大型的复杂系统里面包含了很多这样的小函数，我们称之为<strong>过程</strong>。</p>
<p>过程是相对独立的小模块，系统的运行需要这些过程的紧密合作，这种合作就是函数调用。</p>
<p>在一个函数执行时调用别的函数，比如 P 调用 Q，需要执行一些特定的动作。<code>传递控制</code>，在调用 Q 之前，控制权在 P 的手里，既然要调用 Q，那么就需要把控制权交给 Q；<code>传递数据</code>，就是函数传参；<code>分配与释放内存</code>，在开始时，Q 可能需要位局部变量分配空间，结束时又必须释放这些存储空间。</p>
<p>大多数语言都使用栈提供的先进后出机制来管理内存，x86-64 可以通过通用寄存器传递最多 6 个整数值（整数或地址），如果超过 6 个，那就需要在栈中分配内存，并且通过栈传递参数时，所有数据的大小都要向 8 的倍数对齐。将控制权从 P 转交给 Q，只需要将 PC（程序计数器）的值置为 Q 代码的起始位置，并记录好 P 执行的位置，方便 Q 执行完了，继续执行 P 剩余的代码。</p>
<p>在函数的传参、执行中，多多少少都需要空间来保存变量，局部数据能保存在寄存器中就会保存在寄存器中，如果寄存器不够，将会保存在内存中。除了寄存器不够用的情况，还有数组、结构体和地址等局部变量都必须保存在内存中。分配内存很简单，只需要减小栈指针的值就行了，同样释放也只需要增加栈指针。</p>
<p>在函数执行过程中，处理栈指针<code>%rsp</code>，其它寄存器都被分类为<code>被调用者保存寄存器</code>，即当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。</p>
<p>所以递归也就不难理解了，初学算法总觉得递归有点奇妙，怎么自己调用自己，而实际上对于计算机来说，它和调用其它函数没什么区别，在计算机眼里，没有自身与其它函数的区别，所有被调用者都是其它人。</p>
<p>数组是编程中不可或缺的一种结构，“数组是分配在连续的内存中”这句话已经烂熟于心了，历史上，C 语言只支持大小在编译时就能确定的多维数组，这个多多少少有一些不便利，所以在<code>ISO C99</code>标准中就引入了新的功能，允许数组的维度是表达式。</p>
<pre><code class="language-c">int A[expr1][expr2]
</code></pre>
<p>因为数组是连续的内存，所以很容易就能访问到指定位置的元素，它通过首地址加上偏移量即可计算出对应元素的地址，这个偏移量一定意义上就是由索引给出。</p>
<p>比如现在有一个数组<code>A</code>，那么<code>A[i]</code>就等同于表达式<code>* (A + i)</code>，这是一个指针运算。C 语言的一大特性就是指针，既是优点也是难点，单操作符<code>&amp;</code>和<code>*</code>可以产生指针和简介引用指针，也就是，对于一个表示某个对象的表达式<code>expr</code>，<code>&amp;expr</code>给出该对象地址的一个指针，而对于一个表示地址的表达式<code>Aexpr</code>，<code>*Aexpr</code>给出该地址的值。</p>
<p>即使我们创建嵌套（多维）数组，上面的一般原则也是成立的，比如下面的例子。</p>
<pre><code class="language-c">int A[5][3];

// 上面声明等价于下面
typedef int row3_t[3];
row3_t A[5];
</code></pre>
<p>这个数组在内存的中就是下面那个样子的。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411935351.png" alt=""></figure>
<p>还有一个重要的概念叫做<code>数据对齐</code>，即很多计算机系统要求某种类型的对象的地址必须是某个值 K（一般是2、4 或 8）的倍数，这种限制简化了处理器和内存接口之间的设计，甚至有的系统没有进行数据对齐，程序就无法正常运行。</p>
<p>比如现在有一个如下的结构体。</p>
<pre><code class="language-c">struct S1 {
    int i;
    char c;
    int j;
}
</code></pre>
<p>如果编译器用最小的 9 字节分配，那么将是下面的这个样子。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411921819.png" alt=""></figure>
<p>但是上面这种结构无法满足 i 和 j 的 4 字节对齐要求，所以编译器会在 c 和 j 之间插入 3 个字节的间隙。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411906634.png" alt=""></figure>
<p>在极客时间专栏中有这样一段代码。</p>
<pre><code class="language-c">int main(int argc, char *argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i &lt;= 3; i++){
        arr[i] = 0;
        printf(&quot;Hello world!\n&quot;);
    }
    return 0;
}
</code></pre>
<p>这段代码神奇的是在某种情况下会一直循环的输出<code>Hello world</code>，并不会结束，在<a href="https://mp.weixin.qq.com/s/BRRReU3akhqh8vgm59GNvA">计算机系统漫游（补充）</a>中也提到过。</p>
<p>造成上面这种结果是因为函数体内的局部变量存在栈中，并且是连续压栈，而 Linux 中栈又是从高向低增长。数组<code>arr</code>中是 3 个元素，加上 i 是 4 个元素，刚好满足 8 字节对齐（编译器 64 位系统下默认会 8 字节对齐），变量<code>i</code>在数组<code>arr</code>之前，即<code>i</code>的地址与<code>arr</code>相邻且比它大。</p>
<p>代码中很明显访问数组时越界了，当<code>i</code>为 3 时，实际上正好访问到变量<code>i</code>的地址，而循环体中又有一句<code>arr[i] = 0;</code>，即又把<code>i</code>的值设置为了 0，由此就导致了死循环。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[顺序、条件、循环语句的底层解释]]></title>
        <id>https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi</id>
        <link href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">
        </link>
        <updated>2019-09-25T11:19:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="顺序结构">顺序结构</h4>
<h5 id="数据传送指令">数据传送指令</h5>
<p>我们都清楚，绝大多数编译器都把汇编语言作为中间语言，把汇编语言程序变成可运行的二进制文件早就解决了，所以现在的高级语言基本上只需要把自己翻译成汇编语言就可以了。</p>
<p>汇编指令总共只有那么多，大多数指令都是对数据进行操作，比如常见的数据传送指令<code>mov</code>。不难理解，被操作数据无非有三种形式，<strong>立即数</strong>，即用来表示常数值；<strong>寄存器</strong>，此时的数据即存放在指定寄存器中的内容；<strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置。</p>
<p>需要注意的是，到了汇编层级，就不像高级语言那样随随便便<code>int</code>就能和<code>long</code>类型的数据相加减，他们在底层所占有的字节是不一样的，汇编指令是区分操作数据大小的，比如数据传送指令，就有下面这些品种（x86-64 对数据传送指令加了一条限制：两个操作数不能都指向内存位置）。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569410442560.png" alt=""></figure>
<h5 id="压栈与弹栈">压栈与弹栈</h5>
<p>对于栈，我想不必多讲，IT 行业的同学都清楚，它是一种线性数据结构，其中的数据遵循“先进后出”原则，寄存器<code>%rsp</code>保存着栈顶元素的地址，即栈顶指针。一个程序要运行起来，离不开栈这种数据结构。</p>
<p>栈使用最多的就是弹栈<code>popq</code>和压栈<code>pushq</code>操作。比如将一个四字值压入栈中，栈顶指针首先要减 8（栈向下增长），然后将值写到新的栈顶地址；而弹栈则需要先将栈顶数据读出，然后再将栈指针加 8。所以<code>pushq</code>和<code>popq</code>指令就可以表示为下面的形式。</p>
<pre><code class="language-c">// 压栈
subq $8, %rsp
movq %rbp, (%rsp)

// 弹栈
movq (%rsp), %rax
addq $8, %rsp
</code></pre>
<p>其他还有算术、逻辑、加载有效地址、移位等等指令，可以查阅相关文档了解，不作过多介绍，汇编看起来确实枯燥乏味。</p>
<h4 id="条件结构">条件结构</h4>
<p>前面讲的都是顺序结构，我们的程序中不可能只有顺序结构，条件结构是必不可缺的元素，那么汇编又是如何实现条件结构的呢？</p>
<p>首先你需要知道，除了整数寄存器，CPU 还维护着一组<strong>条件码寄存器</strong>，我们主要是了解如何把高级语言的条件结构转换为汇编语言，不去关注这些条件码寄存器，只需要知道汇编可以通过检测这些寄存器来执行条件分支指令。</p>
<h5 id="if-else-语句">if-else 语句</h5>
<p>下面是 C 语言中的<code>if-else</code>语句的通用形式。</p>
<pre><code class="language-c">if(test-expr){
    then-statement
}else{
    else-statement
}
</code></pre>
<p>汇编语言通常会将上面的 C 语言模板转换为下面的控制流形式，只要使用条件跳转和无条件跳转，这种形式的控制流就可以和汇编代码一一对应，我们以 C 语言形式给出。</p>
<pre><code class="language-c">    t = test-expr;
    if(!t){
        goto false;
    }
    then-statement;
    goto done;
false:
    else-statement;
done:
</code></pre>
<p>但是这种条件控制转移形式的代码在现代处理器上可能会很低效。原因是它无法事先确定要跳转到哪个分支，我们的处理器通过<strong>流水线</strong>来获得高性能，流水线的要求就是事先明确要执行的指令顺序，而这种形式的代码只有当条件分支求值完成后，才能决定走哪一个分支。即使处理器采用了非常精密的分支预测逻辑，但是还是有错误预测的情况，一旦预测错误，那将会浪费 15 ~ 30 个时钟周期，导致性能下降。</p>
<blockquote>
<p>在流水线中，把一条指令分为多个阶段，每个阶段只执行所需操作的一小部分，比如取指令、确定指令类型、读数据、运算、写数据以及更新程序计数器。流水线通过重叠连续指令的步骤来获得高性能，比如在取一条指令的同时，执行它前面指令的算术运算。所以如果事先不知道指令执行顺序，那么事先所做的预备工作就白干了。</p>
</blockquote>
<p>为了提高性能，可以改写成使用条件数据传送的代码，比如下面的例子。</p>
<pre><code class="language-c">v = test-expr ? then-expr : else-expr；

// 使用条件数据传送方法
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t){
    v = ve;
}
</code></pre>
<p>这样改写，就能提高程序的性能了，但是并不是所有的条件表达式都可以使用条件传送来编译，一般只有当两个表达式都很容易计算时，编译器才会采用条件数据传送的方式，大部分都还是使用条件控制转移方式编译。</p>
<h5 id="switch-语句">switch 语句</h5>
<p><code>switch</code>语句可以根据一个整数索引值进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。为了让<code>switch</code>的实现更加高效，使用了一种叫做<strong>跳转表</strong>的数据结构（Radis 也是用的跳表）。跳转表是一个数组，表项 i 是一个代码段的地址，当开关情况数量比较多的时候，就会使用跳转表。</p>
<p>我们举个例子，还是采用 C 语言的形式表是控制流，要理解的是执行<code>switch</code>语句的关键步骤就是通过跳转表来访问代码的位置。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
    long val = x;
    switch(n){
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
        case 103:
            val += 11;
            break;
        case 104:
        case 105:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
</code></pre>
<p>要注意的是，上面的代码中有的分支没有<code>break</code>，这种问题在笔试中会经常遇到，没有<code>break</code>会继续执行下面的语句，即变成了顺序执行。上面的代码会被翻译为下面这种控制流。</p>
<pre><code class="language-c">void switch_eg(long x, long n, long *dest){
        static void *jt[7] = {
            &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,
            &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,
            &amp;&amp;loc_D
        };
        unsigned long index = n - 100;
        long val;
        if(index &gt; 6){
            goto loc_def;
        }
        goto *jt[index];
    loc_A:
        val = x * 13;
        goto done;
    loc_B:
        x = x + 10;
    loc_C:
        val = x + 11;
        goto done;
    loc_D:
        val = x * x;
        goto done;
    loc_def:
        val = 0;
    done:
        *dest = val;
}
</code></pre>
<h4 id="循环结构">循环结构</h4>
<p>C 语言中有<code>do-while</code>、<code>while</code>和<code>for</code>三种循环结构，它们的通用形式一般都长下面那样。</p>
<pre><code class="language-c">// do-while
do
    body-statement
    while(test-expr);
    
// while
while(test-expr)
    body-statement
    
// for
for(init-expr; test-expr; update-expr)
    body-statement
</code></pre>
<p><code>do-while</code>的特点是<code>body-statement</code>一定会执行一次，所以我们可以将<code>do-while</code>翻译成下面的控制流形式，很容易就能联想到它的汇编形式。</p>
<pre><code class="language-c">loop:
    body-statement;
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p><code>while</code>循环我们给出两种形式的控制流，其中一种包含<code>do-while</code>形式，如下所示。</p>
<pre><code class="language-c">// 第一种形式
t = test-expr;
if(!t){
    goto done;
}
do
    body-statement;
    while(test-expr);
done:


// 第二种形式
    goto test;
loop:
    body-statement;
test:
    t = test-expr;
    if(t){
        goto loop;
    }
</code></pre>
<p>面试的时候，有的面试官会问你<code>for</code>循环的执行顺序，现在深入理解了三种循环的机制，再也不怕面试官啦。<code>for</code>循环可以转换成如下的<code>while</code>形式。</p>
<pre><code class="language-c">init-expr;
while(test-expr){
    body-statement;
    update-expr;
}
</code></pre>
<p>有了这种形式的<code>for</code>循环，我们只需要将其中的<code>while</code>部分再翻译一下就好了，前文给出了两种<code>while</code>翻译的方式，而具体采用哪种方式，取决于编译器优化的等级。</p>
<h4 id="总结">总结</h4>
<p>计算机就是用那么几条简简单单的指令就完成了各种复杂的操作，不得不折服于计算机科学家们的魅力。现在人工智能被炒的很火热，然后人是事件、情感驱动的，而计算机是控制流驱动的，所以从架构上就决定了，冯诺依曼体系计算机实现的都是弱人工智能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息的表示和处理]]></title>
        <id>https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li</id>
        <link href="https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li">
        </link>
        <updated>2019-09-24T17:02:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="字数据大小">字数据大小</h4>
<p>前面已经提到过<code>信息=位+上下文</code>，但是基本上的计算机都没有将位作为最小的可寻址单位，而是将字节作为了最小的可寻址单位，内存就是一个非常大的字节数组，它的的每个字节都由一个唯一的数字来标识（这个数字是不需要存的），所有可能的地址集合就是虚拟地址空间。</p>
<p>我们常说的 32 位、64 位指的是一台计算机的<strong>字长</strong>，用于指明指针数据的的标称大小。有的面试官在面试的时候会问这样一个问题：在 C/C++ 中指针的大小是多少？如果你一下就回答出来时多少个字节了，那基本上不必再问了，因为一个指针的大小取决于计算机的字长，所以应该分 32 位机还是 64 位机的情况。</p>
<p>字长还会决定一个极为重要的系统参数——<strong>虚拟地址空间</strong>。比如现在有一个 32 位机，每一位可以取值 1 或 总共 32 位，能组合的出局就有 2<sup>32</sup> 个，所以它能访问 2<sup>32</sup> 个地址，其大小也就是 4G，因此你如果给 32 位机装上 8G 的内存条，是起不了多大作用的。</p>
<p>我们平时所说的 32 位程序和 64 位程序并不是指机器的字长，它们的区别在于程序时如何编译的，而不是其运行的机器类型，高版本都应该做到向后兼容，所以 32 位程序一般都能运行在 64 位机器上，而 64 位程序时不能运行在 32 位机上面的。下面两种伪指令就分别用于编译 32 位程序和 64 位程序。</p>
<pre><code class="language-shell">gcc -m32 prog.c
gcc -m64 prog.c
</code></pre>
<p>C 语言在 32 位机和 64 位机上所表现的差别在于<code>long</code>数据类型，一般在 32 位机上是 4 个字节，而在 64 位机上是 8 个字节，而作为程序员要力图程序能在不同的机器上进行编译执行，要做到这一点就需要保证程序对不同数据类型的确切大小不敏感。</p>
<blockquote>
<p>曾经某运营商的一个基站版本因为数据范围的不同而造成了巨大的损失，在编程环境中使用的是 32 位机，而基站所使用的处理器没有 32 位，最后表现的效果就是大概每隔 40 天，基站就自动复位了。定位到这个问题都花费了巨大的财力和人力资源。</p>
</blockquote>
<h4 id="寻址及字节顺序">寻址及字节顺序</h4>
<p>上文已经提到，有很多的对象实际上不止占用一个字节，而是占用了多个字节，此时就涉及到如何排列这些字节了，以及如何存储这些字节。以<code>11001100 11001100</code>为例，它占用了两个字节，我们可以选择将这两个字节放在连续的内存中，也可以将两个字节分开放在不连续的内存中；另外我们可以将左边的字节当做起始位置，也可以将右边的字节当做起始位置（更专业的称为<strong>大端法和小端法</strong>）。</p>
<p>对于字节的排列，到底是用大端法还是小端法，没有技术上的争论，只有社会政治论题的争论，而且机器它对程序员是完全不可见的。几乎所有的机器都将多字节对象存储为连续的字节序列，所使用字节中最小的地址作为对象的地址。</p>
<p>那么什么时候需要注意字节的顺序规则呢，那就是编写网络应用程序的时候，试想你传输的数据是用大端法表示的，而用户的计算机采用的是小端法，那还会有用户使用你的产品吗。所以编写网络程序时需要遵循已经建立的关于字节顺序的规则。</p>
<h4 id="整数表示">整数表示</h4>
<p>程序员对二进制不会不知道，比如 <code>11111111</code>表示的是 255（不考虑补码），很容易就能转换为我们所熟悉的 10 进制数据。这种方式我们默认它是无符号数，如果要加入有符号数就开始变得有趣了。</p>
<p>几乎所有的计算机都是采用有<strong>补码</strong>来表示有符号整数的，它与无符号整数的区别在于最高位被解释为<strong>负权</strong>，举个例子：将<code>1111</code>看做补码的话，它的值就为：-2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup> + 2<sup>0</sup> = -1。</p>
<p>在程序中不可避免的会使用强制类型转换，C 语言中强制类型转换并没有改变数据的位值，只是改变了解释这些位的方式。比如将无符号数（<code>unsigned</code>） 53191 转换为有符号数的结果为 -12345，它们的位值是完全没有相同的。</p>
<p>最容易入坑的地方是，对两个不同类型的数据进行运算时，C 语言将会隐式的将有符号数转换为无符号数，所以就有下面这样一个神奇的结果。</p>
<pre><code class="language-C">// u 代表无符号数
-1 &lt; 0u
// 结果为 0
// 因为 -1 的补码表示为：11...11
// 转换为无符号数后就是范围内最大的数
</code></pre>
<p>如果需要扩展一个数的位表示，那么放心的扩展就好了，小的数据类型都能安全的向大的数据类型转换，补码表示的数会在前面补上符号位，原码表示的直接在前面补上 0 即可，而需要注意的是从大往小转，这会不可避免的截断位，造成信息的丢失，所以千万不要这么干。</p>
<h4 id="加法-乘法运算">加法、乘法运算</h4>
<p>在编程入门的时候可能都知道两个正数相加的结果可能为负数，还有一个更奇怪的现象就是：<code>x &lt; y</code>和 <code>x - y &lt; 0</code>两个表达式可能会得出不一样的结果，这些神奇的结果都和计算机整数的底层表示和运算有着密切的关系。</p>
<p>C 语言中有无符号数与有符号数之分，而在 Java 中只有有符号数，下面的内容还是基于 C 语言进行说明，毕竟更 C 比 Java 更接近底层嘛。</p>
<h6 id="无符号加法">无符号加法</h6>
<p>假设我们使用 w 位来表示无符号数，那么两个加数取值范围即为：0 ≤ x, y ＜2<sup>w</sup>，理论上它们的和的范围为：0 ≤ sum ＜ 2<sup>w+1</sup>，因为只有 w 位表示无符号数（要把和表示出来就需要 w+1 位），所以超过 z<sup>w</sup>的部分就会造成溢出，如下图所示。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569411732520.png" alt=""></figure>
<p>对于无符号数的溢出，计算机采用的处理方式是丢掉最高位，直观的结果就是，当发生溢出了，就将采用取模运算（或者说是减去 2<sup>w</sup>），举个例子。</p>
<p>只用 4 为来表示无符号数，即 w = 4，现在有 x [1001] 和 y [1100] 相加，其结果应为：[10101] ，但是没有 5 位用来表示，所以丢掉最高位的1，剩下的值为 5 [0101]，也就是 21 mod 16 = 5。</p>
<p>那么如何检测是否发生溢出呢？设求和结果为 s，对于加法有 x + y ≥ x 恒成立，即只要没有发生溢出，肯定有 s ≥ x。另一方面，如果确实发生溢出了，就有 s = x + y - 2<sup>w</sup>，又有 y - 2<sup>w</sup> ＜ 0，因此 s = x + y - 2<sup>w</sup> ＜ x。</p>
<h6 id="补码加法">补码加法</h6>
<p>和前面一样，对于两个给定范围的加数 - 2<sup>w-1</sup> ≤ x, y ≤ 2<sup>w-1</sup> - 1，它们的和的范围就在 - 2<sup>w</sup> ≤ sum ≤ 2<sup>w</sup> - 2。要想把整个和的范围表示出来，依旧需要 w+1 位才行，而现在只有 w 位，因此还是需要采用将溢出部分截断。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569411746318.png" alt=""></figure>
<p>可以发现，当发生正溢出时，截断的结果是从和数中减去了 2<sup>w</sup>；而当发生负溢出时，截断结果是把和数加上 2<sup>w</sup>。</p>
<p>那么对于补码加法如何检测溢出结果呢？通过分析可以发现，当且仅当 x ＞ 0, y ＞ 0，但和 s ≤ 0 时为正溢出；当且仅当 x ＜ 0, y ＜ 0，但 s ≥ 0 时发生负溢出。</p>
<h6 id="无符号乘法">无符号乘法</h6>
<p>有了前面的基础，乘法就变得简单一些了，对于溢出情况，计算机仍然采用的是求模，比如 0 ≤ x, y ≤ 2<sup>w</sup> - 1，它们乘积的范围为 0 到 2<sup>2w</sup> - 2<sup>w+1</sup> + 1 之间，这可能需要 2w 位来表示，溢出部分直接截掉，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569411758041.png" alt=""></figure>
<h6 id="补码乘法">补码乘法</h6>
<p>对于补码，两个乘数的范围为：- 2<sup>w-1</sup> ≤ x, y ≤ 2<sup>w-1</sup> + 1，那么其乘积表示范围就为 - 2<sup>2w-2</sup> + 2<sup>w-1</sup> 到 2<sup>2w-2</sup> 之间，补码乘法和无符号乘法基本是一样的，只是在无符号基础上多加了一步转换，即将无符号数转换为补码。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569411788683.png" alt=""></figure>
<h6 id="乘以常数">乘以常数</h6>
<p>我们知道，计算机做加减法、位级运算的速度最快（1 个指令周期），而做乘除法很慢（10 个甚至更多指令周期），平时编写的程序中常常会乘以一个常数，为了使程序运行的更快，编译器可能会帮我们做一些处理。</p>
<p>首先我们考虑常数是 2 的幂。x * 2<sup>1</sup> 可以表示为 <code>x &lt;&lt; 1</code>，x * 2<sup>2</sup> 可以表示为 <code>x &lt;&lt; 2</code>，依次类推即可。</p>
<p>对于不是 2 的幂的常数，比如 x * 14 可以表示为：<code>(x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1)</code>，因为 14 = 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>1</sup>；聪明的你可能发现 14 还有另一种表示方法，即 14 = 2<sup>4</sup> - 2<sup>1</sup>，这种表示比前一种表示方法又少了运算量，所以 x * 14 还可以表示为：<code>(x&lt;&lt;4) - (x&lt;&lt;1)</code>。</p>
<p>实际上，这里有一个通用的解决方案，对于任何一个常数 K，其二进制可以表示为一组 0 和 1 交替的序列：[(0...0)(1...1)(0...0)(1...1)]，14可以表示为：[(0...0)(111)(0)]，考虑一组从位位置 n 到位位置 m 的连续的 1 （n ≥ m），（对于 14 有 n = 3，m = 1）可以有两种形式来计算位对乘积的影响。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569411804705.png" alt=""></figure>
<p>这个优化不是一定的，大多数编译器只在需要少量移位、加减法就足够的时候才使用这种优化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机系统漫游]]></title>
        <id>https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you</id>
        <link href="https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you">
        </link>
        <updated>2019-09-24T16:34:35.000Z</updated>
        <content type="html"><![CDATA[<h4 id="计算机中的信息">计算机中的信息</h4>
<p>对于程序员来说，HelloWorld 程序再熟悉不过了，下面是 C 语言写的 HelloWorld 程序。</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main()
{
	printf(&quot;hello, world\n&quot;);
	return 0;
}
</code></pre>
<p>这段程序很简单，仅仅是在屏幕上输出<code>hello world</code>，对于程序员很容易阅读，但是从计算机的角度来看，也是这么简单吗？</p>
<p>我们都知道，计算机的世界只有 0 和 1组成的位（比特），这对于人类来说太不友好了，因此计算机科学家们设计了 ASCⅡ 码来表示现实世界的符号。每 8 个位构成一个组（称为一个字节），用一个组来表示一个符号，上面的 C 程序用 ASCⅡ 表示就是下面的样式。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569342929650.jpg" alt=""></figure>
<p>因此对于计算机来说，所有的数据都是由一串比特表示的，要区分这些数据对象的唯一方法就是读到它们时的<strong>上下文</strong>。</p>
<pre><code>信息 = 位 + 上下文
</code></pre>
<p>那么什么是上下文呢？举个例子来讲。在磁盘中有一段二进制数据<code>1010010111010010</code>，如果有一段程序将其当做整数读出来（不考虑补码），那么它的值就是 42450，如果把它当做浮点数读出来将是另一个结果，而JVM 将其当做字节码读出来的话，那又是完全不同的结果。只有把位放在具体的程序、环境中（即上下文）才会有意义，单个位是没有意义的。</p>
<h4 id="源程序编译">源程序编译</h4>
<p>虽然我们把 C 语言程序编写完成了，但是它并不能运行，因为它目前还仅仅是由 ASCⅡ 字符构成的文本文件，计算机并不能运行文本文件。</p>
<p>想要得到 HelloWorld 的可执行文件，需要经过预处理、编译、汇编、链接四个阶段。</p>
<p>预处理阶段，预处理器会根据以字符<code>#</code>开头的命令去修改源程序，预处理器去读取系统头文件<code>stdio.h</code>中的内容，并将其直接插入程序文本中，结果就得到了另一个 C 程序—— hello.i。</p>
<p>编译阶段，编译器会把 hello.i 程序翻译成汇编语言程序 hello.s，汇编语言本质上就是机器语言，此时的程序仍然是文本文件。</p>
<p>汇编阶段，汇编器会将 hello.s 翻译成机器语言指令，保存在 hello.o 文件中，此时得到的就是二进制文件了。</p>
<p>程序中使用了 printf 函数，这是由编译器提供的标准 C 库中的函数，它存储在 printf.o 文件中，链接器会将这个文件合并到 hello.o 中，结果就得到一个可执行的 hello 文件，存储于磁盘中。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569342980915.jpg" alt=""></figure>
<h4 id="系统组成及程序运行">系统组成及程序运行</h4>
<p>在运行可执行文件 hello 文件之前，应该先了解一下系统的硬件组成，一个典型系统的硬件组织如下图所示。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569343008278.jpg" alt=""></figure>
<p>为了运行 hello 程序，我们需要在 shell 中输入指令<code>./hello</code>，指令通过键盘经 I/O 总线 --&gt; I/O 桥 --&gt; 总线接口 --&gt; 寄存器 --&gt; I/O 桥存于主存中，当敲击回车键时，等于告诉 shell 程序，命令的属于已经结束， shell 将会执行一系列指令来加载 hello 文件。</p>
<p>利用**直接存取（DMA）**技术，hello 文件不需要通过寄存器就能到达主存，当目标文件 hello 到达主存中，处理器就开始执行 hello 程序的机器指令。其指令即将 &quot;hello, world\n&quot; 字符串的字节从主存复制到寄存器，再从寄存器复制到显示设备中，最终显示在屏幕上面。</p>
<p>我们发现这个简单的 HelloWorld 程序会让系统花费大量的时间把信息从一个地方挪到另一个地方，而我们都清楚，寄存器、主存、磁盘之间的访问速度是相互差了好几个数量级的，而这种复制的开销会严重减慢程序的运行，为了加快这些复制操作的速度，系统设计者就引入了<strong>高速缓存</strong>。</p>
<h4 id="抽象的重要性">抽象的重要性</h4>
<p>计算机科学中最为重要的概念之一就是<strong>抽象</strong>，指令集提供了对硬件处理器的抽象，操作系统同样通过进程、虚拟内存、文件（磁盘、键盘、网络都可以看成文件）这几个抽象概念为应用程序提供简单一致的机制来控制低级硬件设备，同时防止硬件被失控的应用程序滥用。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569343504770.jpg" alt=""></figure>
<p>进程是对正在运行的程序的抽象，在一个系统上可以同时运行多个进程，但是每个进程看起来都好像在独占的使用硬件，CPU 看上去是在并发的执行多个进程，这就需要操作系统进行上下文切换。</p>
<p>在我们还没有输入<code>./hello</code>之前，只有 shell 进程在运行，当我们让其运行 hello 程序时，shell 会通过系统调用来执行我们的请求。操作系统首先保存 shell 进程的上下文（PC、寄存器等信息），然后创建一个新的 hello 进程，并将控制权转交给 hello 进程。</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569343051098.jpg" alt=""></figure>
<h4 id="并发和并行">并发和并行</h4>
<p><strong>并发</strong>是一个通用的概念，指同时具有多个活动的系统；<strong>并行</strong>是指用并发来使一个系统运行的更快，人类都是很懒的，不仅想要计算机能做的更多，还想它效率更高，这样的想法一致促进着技术的前进。</p>
<p>编程的人都知道，为了使程序运行的更快，我们可以编写多线程程序（虽然多线程程序有些难调），在一个进程里面执行多个控制流，线程级的并发可以让计算机运行的更快。</p>
<p>再向底层看看，在计算机体系结构的课堂上都会做<strong>流水线</strong>实验，通过将一条指令划分成不同的步骤，一条指令的执行时间能够从原来的 3~10 个时钟周期，缩短为接近于 1 个时钟周期，这是<strong>指令级的并行</strong>。条件判断和循环结构又会增加指令执行的时钟周期，如果能对这部分知识作深入了解，你编写的程序应该会高一个档次。</p>
<p>除了上面两种并行，还可以使用特殊的硬件，这种硬件可以允许一条指令产生多个可以并行执行的操作，称为<strong>单指令、多数据并行</strong>。</p>
]]></content>
    </entry>
</feed>