<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1581860172763">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1581860172763" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">
                        MySQL 架构与历史
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-16</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql" class="post-tag i-tag
                            i-tag-other_3">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku" class="post-tag i-tag
                            i-tag-other_2">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mysql-jia-gou-yu-li-shi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》
码农翻身知识星球
数据库村的旺财和小强

存储引擎
 Writing a Custom Storage Engine / Overview 中说存储引擎负责管理 MySQL 的数据存储和索引，MySQL 服务器通过已经定义好的 API 与存储引擎进行通信。
不同的存储引擎都有各自的优势和劣势，存储引擎相互之间不会通信，除了 InnoDB 外其它引擎都不会解析 SQL，API 屏蔽了存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎 API 包含了几十个底层函数，下面列举了其中的一小部分函数，如果你要自己实现一个存储引擎，那所做的工作就是把这些接口函数实现。
//创建一个表
virtual int create(const char *name, TABLE *form, HA_CREATE_INFO *info)=0;

//打开一个表
int open(const char *name, int mode, int test_if_locked);

//写入一行数据
int write_row(byte *buf);

//更新一行
int update_row(const byte *old_data, byte *new_data);

//删除一行
int delete_row(const byte *buf);

//开始一个事务
int  start_stmt(THD *thd, thr_lock_type lock_type);

//提交一个事务
int (*commit)(THD *thd, bool all);

//回滚一个事务
int (*rollback)(THD *thd, bool all);

// ......

MySQL 内建了很多存储引擎，除此之外还有很多社区版的第三方引擎，对于这么多引擎我们应该怎么选择呢？这里可以归结为一句话「除非需要用到某些 InnoDB 不具备的特性，并且没有其它办法可以代替，否则都应该选择 InnoDB 引擎」。例如，如果要用到全文索引，建议优先考虑 InnoDB 加上 Sphinx 组合，而不是使用支持全文索引的 MyISAM。当然，如果不需要用到 InnoDB 的特性，同时其它引擎的特性能够更好的满足需求，也可以考虑一下其它引擎。
除非万不得已，否则不要混合使用多种存储引擎。如果应用需要不同的存储引擎，你至少应该考虑「事务」、「备份」、「崩溃恢复」、「特有的特性」几个因素。
并发控制
数据库需要大量的磁盘读写操作，自然而然就会产生并发控制的问题。我们可以简单的使用读写锁来解决解决并发控制问题。读锁是共享的，多个客户可以在同一时刻读取同一个资源；写锁是排他的，一个写锁会阻塞其它写锁和读锁，只有这样才能在同一时间内只有一个用户能执行写入，并防止其它用户读取正在写入的同一资源。
上一段内容只说了锁，但是没有讨论锁的粒度，锁定资源时是直接锁定整个数据库还是仅锁定具体的表，亦或是只锁定要操作的那几行记录？首先我们需要明白的是任何时候，在给定的资源上，锁定的数据量越少则系统的并发程度越高，只要相互之间不冲突即可。
但是我们还忘了另一件事，加锁本身也是需要消耗资源的，获得锁、检查锁的解除、释放锁等等都会增加系统的开销，如果系统花费大量的时间来管理锁，而不是管理数据，那么系统的并发程度同样会受到影响。因此锁策略就是在锁的开销和数据的安全性之间寻求平衡。
大多数商业数据库在锁策略上并没有提供更多的选择，一般都是在表上施加行级锁。MySQL 则提供了多种选择，每种 MySQL 引擎都可以实现自己的锁策略和锁粒度，比较重要的两种锁策略是「表锁」和「行级锁」。
多版本并发控制
刘大在数据库村的旺财和小强中把「事务的隔离级别」和「多版本并发控制（MVCC）」讲的已经比较透彻了，此处我仅借助文字描述来加深我自己的理解。
MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因为避免了加锁的这些开销，所以 MVCC 能够提升并发性能。包括 Oracle、PostgreSQL、MySQL 等等数据库都实现了 MVCC，只是各自的实现机制不一样，因为 MVCC 没有一个统一的实现标准，比较典型的实现方式有「乐观并发控制」和「悲观并发控制」。
MVCC 是通过保存数据在某个时间点的快照来实现的（这难道不是一个版本控制器吗）。以 InnoDB 为例，它是通过在每行记录后面保存两个隐藏的列来实现，一个保存了行的创建时间，另一个则保存了行的过期（删除）时间。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录记录的版本号做比较。
因此根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。因为同一条记录在存储器中拥有多个版本，每个事务也有自己的版本号，只要把事务和记录的版本号做对比即可知道需要取哪个版本的记录了。一言以蔽之，MVCC 是一个借助空间来换取时间的策略。
小知识点
MySQL 使用文件系统的目录和文件来保存数据库和表的定义，所以大小写敏感就和具体的平台密切相关，在 Windows 中大小写不敏感，而在 Linux 等类 Unix 中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但是表的定义则是在 MySQL 服务层统一处理的，my_table表的定义保存会被保存在my_table.frm中。
如果表在创建并导入数据后，不会再对该表进行修改操作，那么这样的表比较适合 MyISAM 压缩表，而且压缩表也支持索引。可以使用myisampack对 MyISAM 表进行压缩，压缩后的表是不能进行修改的，但是可以极大的减少磁盘的空间占用，因此也可以减少磁盘 I/O，这无疑是一种提升查询性能的方法。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">
                        浅析正则表达式原理
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/JYJKwJM69" class="post-tag i-tag
                            i-tag-success">
            #编译原理
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/QjCHA76i_r" class="post-tag i-tag
                            i-tag-banana">
            #编程基础
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/qian-xi-zheng-ze-biao-da-shi-yuan-li.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《编译原理》
实现简单的正则表达式引擎
正则表达式回溯原理
浅谈正则表达式原理

最近在一个业务问题中遇到了一个正则表达式性能问题，于是查了点资料去回顾了下正则表达式的原理，简单整理了一下就发到这里吧；另外也是想试试 Apple Pencil 的手感如何，画的太丑不要嫌弃哈。
有穷自动机
正则表达式的规则不是很多，这些规则也很容易就能理解，但是正则表达式并不能用来直接识别字符串，我们还需要引入一种适合转换为计算机程序的模型，我们引入的就是有穷自动机。
在编译原理中通过构造有穷自动机把正则表达式编译成识别器，识别器以字符串x作为输入，当x是语言的句子时回答是，否则回答不是，这正是我们使用正则表达式时需要达到的效果。
有穷自动机分为确定性有穷自动机（DFA）和非确定性有穷自动机（NFA），它们都能且仅能识别正则表达式所表示的语言。它们有着各自的优缺点，DFA 导出的识别器时间复杂度是多项式的，它比 NFA 导出的识别器要快的多，但是 DFA 导出的识别器要比与之对应的 NFA 导出的识别器大的多。
大部分正则表达式引擎都是使用 NFA 实现的，也有少部分使用 DFA 实现。从我们写正则表达式的角度来讲，DFA 实现的引擎要比 NFA 实现的引擎快的多，但是 DFA 支持的功能没有 NFA 那么强大，比如没有捕获组一类的特性等等。
我们可以用带标记的有向图来表示有穷自动机，称之为转换图，其节点是状态，有标记的边表示转换函数。同一个字符可以标记始于同一个状态的两个或多个转换，边可以由输入字符符号标记，其中 NFA 的边还可以用ε标记。
之所以一个叫有确定和非确定之分，是因为对于同一个状态与同一个输入符号，NFA 可以到达不同的状态。下面看两张图就能明白上面那一长串的文字了。
图中两个圈圈的状态表示接受状态，也就是说到达这个状态就表示匹配成功。细心的你应该发现了两张图所表示的正则表达式是一样的，这就是有穷自动机神奇的地方，每一个 NFA 我们都能通过算法将其转换为 DFA，所以我们先根据正则表达式构建 NFA，然后再转换成相应的 DFA，最后再进行识别。

上图的画法在正则表达式很简单的时候还可以，如果遇到很复杂的正则表达式画起来还是挺费力的，如果想对自动机有更加深入的认识可以自行查阅相关资料。下面的图片是使用正则可视化工具生成的，对应的正则表达式是^-?\d+(,\d{3})*(\.\d{1,2})?$，它所匹配的字符串是数字/货币金额（支持负数、千分位分隔符）。

回溯
NFA 引擎在遇到多个合法的状态时，它会选择其中一个并记住它，当匹配失败时引擎就会回溯到之前记录的位置继续尝试匹配。这种回溯机制正是造成正则表达式性能问题的主要原因。下面我们通过具体的例子来看看什么是回溯。
/ab{1,3}c/




正则
文本




ab{1,3}c
abbbc


ab{1,3}c
abbbc


ab{1,3}c
abbbc


ab{1,3}c
abbbc


ab{1,3}c
abbbc


ab{1,3}c
abbbc



上表中展示的是使用ab{1,3}c匹配abbbc的过程，如果把匹配字符串换成abbc，在第五步就会出现匹配失败的情况，第六步会回到上一次匹配正确的位置，进而继续匹配。这里的第六步就是「回溯」



正则
文本
备注




ab{1,3}c
abbc



ab{1,3}c
abbc



ab{1,3}c
abbc



ab{1,3}c
abbc



ab{1,3}c
abbc
匹配失败


ab{1,3}c
abbc
回溯


ab{1,3}c
abbc




会出现上面这种情况的原因在于正则匹配采用了回溯法。回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。它通常采用最简单的递归来实现，在反复重复上述的步骤后可能找到一个正确的答案，也可能尝试所有的步骤后发现该问题没有答案，回溯法在最坏的情况下会导致一次复杂度为指数时间的计算。
上面一段的内容来源于维基百科，精简一下就是深度优先搜索算法。贪婪量词、惰性量词、分支结构等等都是可能产生回溯的地方，在写正则表达式时要注意会引起回溯的地方，避免导致性能问题。
John Graham-Cumming 在他的博文 Details of the Cloudflare outage on July 2, 2019 中详细记录了因为一个正则表达式而导致线上事故的例子。该事故就是因为一个有性能问题的正则表达式，引起了灾难性的回溯，进而导致了 CPU 满载。
(?:(?:\&amp;quot;|&#39;|\]|\}|\\|\d|(?:nan|infinity|true|false|null|undefined|symbol|math)|\`|\-|\+)+[)]*;?((?:\s|-|~|!|{}|\|\||\+)*.*(?:.*=.*)))

上面是引起事故的正则表达式，出问题的关键部分在.*(?:.*=.*)中，就是它引起的灾难性回溯导致 CPU 满载。那么我们应该怎么减少或避免回溯呢？无非是提高警惕性，好好写正则表达式；或者使用 DFA 引擎的正则表达式。
[0-9] 与 \d 的区别
此问题来源于Stackoverflow，题主遇到的问题是\d比[0-9]的效率要低很多，并且给出了如下的测试结果，可以看到\d比[0-9]慢了差不多一倍。
Regular expression \d           took 00:00:00.2141226 result: 5077/10000
Regular expression [0-9]        took 00:00:00.1357972 result: 5077/10000  63.42 % of first
Regular expression [0123456789] took 00:00:00.1388997 result: 5077/10000  64.87 % of first

出现这个性能问题的原因在于\d匹配的不仅仅是0123456789，\d匹配的是所有的 Unicode 的数字，你可以从 Unicode Characters in the &#39;Number, Decimal Digit&#39; Category 中看到所有在 Unicode 中属于数字的字符。
此处多提一嘴，[ -~]可以匹配 ASCII 码中所有的可打印字符，你可以查看 ASCII 码中的可显示字符，就是从&amp;quot; &amp;quot;（32）至&amp;quot;~&amp;quot;（126）的字符。
工具/资源推荐
正则表达式确实很强大，但是它那晦涩的语法也容易让人头疼抓狂，不论是自己还是别人写的正则表达式都挺头大，好的是已经有人整理了常用正则大全，也大神写了个叫做 VerbalExpressions 的小工具，主流开发语言的版本它都提供了，可以让你用类似于自然语言的方式来写正则表达式，下面是它给出的一个 JS 版示例。
// Create an example of how to test for correctly formed URLs
const tester = VerEx()
    .startOfLine()
    .then(&#39;http&#39;)
    .maybe(&#39;s&#39;)
    .then(&#39;://&#39;)
    .maybe(&#39;www.&#39;)
    .anythingBut(&#39; &#39;)
    .endOfLine();

// Create an example URL
const testMe = &#39;https://www.google.com&#39;;

// Use RegExp object&#39;s native test() function
if (tester.test(testMe)) {
    alert(&#39;We have a correct URL&#39;); // This output will fire
} else {
    alert(&#39;The URL is incorrect&#39;);
}

console.log(tester); // Outputs the actual expression used: /^(http)(s)?(\:\/\/)(www\.)?([^\ ]*)$/

文章大部分内容都是介绍的偏原理方面的知识，如果仅仅是想要学习如何使用正则表达式，可以看正则表达式语法或者 Learn-regex，更为详细的内容推荐看由老姚写的JavaScript 正则表达式迷你书

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">
                        Vue + TypeScript 项目起手式
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-09</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/vue" class="post-tag i-tag
                            i-tag-success">
            #Vue
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/J_3GE6pBm" class="post-tag i-tag
                            i-tag-banana">
            #TypeScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-info">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/vue-typescript-xiang-mu-qi-shou-shi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            在此前我使用的前端框架是 Angular，使用过 TypeScript 后你就会讨厌 JS 了，我学习 Vue 时的最新版本是 2.5，相信大部分同学都不会认为 Vue 那样又细又长的代码很美观吧，简单看了一些网络博客后，我毅然决然引入了 TypeScript 进行开发，本文仅整理记录我自己遇到的一些坑。
使用 Cli
脚手架是一个比较方便的工具，这里需要注意的是@vue/cli和vue-cli是不一样的，推荐使用npm i -g @vue/cli安装。
安装完成后，可以直接使用vue create your-app创建项目，你可以选择使用默认配置亦或是自己手动选择配置，按提示一步一步向下走即可，它会根据你的选择自己创建比如tsconfig.json等等配置文件。这里推荐使用less开发样式，sass老是在安装的过程中出问题。
当然你也可以使vue ui命令启动一个本地服务，它是一个 Vue 项目管理器，提供了一个可视化的页面供你管理自己的项目，它的样子如下图所示，还是比较清新的。

使用 vue-property-decorator
Vue 官方维护了 vue-class-component 装饰器，vue-property-decorator 则是在vue-class-component基础上增强了更多结合Vue特性的装饰器，它可以让 Vue 组件语法在结合了 TypeScript 语法后变得更加扁平化。
截止本文时间，vue-property-decorator共提供了 11 个装饰器和 1 个Mixins方法，下面用@Prop举个例子，是不是看起来引起极度舒适。
import { Vue, Component, Prop } from &#39;vue-property-decorator&#39;

@Component
export default class YourComponent extends Vue {
    @Prop(Number) readonly propA: number | undefined
    @Prop({ default: &#39;default value&#39; }) readonly propB!: string
    @Prop([String, Boolean]) readonly propC: string | boolean | undefined
}


// 上面的内容将会被解析成如下格式

export default {
    props: {
        propA: {
            type: Number
        },
        propB: {
            default: &#39;default value&#39;
        },
        propC: {
            type: [String, Boolean]
        }
    }
}

使用 Vuex
关于怎么使用Vuex此处就不再做过多说明了，需要注意的一点是，如果你需要访问$store属性的话，那么你必须得继承Vue类，坑的地方是在某些情况下即使你没有继承Vue，它也能通过编译，只有在程序运行起来的时候才报错。
class ExampleApi extends Vue {

    public async getExampleData() {
        if (!this.$store.state.exampleData) {
            const res = await http.get(&#39;url/exampleData&#39;);
            if (res.result) {
                this.$store.commit(&#39;setExampleData&#39;, res.data);
                return res.data;
            } else {
            promptUtil.showMessage(&#39;get exampleData failed&#39;, &#39;warning&#39;);
            }
        } else {
            return this.$store.state.exampleData;
        }
    }
}

使用自己的配置（含代理）
vue.config.js是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被@vue/cli-service自动加载，它的配置项说明可以查看配置参考。
我们再开发过程中都会使用代理来转发请求，代理的配置也是在这个文件中，它的官方说明在devserver-proxy中，下面是一个简单的vue.config.js文件例子。
module.exports = {
    filenameHashing: true,
    outputDir: &#39;dist&#39;,
    assetsDir: &#39;asserts&#39;,
    indexPath: &#39;index.html&#39;,
    productionSourceMap: false,
    transpileDependencies: [
        &#39;vue-echarts&#39;,
        &#39;resize-detector&#39;
    ],
    devServer: {
        hotOnly: true,
        https: false,
        proxy: {
            &amp;quot;/statistics&amp;quot;: {
                target: &amp;quot;http://10.7.213.186:3889&amp;quot;,
                secure: false,
                pathRewrite: {
                    &amp;quot;^/statistics&amp;quot;: &amp;quot;&amp;quot;,
                },
                changeOrigin: true
            },
            &amp;quot;/mail&amp;quot;: {
                target: &amp;quot;http://10.7.213.186:8888&amp;quot;,
                secure: false,
                changeOrigin: true
            }
        }
    }
}

让 Vue 识别全局方法和变量
我们在项目中都会使用一些第三方 UI 组件，比如我自己就使用了 Element，但是在使用它的$message、$notify等方法时就直接报错了，究其原因就是$message等属性并没有在 Vue 实例中声明。
官方对此给出了很明确的解决方案，使用的是 TypeScript 的 模块补充特性，可以查看增强类型以配合插件使用。既然知道是因为没有声明导致的错误，那我们就给它声明一下好了，在src/shims-vue.d.ts文件中添加如下代码即可，如果没有该文件请自行创建。

看到网上也有一部分人说的是src/vue-shim.d.ts，反正不管是怎么命名这个文件的，它们的作用是一样的。

declare module &#39;vue/types/vue&#39; {
    interface Vue {
        $message: any,
        $confirm: any,
        $prompt: any,
        $notify: any
    }
}

这里顺道提一下，src/shims-vue.d.ts文件中的如下代码是为了让你的 IDE 明白以.vue结尾的文件是什么玩意儿。
declare module &#39;*.vue&#39; {
    import Vue from &#39;vue&#39;;
    export default Vue;
}


路由懒加载
Vue Router 官方有关于路由懒加载的说明，但不知道为什么官方给的这个说明在我的项目里面都没有生效，但使用require.ensure()按需加载组件可以生效。
// base-view 是模块名，写了相同的模块名则代码会被组织到同一个文件中
const Home = (r: any) =&amp;gt; require.ensure([], () =&amp;gt; r(require(&#39;@/views/home.vue&#39;)), layzImportError, &#39;base-view&#39;);

// 路由加载错误时的提示函数
function layzImportError() {
    alert(&#39;路由懒加载错误&#39;);
}

上面的方式会在编译的时候把文件自动分成多个小文件，编译后的文件会以你自己命名的模块名来命名，如果代码之间有相互依赖，依赖部分代码编译后的文件会以两个模块名相连后进行命名。
但是需要注意的是，这样拆分小文件之后引入了另外一个新的问题，因为客户端会缓存这些编译后的 js 文件，如果功能 A 同时依赖了a.js和b.js两个文件，但用户在使用其它功能时已经把a.js缓存到本地了，使用功能 A 时需要请求b.js文件，这时程序就很容易报错，因为此时在客户端这两个文件不是同一个版本，所以可能导致a.js调用b.js中的方法已经被删了，进而导致客户端页面异常。
关于引入第三方包
项目在引入第三方包的时候经常会报出各种奇奇怪怪的错误，这里仅提供我目前找到的一些解决办法。
/*
 引入 jquery 等库可以尝试下面这种方式
 只需要把相应的 js 文件放到指定文件夹即可
**/
const $ = require(&#39;@/common/js/jquery.min.js&#39;);
const md5 = require(&#39;@/common/js/md5.js&#39;);

引入一些第三方样式文件、UI 组件等，如果引入不成功可以尝试建一个 js 文件，将导入语句都写在 js 文件中，然后再在main.ts文件中导入这个 js 文件，这个方法能解决大部分的问题。例如我先建了一个lib.js，然后在main.ts中引入lib.js就没有报错。
// src/plugins/lib.js
import Vue from &#39;vue&#39;;

// 树形组件
import &#39;vue-tree-halower/dist/halower-tree.min.css&#39;;
import {VTree} from &#39;vue-tree-halower&#39;;
// 饿了么组件
import Element from &#39;element-ui&#39;;
import &#39;element-ui/lib/theme-chalk/index.css&#39;;
// font-awesome 图标
import &#39;../../node_modules/font-awesome/css/font-awesome.css&#39;;
import VueCookies from &#39;vue-cookies&#39;;
import VueJWT from &#39;vuejs-jwt&#39;;

Vue.use(VueJWT);
Vue.use(VueCookies);
Vue.use(VTree);
Vue.use(Element);


// src/main.ts
import App from &#39;@/app.vue&#39;;
import Vue from &#39;vue&#39;;
import router from &#39;./router&#39;;
import store from &#39;./store&#39;;
import &#39;./registerServiceWorker&#39;;
import &#39;./plugins/lib&#39;;

Vue.config.productionTip = false;

new Vue({
    router,
    store,
    render: (h) =&amp;gt; h(App),
}).$mount(&#39;#app&#39;);

因为第三方包写的各有特点，在引入不成功的时候基本也只能是见招拆招，当然如果你的功底比较深厚，你也可以自己写一个index.d.ts文件，实在不行的话，那个特殊的组件不使用 TypeScript 来写也能解决，我目前还没有找一个可以完全解决第三方包引入错误的方法，如果您已经有相关的方法了，希望能与你一起探讨交流。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/2019-nian-zong-jie">
                        2019 年个人总结
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-06</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/EE1uiCHgH" class="post-tag i-tag
                            i-tag-error">
            #个人总结
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/2019-nian-zong-jie">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/2019-nian-zong-jie.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            写总结的习惯是从 2015 年开始的，我的大学学费是县政协资助的，叔叔阿姨们唯一的要求就是每年给他们写个总结汇报一下学习情况，毕业后敦促我写总结的人则从外力转为内心。
一点感动
上半年我还很年轻，那时候还会经常使用 QQ、Soul、同桌、一罐 等等社交产品，无意结识了一个还在读高中的同性恋女孩子，我没学过心理学不知道用什么专业名词描述她的情况，反正就是心理上有严重的问题，玻璃心、想自杀等等。几次拼了我老命陪她聊到半夜两三点，现在完完全全能正视自己的情况了。
让我感动的是有次她问我在干啥，我随便拍了一张自己的被汗水打湿衣服发给她，告诉她自己正在打羽毛球。小姑娘给我说我穿的衣服不好看，说我才多大穿的衣服太老了，我也就随口一说叫她给我这个老年人推荐推荐衣服，因为她要上课后面就一直没有回我消息。
第二天早上睡醒了看到了小姑娘的几十条消息，是半夜两点多发的，给我挑了好几件衣服裤子，还给我画了几张示意图（如下），瞬间收获一份小感动。我也遵从小姑娘的意见买了两件上班穿穿，结果一到部门就是众目睽睽之下给我说穿的好酷，穿几次了都还是会引来大家不一样的目光，个性低调的我还是选择走大众程序员路线，老就老吧。


前几天小姑娘给我发了她暗恋的小姐姐的照片，虽然极少时候还是会上课偷偷玩手机，但也在努力的备战高考。我做的不好的就是她多次给我讲自己在龙岗，我每次都把她当成龙华的，希望写了这篇总结之后不再记错吧。
赚钱理财
这个小标题起的有点大，仅说说我自己的实际情况吧。凭着运气，2019 年的银行理财收益在 4.5% 左右，基金收益在 7% 左右。我没有去玩股票，网上各种理财课程可能都会给你讲股票的收益多么多么高，但是他们从来不会给你说玩股票的风险有多高，更不可能给你讲玩股票会严重影响自己的心情，可能连自己的本职工作都会搞砸，所以我不建议职场新人进入股市。
房东忙的时候我会帮他带房客看房，他也给了我小几千块钱的介绍费，加上每个月没交网费直接用他的，还时不时蹭蹭房东的饭局，也给自己省下来周末出去散步的费用了。上半年也给别人分享过两三个课程，在群里分享过一点小技能，大家给发了点红包，交个朋友、图个开心。
总的来讲，理财这方面做得很差，没有花什么时间去学习，我们的大学也没有教给学生一点金融知识，这一年只读了几本写给小白的理财书，今年在这个领域要多花一点功夫，希望能入得了门吧。
写书失败
快要毕业的时候和电子工业出版社签了一份合同，合同内容就是我要写一本叫做《知识图谱：自顶向下方法》，这本书的计划内容是我的毕业设计，已经写了一百多页的内容了，但现在确定以失败告终。
一者我手里现有的数据属于机密数据，没办法拿来直接使用；二来书中有很大一部分内容涉及到网络爬虫，上半年网上曝了很多因为抓数据而入狱的案例，出版社和我都害怕；三者知识图谱所需要的数据量很大，而且我写的那个领域又是中国特有的经济责任审计领域，大量数据都得从政府网站来，更害怕了；最重要的原因是自己懒，写书的那几个月确实非常的累，想想自己都还是个菜鸟呐，有啥资本教给别人知识，心里给了自己后退的理由。
小时候曾夸下海口说要给父亲写个传记，也不知道有没有那么一丢丢可能性实现，写家里的狗时，发现写这样的内容会增加我的多巴胺分泌，以后不开心了就写这样的小故事。
运动健身
在深圳校友会骑行社师兄师姐们的带领下，同时也得益于一起入职的小伙伴送了我一辆 MERIDA，我喜欢上了骑行这项运动，基本上每周五都会出去骑几十公里，中间还参加了环漓江骑行和 TREK100 骑行，锻炼的同时也见到了美丽的风景。深圳对自行车是不太友好的，基本没有什么自行车道，所以我们大部分时间都是等到晚上车少，交警下班了之后才开始骑行。
除了骑行每周一也会打两小时羽毛球，谈不上专业，但至少打的不再是广场球了。偶尔也会出去爬爬山啥的，身体确实比上学时候要好很多，而且多锻炼能让自己的精神面貌更好，精气神好也能稍稍掩盖长得丑的缺点。以前每年再怎么也会因为感冒一类的问题进几次医院，19 年仅一次因为智齿发炎去过医院。
削减迷茫
大概在四五月份的时候吧，几乎天天失眠，经常夜里只睡了三四个小时，有时甚至通宵未眠，心里很清楚是因为迷茫了，大概就是「晚上想了千条路，早上醒来走原路」的状态。好在自己的调节能力还不算差，同时也有楼下的叔叔、自己的好朋友能唠唠嗑，差不多两个月就回归正常状态了。
从几个比我晚入职半年的小伙伴那里了解到，他们现在的情况和我四五月份的情况差不多，我想绝大部分普通人都会经历这个迷茫期吧，大部分人也都能通过时间调节过来，调节不过来的那部分人就成为了媒体比较喜欢的人。
现在迷茫的雾气已经没有那么浓了，初入社会肯定有很多的不成熟，但谁不是这样过来的呢？更何况我并不像多数程序员那样交友严重同质化，周末也不会死宅在家里不出去，猜测我应该比大多数人更潇洒自在的，嘿嘿。
新的思想
大家基本都是看着金庸武侠小说（相关影视作品）长大的，没有人写武侠小说能超过金庸。偶然一天在推特上刷到一条评论，大意是：没有人写武侠小说能超过金庸不正代表着社会的进步吗？金庸的成就如此巨大，一个很重要的历史背景是那时候大家没有那么多小说可看呀，哪里像今天遍地的网络小说。咱们没必要去争论这个观点的对错，重要的是它告诉了我们一个不一样的角度去看待问题。
上面只是一个特例，思维方式是一点一点改变的，认知水平是一点一点提升的，一年时间修正了不少我此前狭隘的观点，这样的修正还在继续，我也会让这样的修正持续下去。
写在最后
巴黎圣母院被烧、凉山火灾、女排十连冠、NBA 事件、无锡高架桥倒塌......等等发生在 2019 年的大事，不知道还有多少朋友会记起来。时间从来不会等谁，网友也都是不长记性的，成熟的一部分无非是经历的多了，失望的多了，然后变得更耐操一点，总之生活依旧得继续，人总会亦悲亦喜，那为啥不把悲缩小喜放大呢？
成功没有银弹、没有捷径，少讲大道理，多解决小问题。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/2019-nian-zong-jie">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men">
                        MongoDB 聚合入门
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-04</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku" class="post-tag i-tag
                            i-tag-error">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mongodb-ju-he-ru-men.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            MongoDB 聚合官方文档
聚合管道是一个基于数据处理管道概念建模的数据聚合框架，文档进入一个多阶段的处理管道，该管道最终将其转换为聚合后的结果。
下面的例子来源于官方文档。第一阶段，$match按status字段来过滤文档，并把status字段值为A的文档传递到下一阶段；第二阶段，$group将文档按cust_id进行分组，并针对每一组数据对amount进行求和。
db.orders.aggregate([
   { $match: { status: &amp;quot;A&amp;quot; } },
   { $group: { _id: &amp;quot;$cust_id&amp;quot;, total: { $sum: &amp;quot;$amount&amp;quot; } } }
])

管道

聚合管道包含很多步骤，每一步都会将输入的文档进行转换，但并不是每个阶段都一定需要对每个输入文档生成一个输出文档，比如某些阶段可能生成新的文档或者过滤掉文档。
除了$out、$merge、$geoNear外，其它的阶段都可以在管道中多次出现，更加详细的内容可以查看 Aggregation Pipeline Stages。

管道表达式
一些管道阶段采用表达式作为操作元，管道表达式指定了要应用到输入文档的转换，表达式自己是一个文档结构（JSON），表达式也可以包含其它的表达式。
表达式仅提供文档在内存中的转换，即管道表达式只能对管道中的当前文档进行操作，不能引用来自其他文档的数据。
写聚合表达式式建议直接参考官方文档，下面列出一些我收集的案例，供深入理解使用。
案例一：将对象数组转换为单个文档
// 转换前
{
    &amp;quot;_id&amp;quot;: &amp;quot;10217941&amp;quot;,
    &amp;quot;data&amp;quot;: [
        {
            &amp;quot;count&amp;quot;: 2,
            &amp;quot;score&amp;quot;: &amp;quot;0.5&amp;quot;
        },
        {
            &amp;quot;count&amp;quot;: 6,
            &amp;quot;score&amp;quot;: &amp;quot;0.3&amp;quot;
        },
        {
            &amp;quot;count&amp;quot;: 5,
            &amp;quot;score&amp;quot;: &amp;quot;0.8&amp;quot;
        }
    ]
}

// 转换后
{
    &amp;quot;_id&amp;quot;: &amp;quot;10217941&amp;quot;,
    &amp;quot;0.3&amp;quot;: 6,
    &amp;quot;0.5&amp;quot;: 2,
    &amp;quot;0.8&amp;quot;: 5
}

需要说明的是，如果上面data属性中的数据格式为{&amp;quot;k&amp;quot;: &amp;quot;0.6&amp;quot;, &amp;quot;v&amp;quot;: 5}，那么下面的聚合表达式就不需要$map，这一点可以查看 $arrayToObject。这个案例的难点在于score中有小数点，这个小数点会让聚合表达式懵逼的。
db.collection.aggregate([
    {
        &amp;quot;$addFields&amp;quot;: {
            &amp;quot;data&amp;quot;: {
                &amp;quot;$arrayToObject&amp;quot;: {
                    &amp;quot;$map&amp;quot;: {
                        &amp;quot;input&amp;quot;: &amp;quot;$data&amp;quot;,
                        &amp;quot;as&amp;quot;: &amp;quot;item&amp;quot;,
                        &amp;quot;in&amp;quot;: {
                            &amp;quot;k&amp;quot;: &amp;quot;$$item.score&amp;quot;,
                            &amp;quot;v&amp;quot;: &amp;quot;$$item.count&amp;quot;
                        }
                    }
                }
            }
        }
    },
    {
        &amp;quot;$addFields&amp;quot;: {
            &amp;quot;data._id&amp;quot;: &amp;quot;$_id&amp;quot;
        }
    },
    {
        &amp;quot;$replaceRoot&amp;quot;: {
            &amp;quot;newRoot&amp;quot;: &amp;quot;$data&amp;quot;
        }
    }
]);


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">
                        用户关注而程序员不关注的事
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-12-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/vhSkGeYf1D" class="post-tag i-tag
                            i-tag-other_2">
            #设计
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
原文：Things end users care about but programmers don&#39;t

色彩

改变元素的颜色
漂亮的默认调色板
使用我喜欢的调色板
导入/导出颜色主题
一些标识符、关键字等应该始终具有特定的颜色
同一事物在任何地方都应颜色一致
具有适宜的对比度
切换深色/浅色背景时，自动调整对比度以适应当前背景
自动生成大量颜色

所有的颜色都属于同一个系列
不生成不易辨别的颜色
相似的颜色不要放在一起
不要将背景色用在元素上



格式

将基本格式应用于文本
文本对齐
使用我在 office 中使用的字体
类似于 Word 中的 WYSIWYG 编辑器
数字对齐
数字/日期自动根据语言环境设置格式
小数设置为右边有固定小数位
在任何地方都没有奇怪的 .0000004 格式
整数后面不应该有 .00
支持 Emoji

主题

深色主题
我的主题
公司品牌
将 logo 放在合适的位置
在登录页面有 logo

系统整合

与账户系统整合
使用 Active Directory 中的账户/权限
导入 Excel/CSV
从电子邮件附件导入
导出为 Excel
导出为 PDF/图像
录制短片

制作 gif


作为邮件发送

定期发送邮件
以 PDF 附件形式发送邮件


导入/附加图像

上传前裁剪
压缩
变更格式


使用图像作为背景，并且以正确的方式拉伸
APP 上的通知

在手机的应用程序上
通过短信
在我们的系统上
在我的邮箱



用户体验

良好的错误处理
简洁的错误描述

翻译错误信息


告诉我如何做才能解决错误
在我点击前告诉我会发生什么
支持手势和鼠标
快捷键

支持自定义


任何时间都可以撤销
支持多次撤销
恢复已被删除的东西
在删除前给提示
复制与粘贴
模板
详细的用户指南，并且每一步都有截图与重点标注

在视频中
截图随着产品的发布保持更新
与我正在使用的版本同步
适应我的自定义设置


最新的详细文档
自动翻译为我的语言（国际化）
任何地方都支持排序

自然排序
根据多个条件排序


任何地方都支持过滤器

模糊匹配
大小写敏感/不敏感过滤
按多个复杂条件筛选


记录历史操作，在我删除时给出警告
可选的级联删除
在每个平台本机都提供简单的日期选择器
对列表/已经项排序（按标签）

自然排序


带有过滤功能的下拉菜单
预览
一致的按钮排序/标签
一致的大小写
慢速操作显示进度条
缓慢操作时 UI 可以快速响应
响应缓慢时禁用按钮
处理应单击元素的双击事件
明确指示可以单击的内容

兼容性

可在其它系统部署
可在旧的/不支持的版本上部署
在我拥有的任何系统上都可部署
不需要网络就可部署
处理 Excel, CSV, JSON, XML

处理以上所有格式不正确的版本


处理（猜测）没有时区的日期
处理模糊的/被更改的日期格式
可与过时的软件混合
可以在旧安卓的浏览器工作
编码

处理具有未知和可变编码的输入



操作

易安装
易更新
易备份
易恢复
可与我们所使用的的数据库版本一起工作
可以挂载在非根路径


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi">
                        刘小绪同学随笔（2019-12-15）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-18</time>
                    
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/liu-xiao-xu-tong-xue-sui-bi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            利用周末时间到成都走了走，见到了四五年没见的三个高中同桌，心中甚是欢喜。在去往成都的途中，与我挨着的乘客是一个彝族同胞，她在东莞的一个纺织厂做衣服，这次请了两个月的假，回家与家人团聚过年。彝族的「年」叫做「库斯」，现在定在每年的 11 月 20 日，出于对不了解文化的好奇，我加了小姑娘的微信，天天都能看到他们的村民盛装举办各种活动，让我明年此时到凉山州走一走的想法愈发强烈。
四五年的时间让我和同学产生了很大的差异，他们做菜都超级棒，而我做的菜可能也只有自己才能忍着吃下去，找到了两点原因。一者成都的房子大部分都很适合做饭，空间很大，给了足够大的舞台让你展现厨艺，同等配置的房子在深圳需要成都两到三倍的租金；二者成都加班时间远比深圳少的多，同学说他有时候会加班到七点，而深圳大部分公司七点应该算正常下班时间，因此在成都的超市我看到了很多年轻人在买菜也就不足为奇了。

前两天在微信朋友圈看到一篇《香港问题和世界真相》，以前也看到过类似标题的一些文章，那时候还会花些时间去读一读，最近愈发觉得微信公众号咋这么多人才呢？不管多么深奥的问题都能在公众号上找到答案，还引经据典讲的神乎其神，一篇公众号文章就能把科学家解决不了的问题全给解决了，实乃圣人也，我更愿意做一个俗人！
微信公众号可能是国内在保护原创这块做的最好的平台，但是其缺点也并不少。现在能看到很多作者变成了公众号平台的写作苦力，在微信公众号的机制下，你需要一直更新才能积累人气，很少有人持续输出高质量的内容，那些还没毕业或是刚毕业几年的小孩子更加不可能做到。
公众号是一个封闭的平台，搜索引擎无法检索到公众号的文章，这一点和互联网开放共享的思想是相违背的。公众平台提供的改几个错别字功能，远远不够纠正文章中引入的错误。以前我把公众号当个记事本，但是有一次因为说了不该说的话，直接给我封号了，连自己的历史文章都看不了，好在最后给解封了，赶紧把文章都备份下来。
去年十月份有个那么一周很多公众号都在推荐一个写作课，是几个 90 后开的写作课，其中一个的微信昵称是「九爷」，课程内容大致就是自媒体写作赚钱；而最近我微信朋友圈莫名出现了一个昵称为「宝藏女孩买买提」的人天天发京东各种商品的抢购链接，点进去看才发现这就是去年的那个「九爷」，心想这女生变得也太快了吧，何况我还不能百分百确定是女生，还是赶紧删掉好！

上面两个片段已经写完一个多月了，这一个多月没有找到什么片段可以凑到这里来，那就水一把说自己经历的一个小事吧。学长是做体育赛事直播的，他们公司举办了一个 2-4 岁儿童的骑跑比赛，我被学长抓壮丁去帮他在现场奖品和完赛纪念品，有一个家长给我的印象非常深刻。
一位妈妈在我这里领完纪念品后，一下扔到地上气冲冲的走了，孩子的表情我形容不出来，自己去把纪念品捡起来，但也没有去追妈妈。我本以为是我们哪里做的不对致使她那么大火气，结果一了解才知道是因为孩子比赛成绩太差了，自己家孩子赶不上别家孩子给气的。
上面那件事情不作评论，毕竟这一个片段是用来凑字数的，那就得有凑字数的样子。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                        Linux 中的零拷贝技术
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-18</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-error">
            #Linux
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-other_2">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/linux-zhong-de-ling-kao-bei-ji-zhu.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Two new system calls: splice() and sync_file_range()
Linux 中的零拷贝技术1
Linux 中的零拷贝技术2
Zero Copy I: User-Mode Perspective
Linux man-pages splice()

此前在Nginx 文件操作优化中有提到零拷贝技术，它可以有效的改善数据传输的性能，但是由于存储体系结构非常复杂，而且网络协议栈有时需要对数据进行必要的处理，所以零拷贝技术有可能会产生很多负面影响，甚至会导致零拷贝技术自身的优点完全丧失。
零拷贝就是一种避免 CPU 将一块存储拷贝到另一块存储的技术。它可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率，而且零拷贝技术也减少了内核态与用户态之间切换所带来的开销。进行大量的数据拷贝操作是一件简单的任务，从操作系统的角度来看，如果 CPU 一直被占用着去执行这项简单的任务，是极其浪费资源的。如果是高速网络环境下，很可能就出现这样的场景。
零拷贝技术分类
现在的零拷贝技术种类很多，也并没有一个适合于所有场景的零拷贝零拷贝技术，概括起来总共有下面几种：


直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统只是辅助数据传输，这类零拷贝技术可以让数据在应用程序空间和磁盘之间直接传输，不需要操作系统提供的页缓存支持。关于直接 I/O 可以参看Linux 中直接 I/O 机制的介绍。


避免数据在内核态与用户态之间传输：在一些场景中，应用程序在数据进行传输的过程中不需要对数据进行访问，那么将数据从页缓存拷贝到用户进程的缓冲区是完全没有必要的，Linux 中提供的类似系统调用主要有mmap()、sendfile()和splice()。


对数据在页缓存和用户进程之间的传输进行优化：这类零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统页缓存之间的拷贝操作，此类方法延续了传统的通信方式，但是更加灵活。在 Linux 中主要利用了「写时复制」技术。


前两类方法的目的主要是为了避免在用户态和内核态的缓冲区间拷贝数据，第三类方法则是对数据传输本身进行优化。我们知道硬件和软件之间可以通过 DMA 来解放 CPU，但是在用户空间和内核空间并没有这种工具，所以此类方法主要是改善数据在用户地址空间和操作系统内核地址空间之间传递的效率。
避免在内核与用户空间拷贝
Linux 主要提供了mmap()、sendfile()、splice()三个系统调用来避免数据在内核空间与用户空间进行不必要的拷贝，在Nginx 文件操作优化对sendfile()已经做了比较详细的介绍了，这里就不再赘述了，下面主要介绍mmap()和splice()。
mmap()
当调用mmap()之后，数据会先通过 DMA 拷贝到操作系统的缓冲区，然后应用程序和操作系统共享这个缓冲区，这样用户空间与内核空间就不需要任何数据拷贝了，当大量数据需要传输的时候，这样做就会有一个比较好的效率。
但是这种改进是需要代价的，当对文件进行了内存映射，然后调用write()系统调用，如果此时其它进程截断了这个文件，那么write()系统调用将会被总线错误信号SIGBUG中断，因为此时正在存储的是一个错误的存储访问，这个信号将会导致进程被杀死。
一般可以通过文件租借锁来解决这个问题，我们可以通过内核给文件加读或者写的租借锁，当另外一个进程尝试对用户正在进行传输的文件进行截断时，内核会给用户发一个实时RT_SIGNAL_LEASE信号，这个信号会告诉用户内核破坏了用户加在那个文件上的写或者读租借锁，write()系统调用就会被中断，并且进程会被SIGBUS信号杀死。需要注意的是文件租借锁需要在对文件进行内存映射之前设置。
splice()
和sendfile()类似，splice()也需要两个已经打开的文件描述符，并且其中的一个描述符必须是表示管道设备的描述符，它可以在操作系统地址空间中整块地移动数据，从而减少大多数数据拷贝操作。适用于可以确定数据传输路径的用户应用程序，不需要利用用户地址空间的缓冲区进行显示的数据传输操作。
splice()不局限于sendfile()的功能，也就是说sendfile()是splice()的一个子集，在 Linux 2.6.23 中，sendfile()这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过内部已经使用了splice()这种机制来实现了。
写时复制
在某些情况下，Linux 操作系统内核中的页缓存可能会被多个应用程序所共享，操作系统有可能会将用户应用程序地址空间缓冲区中的页面映射到操作系统内核地址空间中去。如果某个应用程序想要对这共享的数据调用write()系统调用，那么它就可能破坏内核缓冲区中的共享数据，传统的write()系统调用并没有提供任何显示的加锁操作，Linux 中引入了写时复制这样一种技术用来保护数据。
写时复制的基本思想是如果有多个应用程序需要同时访问同一块数据，那么可以为这些应用程序分配指向这块数据的指针，在每一个应用程序看来，它们都拥有这块数据的一份数据拷贝，当其中一个应用程序需要对自己的这份数据拷贝进行修改的时候，就需要将数据真正地拷贝到该应用程序的地址空间中去，也就是说，该应用程序拥有了一份真正的私有数据拷贝，这样做是为了避免该应用程序对这块数据做的更改被其他应用程序看到。这个过程对于应用程序来说是透明的，如果应用程序永远不会对所访问的这块数据进行任何更改，那么就永远不需要将数据拷贝到应用程序自己的地址空间中去。这也是写时复制的最主要的优点。
写时复制的实现需要 MMU 的支持，MMU 需要知晓进程地址空间中哪些特殊的页面是只读的，当需要往这些页面中写数据的时候，MMU 就会发出一个异常给操作系统内核，操作系统内核就会分配新的物理存储空间，即将被写入数据的页面需要与新的物理存储位置相对应。它最大好处就是可以节约内存，不过对于操作系统内核来说，写时复制增加了其处理过程的复杂性。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                        Vim 常用命令快速查询
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-01</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/vim" class="post-tag i-tag
                            i-tag-other_1">
            #Vim
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-banana">
            #Linux
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/vim-chang-yong-ming-ling-kuai-su-cha-xun.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容
Learning Vim The Pragmatic Way
《鸟哥的 Linux 私房菜》

Vim 可以认为是 Vi 的高级版本，Vim 可以用颜色或下划线的方式来显示一些特殊信息，您可以认为 Vi 是一个文本处理工具，而 Vim 是一个程序开发工具，现在大部分 Linux 的发行版都以 Vim 替换 Vi 了。在 Linux 命令行模式下有很多编辑器，但是 Vi 文本编辑器是所有 Unix-like 系统都会内置的，因此学会 Vi/Vim 的使用时非常有必要的，对于 Vi 的三种模式（命令模式、编辑模式、命令行模式）这里就不在做说明了，下面是一些比较常用的命令。
一般命令模式下



命令
说明




h、j、k、l
与键盘的方向键一一对应，分别为左、下、上、右，在键盘上着几个字母是排在一起的


Ctrl+f、Ctrl+b
分别对应键盘的「Page Down」、「Page Up」，我更习惯于这两个键，而不是前面的组合键


0、$
分别对应键盘的「Home」、「End」，即移动到该行的最前面/后面字符处


n&amp;lt;Enter&amp;gt;
n 为数字，光标向下移动 n 行


/word、?word
向光标之上/下寻找一个字符串名称为 word 的字符串


n、N
如果我们刚刚执行了上面上面的 /word 或 ?word 查找操作，那么 n 则表示重复前一个查找操作，可以简单理解为向下继续查找下一个名称为 word 的字符串，N 则与 n 刚好相反


:n1,n2s/word1/word2/g
在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将这个字符串替换为 word2，如果前面的 n1,n2 使用 1,$ 代替则表示从第一行到最后一行，最后的 g 后面可以加个 c，即 :1,$s/word1/word2/gc，这样就会在替换钱显示提示字符给用户确认（confirm）


x、X
分别对应键盘的「Del」、「Backspace」键


dd、yy
删除/复制光标所在的那一整行


p、P
p 将已复制的数据在光标下一行粘贴，P 粘贴在光标上一行


u
恢复前一个操作，类似于 Windows 下的 Ctrl+Z


Ctrl+r
重做上一个操作


.
小数点，重复上一个操作



命令行模式下



命令
说明




:w
将编辑的数据写入硬盘中


:w!
若文件属性为只读，强制写入该文件，不过到底能不能写入，还是跟文件权限有关系


:q、:q!
与 w 一样，q 为关闭的意思


:r [filename]
在编辑的数据中读入另一个文件的数据，即将[filename]这个文件的内容追加到光标所在行的后面


:w [filename]
将编辑的数据保存为另一个文件


:set nu/nonu
显示/不显示行号



编辑模式下



组合键
作用




[ctrl]+x -&amp;gt; [ctrl]+n
通过目前正在编辑的这个文件的内容文字作为关键字，予以自动补全


[ctrl]+x -&amp;gt; [ctrl]+f
以当前目录内的文件名作为关键字补全


[ctrl]+x -&amp;gt; [ctrl]+o
以扩展名作为语法补充，以 Vim 内置的关键字予以补全



当我们在使用 Vim 编辑器的时候，Vim 会在与被编辑的文件目录下再建立一个名为.filename.swp的文件，我们对文件的操作都会记录到这个 swp 文件中去，如果系统因为某些原因掉线了，就可以利用这个 swp 文件来恢复内容。如果存在对应的 swp 文件，那么 Vim 就会主动判断当前这个文件可能有问题，会给出相应的提示。
我们也可以给 Vim 环境设置一些个性化的参数，虽然在命令行模式下可以使用:set来设置，但是这样每次设置实在是太麻烦，因此我们可以设置一些全局的参数。Vim 的整体设置值一般放在/etc/vimrc中，我们一般通过修改~/.vimrc这个文件（默认不存在）来设置一些自己的参数，比如：
&amp;quot; 该文件的双引号是注释
set nu &amp;quot;在每一行的最前面显示行号
set autoindent &amp;quot; 自动缩进
set ruler &amp;quot; 可显示最后一行的状态
set bg=dark &amp;quot; 显示不同的底色色调
syntax on &amp;quot;进行语法检验，颜色显示，比如 C 语言等

最后附上一张命令速查卡，此图来源于Learning Vim The Pragmatic Way，PDF 版下载链接在这里。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
                        刘小绪同学随笔（2019-10-28）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-28</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-success">
            #随笔
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/liu-xiao-xu-tong-xue-sui-bi-2019-10-28.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            分享一个视频：施利伦法，利用折射率的不同使肉眼不可见的物质可视化，我把它下下来了，如下：


在一位做酱香酒的朋友那里学了个鉴别真伪飞天茅台的方法，我不会喝酒所以没什么研究，实用性还请读者大人自行判断，反正我喝茅台的感觉与喝二锅头差不多，到嘴里都是一个味。
方法一：如果「酒」字里面的那一横，是图一的那个样子，那是真酒；而如果是图二的样子则是假酒。


方法二：在如图左边仙女标红圈那个位置，如果线条的交汇点是穿出去的，则为真，反之为假。



看了2019·菠萝科学奖颁奖典礼，一个沙雕、严谨、有趣......的节目，处处都透漏着尴尬又不失礼貌的微笑，永远向好奇心致敬。我个人认为这个节目最大的优点就是把常人眼里那种无趣、严谨的科学以一种有趣的方式呈现出来，这可以让大多数人更喜欢科学，让科学家在科研的道路上坚持的更久。
在怎样才能开开心心的呢中有提到过降低对事物的期望值，这里再详细谈一下降低期望值对学习的促进作用。以这两年大量冒出来的线上英语阅读打卡为例，只要打卡多少天就有小礼物，全勤甚至可以返还学费，这么一想那公司还怎么赚钱呢？原因就在于绝大部分人都只能坚持短短的几天，和健身卡的套路基本一致。
我想读者大人肯定都知道复利曲线，其实并不需要给自己定多么多么高远的目标，只需要每天坚持花一点时间一直去做，就能达到复利曲线的效果。之所以坚持不下去无非是因为学习很痛苦，而如果把学习变成像玩游戏一样有趣，那你肯定不会拒绝学习。比如上面说的英语学习，每天去背单词没几个人坚持的下来，那如果是每天看一集美剧呢？
人是需要被成就感驱动的，给自己一下定的目标太高很容易就气馁了，降低自己的期望值，把目标定小一点点，说不定每天都可以获得满满的成就感，配上一些有趣的方式、方法，学习这件事做起来简直妙不可言，其它事情也是一样的道理。

最近取关了很多公众号，互联网时代不得不承认网上的好文不少，但是大部分人都没有那么多精力去读完，与其走马观花的读一遍，我更愿意精读一篇文章后再从中挖掘信息。之前一直不肯取关一些公众号，总是觉得某天会有个重要信息从那里得到，刘未鹏老师说这是源于人「不肯关上一扇门」的心理，而实际关上一扇门可能增大我们的收益，注意力不至于被滑不到底的信息流骚扰。读过了却不一定领悟了，愈发赞同人与人学习的差距不在资质上，而在于花在思考上的时间与思考的深度。
同样为了不让太多事物让自己分心，我周末也花了些时间把很久没用的东西，很久没有穿的衣物等等都扔了，屋子一下显得宽敞了许多，忘记此前在哪里看到一篇文章有讲太多的家具会让自己分心，不过当时是找了一圈没舍得扔，因为每一件物品我好像总能想到它在某个场景下的作用，而现实情况是那些场景可能是我幻想出来的，或者当那个场景出现的时候，对应的物品也因为放的太久而无法使用了，还不如扔了算了。

下面是一些比较有意思的文章。
tylervigen.com 专门收集那些看起来高度相关但实际上毫不相关的数据，比如美国在科学、太空、技术方面的投入，与采用上吊、勒死、窒息方式自杀的案例，这两组数据之间的相关性高达 99.79% 。
https://bruno-simon.com 是一个超酷的网站主页，网站的源码在 Github。页面用到了 3D 导航，你可以像玩游戏一样在里面探索，也可以把这个网页当成一个减压神器。
一些可能会颠覆你对世界的认识的照片 文章里面列举了大量可能颠覆你认知的照片，比如世界上第一张自拍花了 30 秒，即保持一个姿势 30 秒不动。
Youtube 上最近有个视频火了：美国加州某地的微波传输站失灵了，技术人员在微波天线罩里面发现了 300磅（136公斤）的橡子，大家都认为是松鼠干的，根据美国「国家地理」的文章 Meet the Bird that Filled an Antenna With Acorns 介绍，在微波天线罩里藏橡子的很可能不是松鼠，而是橡子啄木鸟。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
                
                    <a href="https://mengxiaoxu.github.io/page/2" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1581860172763)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">MySQL 架构与历史</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">浅析正则表达式原理</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji">小工具收集</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">Vue + TypeScript 项目起手式</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/2019-nian-zong-jie">2019 年个人总结</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>