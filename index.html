<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1569769416770">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1569769416770" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/o9IjztOrR">
                        怎样才能开开心心的呢？
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-08</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-">
            #随笔
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/94PzxqinO" class="post-tag i-tag
                            i-tag-other_4">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/o9IjztOrR" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/o9IjztOrR.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。
说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。
媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。
包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。

周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”
像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。
我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。
很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。

毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。
这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。
于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。
当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。

另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。
当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。
举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。

高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。
我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。
另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。

我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。
周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？
凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/o9IjztOrR">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu">
                        变量提升与作用域
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-08</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/javascript" class="post-tag i-tag
                            i-tag-other_3">
            #JavaScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-error">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/bian-liang-ti-sheng-yu-zuo-yong-yu.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
lhs rhs是啥意思
《Javasript 高级程序设计（第三版）》
《你不知道的 JavaScript（上卷）》

几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为作用域。
编译原理
我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。
传统语言在执行之前会经历三个步骤：分词/词法分析、解析/语法分析、代码生成，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。
我们需要先了解三个名词。引擎：从头到尾负责整个 js 程序的编译及执行过程；编译器：负责词法分析及代码生成；作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
var a = 2;，我们以这段程序为例，它首先声明了变量a，然后将2赋值给变量a。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
变量提升
用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码
console.log(a);
var a = 2;

上述代码在a声明之前访问了变量a，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是undefined。
回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理。所以我们前面列出来的代码实际上会变成下面这个样子。
var a;
console.log(a);
a = 2;

这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。
foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}

这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。
function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};

可以看到，虽然var foo出现在function foo()之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。
LHS 和 RHS 查询
LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是赋值操作符的左侧和右侧。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。
RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。
console.info(a);我们深入研究一下这句代码。这里对a的引用是 RHS 引用，因为这里a并没有赋予任何值，相应的需要查找并取得a的值，这样才能传递给console.info()。
a = 2;对a的引用则是一个 LHS 引用，因为实际上我们并关心a当前的值是什么，只是想为= 2这个赋值操作找到一个目标。
function foo(a) {
    console.info(a);
}
foo(2);

为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行foo()函数的调用需要对foo进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给foo()函数时，2 会被分配给参数a，为了给参数a（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了a = 2的语句。
前文已经说过了console.info(a);会对a进行一次 RHS 查询，需要注意的是console.info()本身也需要一个引用才能执行，因此会对console对象进行 RHS 查询，并检查得到的值中是否有一个log方法。
为什么区分 LHS 和 RHS
我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。
function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);

第一次对b进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。
引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。

需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。

接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。
作用域链
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。
每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。
当代码在环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。
var color = &amp;quot;blue&amp;quot;;

function changeColor() {
    var anotherColor = &amp;quot;red&amp;quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();

下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。
window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor

作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：
var color = &amp;quot;blue&amp;quot;;

function getColor() {
    var color = &amp;quot;red&amp;quot;;
    return color;
}

console.info(getColor()); // &amp;quot;red&amp;quot;

在getColor()中沿着作用域链在局部环境中已经找到了color，所以搜索就停止了，也就是说任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/bian-liang-ti-sheng-yu-zuo-yong-yu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu">
                        惰性载入函数
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-06</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/javascript" class="post-tag i-tag
                            i-tag-primary">
            #JavaScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-other_4">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/duo-xing-zai-ru-han-shu.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考资料：
《JavaScript 高级程序设计（第三版）》
JavaScript专题之惰性函数
深入理解javascript函数进阶之惰性函数

因为不同厂商的浏览器相互之间存在一些行为上的差异，很多 js 代码包含了大量的if语句，将执行引导到正确的分支代码中去，比如下面的例子。
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        if (typeof arguments.callee.activeXString != &#39;string&#39;) {
            var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
            var i, len;
            for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (e) {
                    // skip
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&#39;No XHR object available.&#39;);
    }
}

我们可以发现，在浏览器每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查，但是很明显当第一次检查之后，我们就应该知道浏览器是否支持我们所需要的能力，因此除第一次之外的检查都是多余的。即使只有一个if语句也肯定要比没有if语句慢，所以if语句不必每次都执行，那么代码可以运行的更快一些，惰性载入就是用来解决这种问题的技巧。
函数重写
要理解惰性载入函数的原理，我们有必要先理解一下函数重写技术，由于一个函数可以返回另一个函数，因此可以在函数内部用新的函数来覆盖旧的函数。
function sayHi() {
    console.info(&#39;Hi&#39;);
    sayHi = function() {
        console.info(&#39;Hello&#39;);
    }
}

我们第一次调用sayHi()函数时，控制台会打印出Hi，全局变量sayHi被重新定义，被赋予了新的函数，从第二次开始之后的调用都会打印出Hello。惰性载入函数的本质就是函数重写，惰性载入的意思就是函数执行的分支只会发生一次。
惰性载入
我们来看一个例子（例子来源于冴羽所写的JavaScript专题之惰性函数）。现在需要写一个foo函数，这个函数返回首次调用时的Date对象，注意是首次。
方案一
var t;
function foo() {
    if (t) return t;
    t = new Date()
    return t;
}
// 此方案存在两个问题，一是污染了全局变量
// 二是每次调用都需要进行一次判断

方案二
var foo = (function() {
    var t;
    return function() {
        if (t) return t;
        t = new Date();
        return t;
    }
})();
// 使用闭包来避免污染全局变量，
// 但是还是没有解决每次调用都需要进行一次判断的问题

方案三
function foo() {
    if (foo.t) return foo.t;
    foo.t = new Date();
    return foo.t;
}
// 函数也是一种对象，利用这个特性也可以解决
// 和方案二一样，还差一个问题没有解决

方案四
var foo = function() {
    var t = new Date();
    foo = function() {
        return t;
    };
    return foo();
};
// 利用惰性载入技巧，即重写函数

惰性载入函数有两种实现方式，第一种是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一种按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行分支了。
第二种实现方式是在声明函数时就指定适当的函数。这样第一次调用时就不会损失性能了，而是在代码首次加载时会损失一点性能，即是利用闭包写一个自执行的函数。
改进 createXHR
有了上面的基础，我们就可以将createXHR()改进为下列形式，这样就不用每次调用都进行判断了。
// 第一种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        createXHR = function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}

// 第二种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        return function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/duo-xing-zai-ru-han-shu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">
                        非设计师需要知道的四个设计原则
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-06-22</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/i4kET55EC" class="post-tag i-tag
                            i-tag-other_4">
            #翻译
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/vhSkGeYf1D" class="post-tag i-tag
                            i-tag-other_4">
            #设计
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
作者：Anna 4erepawko Mészáros，UI/UX 设计师。
关注作者： Medium、Twitter

这篇文章是写给无力邀请专业设计师的所有内容创作者的，以及设计师异常忙碌的团队的非设计师们。如果您按照这些简单的步骤进行操作，我保证您的设计会变得更好。
这些 Tips 来源于我对身边非设计朋友的多年观察，家人与同事在日常生活中也需要设计他们的东西。比如简历、作品集，Facebook 和 Instagram 上帖子要使用的图片，YouTube 视频的缩略图等。
所有这些人都向我寻求帮助与建议，希望能让他们的东西看起来更好。我坚信「授人以鱼不如授人以渔」，所以我试图提供更有价值的建议，以便他们在未来也能解决类似的问题。
随着时间的推移，我意识到我一直在给所有人提供相同的建议，虽然每次所使用的措辞不同，但我所有的建议都可以提炼为以下四个原则。
这些 Tips 会帮您创造出美丽动人的设计吗？答案是不会！它们只会帮您创造出色、清晰且易于理解的设计。是每个人都可以轻松理解和互动吗？那当然，所以不多说废话，下面我就向您逐一展示。
对比
确保所有元素之间有足够的对比度。为什么？因为那些略有差异但是又不够不同东西，创造了一种恐怖谷。人类的眼睛会排斥它们，对它们感到厌恶、难以理解。我们不希望它们出现在我们的设计中，难道不是吗？

恐怖谷理论，是一个关于人类对机器人和非人类物体的感觉的假设。如果一个非人类实体不够拟人，那么它身上的人类特征会很容易辨认；而当它足够拟人时，他身上的非人类特征则会变得很容易辨认。因此会在人类观察者眼中产生一种古怪的感觉，想想您看到病患者或者尸体时的感觉。

因此您设计的元素要么完全相同，要么具有显著差异。
您可以从下面四个方面来突出对比：
1、颜色：浅色上使用暗色，反之亦然
示例： 切勿在浅蓝色上使用浅灰色或浅粉红色等灰色组合，它们会造成阅读/互动上的极大困难。

2、大小：相邻元素要么大小完全相同，要么大小区别很大
示例： 不要将 32pt 和 36pt 的文本放在一起；18pt 和 36pt 放在一起会显得更加协调。

3、粗细：与大小一样，相邻元素的粗细要么完全相同，要么有明显的区别
示例： 不要将相同字体的粗体与黑体放在一起，因为它们看起来太相似了；将黑体与细体放在一起会显得很协调。

4、风格：不要将一个斜体类型放在另一个斜体类型旁边，或者在一个衬线字体旁边放置另一个衬线字体。应该组合不同的东西。
示例： 不要将 Times New Roman 与 Georgia 放在一起，它们看起来太相似了，应该组合完全不同的风格。

一致性
确保相似的元素以相似的方式出现。为什么呢？首先，通过确保确保事物一致性，您可以让用户将注意力集中在设计的重要方面，而不是被随时变化的元素分散注意力。
其次，一致性也增加了用户对您的信任，使事物看起来实际上是设计的，而不是简单快速拼凑出来的。
一旦你选择了具体的风格，就要毫不犹豫的坚持下去，这里所说的风格包括字体、颜色、阴影、栅格、对齐、装饰风格等等。

当您处理许多相邻的不同部分时（比如 YouTube 的视频缩略图或是中型文章的封面），您应该为所有部分选择一种整体风格，并坚持使用。
奥卡姆剃刀 减少视觉噪音
在您的设计中，使用的元素越少越好。为什么呢？因为人类的大脑很难在输入过载的情况下处理信息并作出决策。您应该使用尽可能少的装饰元素（字体、颜色、阴影、图标等等）。
将奥卡姆剃刀应用于所有内容。如果只需要两个元素就能满足需求，那么就不要使用 3 个元素；如果 10 个元素实现所需的功能，那么就不要用 20 个元素。

如果您不喜欢古老的英国哲学家风格，更喜欢您在 Netflix（一家美国流媒体提供商）上看到的东西。请将怦然心动的人生整理魔法应用到您的设计中。

《怦然心动的人生整理魔法》是美国流媒体提供商Netflix于2019年1月1日首播的一档真人实境秀节目。节目由日本“整理咨询顾问” 近藤麻理惠主创。她在每集节目中拜访一个家庭，帮助他们整理自己的房间。
近藤麻理惠认为整理房间时应当将物品分为五类：衣物、书籍、纸张文件、杂物和情感纪念品；在整理时拿起每件物品，如果能使自己“怦然心动”则留下，如果不能则要感谢物品的贡献然后与其告别。

间距
元素的位置会发送关于其含义的元级别消息。为什么这很重要？因为了解如何放置元素以及在它们周围预留了多少空间有助于降低设计的复杂性，因此会使人更加愉悦，并且更容易交互。
在您的设计中使用间距来传达下面 3 个方面的信息：
1、接近度 = 相关性
与其它元素相比，彼此更接近的事物被认为它们有更强的相关性。这是最重要的，因为我觉得它常常容易被忽视。
它可以以很多不同的方式应用，比如行与行之间应该有一定的间距，而不是一行中每个单词之间的间距那么小；同样不同段落之间的空间也比段落内的行空间要大。

元素之间的间距应该小于元素与组合边缘之间的间距。

标签和支撑信息应该位于其相关元素附近。

2、留白
结合奥卡姆剃刀，给您的设计尽可能留白，去整理它们，使它们的意义更加明显。
如果把太多元素放在有限的空间里，就像同时听三首不同的哥，很难理解别人在说什么。

3、重要性与顺序
这是一个很普通的常识，但是我还是要在这里提到它。
最重要的事情放在第一位，使它们占据最大的空间，用一系列的事物来传达秩序。
结束语
恭喜您！如果您按照这些 Tips 进行设计，那么按照行业标准，它可能看起来非常好。
For everything else, there is always a designer.

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-05-12">
                        刘小绪同学随笔（2019-05-12）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-12</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-success">
            #随笔
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-05-12" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/liu-xiao-xu-tong-xue-sui-bi-2019-05-12.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            最近机缘巧合和几个中年大叔聊天，从眼神里面能看出来他们是讲的真心话，平时也非常反感长辈们给自己讲的一些大而空的道理，但仔细想想这些话其实并不是完全没用。
不管对方是世俗眼光中的成功人士还是失败人士，他们都会有自己没有实现的理想愿望，成功人士没有好好陪家人孩子，他们可能喜欢特地找个时间，不管接收方是否感动，但至少他自己已经得到心灵的慰藉了；失败人士没有给到家人足够富裕的生活，这时候他们都很喜欢看努力、奋斗、自强不息......一类词汇堆砌的文章。而老人的精神世界已经不是奋斗了，而是人这一生......，所以如果陪老人说话，你只需要把话题引入到佛身上，然后静静的听就可以了。

忘了啥时候无意中加了一个高中生，目前正在读高二，与大多数人不同的是，她属于双性恋人群，并且更偏爱小姐姐，出口成脏，上课偷偷玩手机，宛然一个大家脑中所构想的问题少年。
但是几个月前突然变了，一下子变得有礼貌起来了，我问她是因为什么变了，她告诉我是因为我说的一句话：不说脏话是对人起码的尊重。这句话让她想明白了，我在这里偷偷说一句，我也不知道当时说的这句话对不对，其实就是随口一说，让一个小娃娃变好了，那也好。
在我的循序诱惑下，小姑娘已经不藏手机了，每周日自觉的把手机交上去，每周五手机发下来再玩，所以我和她的聊天记录现在基本上变成了，周日我发一句“加油”，周五下午我会收到一句“突然出现”。
小姑娘自己是同性恋的事情不敢给爸妈说，我想这是不是因为父母与孩子天然就有一种屏障，以至于无法与他们进行心灵上的沟通，要想能够得到孩子的信任，父母应该多站在孩子角度考虑考虑问题，尽量不要拿「我都是为你好」去搪塞孩子。

最近上饶杀熊孩子案很火，女生父亲杀人当然是不对对，但是对于这种校园霸凌这件事，校方与男生家长都摆出无所谓的态度，才导致悲剧的发生，其实校园霸凌的核心不在熊孩子身上，而是在熊家长身上。
吴军在其《大学之路》上有写道：“在我的印象中，父母晚上从来不参加应酬，甚至不看什么电视剧，总是非常有规律的学习，我的母亲现在快 80 岁了，依然每天坚持学习，父母们并不知道，他们在对我们兄弟的教育上最成功之处，是以他们的行为潜移默化地影响了我们，让我们渐渐养成了终身学习的习惯”。借句公益广告词——父母是最好的老师。

最近一个很搞笑的新闻，法国一所小学为了拯救学校不被关闭，招了 15 只羊作为新生。简单来说就是，根据法国政策，当学生数量少于 261 时，学校将被迫停办，而法国人在抗议上也很有创意，反正规定上又没有写招生的物种必须是人，正好我们家有许多只适龄绵羊，都送去上学吧！
牧民说到做到，这周二就和校长及家长达成一致，带领着自己家50只绵羊赶到学校招生办公室报道，招生办的老师热情的接待了羊以及送羊报道的牧羊犬们，在检查了所有绵羊的出生证后，最终有15只年龄在3-6岁之间的适龄绵羊顺利通过合法注册，成为小学的一年级新生，让这所小学不至于被停学。

我们常常把体育锻炼与健身、减肥挂钩，前段时间杭州程序员小伙伴突然精神崩溃，引发了一大波人关注，在校大学生跳楼也是常有的事，但是去细细看一下，是不是很少会看到体育生跳楼。
大学生跳楼无非是意志力脆弱、心理自我调节能力差等方面影响的，而体育锻炼恰恰会无意中去缩短了这些短板，我主要不是想说体育锻炼有多么多么好，因为这是大家都知道的，而是想说一件事的作用范围可能比你想象的要大的多。

今天是母亲节，无意中突然记起了初中的一篇阅读理解——《那支枯萎的康乃馨》，读者大人可以去搜搜读读，从另一个角度看看母亲节送礼这件事，不知道现在的朋友圈孝子还多不多。
同样今天是 5.12 汶川地震纪念日，地震发生时我还在读 6 年级，记得整个床都摇的快要倒了，房子上面的瓦片蹭蹭的往下掉，但是学生中间没有一个害怕了，原因只是因为我们并不知道地震这个词。
去年的 5.28 日，吉林松原发生了一次小的地震，哈尔滨有震感，作为也算经历过地震的人，自然异常的敏感，熟睡中的我一下就惊醒了，立刻意识到地震了，然后在那三四秒的时间里面，时间好像停住了一样，我都数不清那几秒时间脑海里滑过了多少记忆，我体会到了面对死亡的感觉，几秒过后，根据汶川地震的经验，本次只是小地震，所以我又躺下睡觉了，然后室友们都跑出去了。

出来工作也有大半年了，之前以为第一份工作是学习技术的，现在才发现第一份工作首先应该学习的是做事态度，在学校如果某件事不想做或者太困难，那么完全可以选择不做，但是在企业不行，一些恶心的事情必须有人得去做，学生总是缺乏应有的责任感，但责任感是优秀员工的基本条件。
我之前在公司怼过两次领导，怼完领导之后他反倒对我更好了，给我解决问题的速度超快，现在回想起来可能自己实际上做错了，为啥不能心平气和的去解释，而采取暴力沟通，今后我也要学习怎么做一个圆滑的俗人。
保持一个虚心的学习态度是异常重要的，认清自己资质平平的现实。一些人在公司认为经理是个傻逼，总监是个马屁精，董事长屁股决定脑袋，那不过是因为你没到那个位置，没办法理解他们考虑问题的角度而已。

最后，放个图，开心一下！！！


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-05-12">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/qCt13nLLT">
                        浅析浏览器缓存机制
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-26</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/S57Vp3Suu" class="post-tag i-tag
                            i-tag-error">
            #计算机网络
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-other_4">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/qCt13nLLT" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/qCt13nLLT.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。
HTTP 报文
HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。
缓存概述
浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：

浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有强制缓存和协商缓存两类，也有人把协商缓存叫对比缓存。
强制缓存
我们先自己想一下，使用缓存是不是会有下面几种情况出现。


存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；


存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；


不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。


控制强制缓存的字段分别是Expires和Cache-Control，并且Cache-Control的优先级高于Expires。
Expires
Expires是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于Expires值，就直接使用缓存数据。到了 HTTP/1.1，Expires已经被Cache-Control替代了。
Expires被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。
Cache-Control
Cache-Control是 HTTP/1.1 中最重要的规则，主要取值为：



取值
规则




public
所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与private一样。


private
所有内容只有客户端可以缓存，Cache-Control的默认值。


no-cache
客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）


no-store
所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用


max-age=xxx
缓存内容将在 xxx 秒后失效



我们可以看看下面这个例子，可以从截图中看到Expires是一个绝对值，而Cache-Control是一个相对值，此处为max-age=3600，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于Expires是更好的选择，所以同时存在时只有Cache-Control生效。

协商缓存
协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。

上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高，所以同时存在时只有Etag / If-None-Match生效。
Last-Modified / If-Modified-Since
你可以往上翻一翻，看一下那张响应报文截图，其中有一个Last-Modified字段，它的值是该资源文件在服务器最后被修改的时间。
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值。服务器收到该请求后，发现该请求头有If-Modified-Since字段，则会将If-Modified-Since与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。

Etag / If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。
If-None-Match则是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，

disk cache 与 memory cache
我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？

猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。
内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。
浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。
总结
到这里偷懒一下子了，找到人家画的一张图，看图就行了。


参考内容：
彻底理解浏览器的缓存机制
彻底弄懂HTTP缓存机制及原理


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/qCt13nLLT">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling">
                        Git 进阶及常用命令
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-18</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/git" class="post-tag i-tag
                            i-tag-info">
            #Git
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/QjCHA76i_r" class="post-tag i-tag
                            i-tag-error">
            #编程基础
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/git-jin-jie-ji-chang-yong-ming-ling.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            如果你只是想查看 Git 常用命令可以选择直接到文章底部「Git 常用命令」阅读，文章大部分内容是 Git 进阶知识，均是自己的读书笔记，如果还想在此基础上再上一层楼，那可以直接看 Pro Git book。
Git 历史
版本控制器是一种记录一个或若干文件内容变化，以便将来查阅特定版本的修订情况。也就是说，版本控制器记录了一个可供考证的历史数据，通过该数据可以知道文件是怎么一步一步发展到今天这个样子的。
最初 Linux 项目使用 BitKeeper 来管理和维护代码，但是到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。那 Linux 开源社区的解决方案就是自己搞一个版本控制器，所以就有了 Git。
简单说就是 Linus 被逼的去开发了这一款叫做 Git 的版本控制器，因为 Linus 本身就是内核专家与文件专家，所以 Git 也就自然而然具备了非凡的存储能力与性能。
安装
关于如何安装 git 可以查看 Pro Git book，安装完成后需要进行一些必要的配置，比如用户信息、文本编辑器、差异分析工具等等，我们可以通过git config --list来查看配置信息。比如我们要配置用户和邮箱，就可以像下面这样输入命令。
$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email johndoe@example.com

Git 原理
Git 和大多数版本控制器有一个重要的区别，就是它直接记录快照，而非差异比较，其它大部分系统以文件变更列表的方式存储信息，而 Git 则存储每个文件与初始版本的差异。换句话说，只要你的文件有改动，那么 Git 就会将该文件复制一份，正因为 Git 的这个特性，所以 Git 仓库很容易就变得非常大；为了高效，如果文件没有修改，那么 Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。
Git 有三个区，分别为：仓库、工作目录、暂存区。基本的 Git 流程为：1）在工作目录中修改文件；2）暂存文件，将文件的快照放入暂存区域；3）提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。那么相应的 Git 就有三种状态：已提交（committed）、已修改（modified）和已暂存（staged），你的文件可能处于其中之一。

Git 基础
工作目录中的文件不外乎处于两种状态：已跟踪或未跟踪。已跟踪是指那些纳入了版本控制的文件，在上一次快照中有它们的记录；工作目录中除了已跟踪文件以外的所有文件都属于未跟踪文件，们既不存在于上次快照的记录中，也没有放入暂存区。

查看文件状态
如果需要查看哪些文件处于什么状态，可以使用git status命令，这个命令显示的信息十分详细，如果你喜欢简洁一点的信息，那么可以在其后添加一个-s，其报告格式类似于下面这样。
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt

??表示新添加的未跟踪文件；修改过的文件前面有M标记，右边的表示还没有放入暂存区，左边的表示已经放入暂存区了。当然你可能不希望每个文件都出现在未跟踪列表中，比如编译过程临时创建的文件、日志文件等等，所以可以通过创建一个名为.gitignore的文件，列出要忽略的文件模式，它支持标准的glob模式匹配（shell 所使用的简化了的正则表达式），在 gitignore 中有一个十分详细的针对数十种项目及语言的.gitignore文件列表。
git status对于具体修改显示的过于模糊，如果想查看具体修改了什么地方，可以使用git diff命令，比如git diff README.md。需要注意的是git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动，如果需要查看已经暂存起来的变化，则要加上--staged或者--cached，比如git diff --cached README.md。
删除文件
当然我们不可避免的需要删除某个文件，如果你仅仅是简单的从工作目录中手工删除文件，那它并没有真正的从 Git 中删除，Git 会将这次删除识别为一次改动。更好的方式是使用git rm命令来完成删除文件的工作，比如git rm README.md就会从已跟踪文件中删除，并且连带从工作目录中删除指定文件。
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。
另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。这时就需要使用--cached选项了，比如git rm --cached README。
查看历史
我们或许因为某种原因需要回顾一下提交历史，这时git log就派上用场了，默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。
git log提供的选项很多，更详细的内容可以查看 Git 基础 - 查看提交历史。除了不带选项的命令，我个人更常用的命令还有另外两个，分别为：git log --pretty=oneline它将每个提交放在一行显示，在查看的提交数很大时非常有用；git log --graph或者git log --pretty=oneline --graph用于显示 ASCII 图形表示的分支合并历史。
撤销操作
在任何一个阶段我们都可能有想要撤销的操作，我们只需要掌握几个基本的撤销操作就能够应对日常的工作了。
第一种情况：取消上一次提交。有时候当我们提交完之后才发现漏掉了几个文件没有添加，或者是提交信息写错了，此时可以使用带--amend选项的提交命令尝试重新提交，即git commit --amend。这个命令会将暂存区的文件全部提交，如果自上次提交以来你还没一做任何修改（比如，在上次提交后马上执行了此命令），那么快照将会保持不变，而所修改的只是提交信息。
第二种情况：取消暂存的文件。假设你修改了两个文件并且想要将它们作为两次独立提交，但是却不小心输入了git add *暂存了它们两个，如何取消其中一个暂存呢？其实在运行git status时已经给出提示了。
$ git status
On branch master
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	renamed:    README.md -&amp;gt; README
    modified:   CONTRIBUTING.md

所以如果我们想要取消CONTRIBUTING.md的暂存，那么就可以用git reset HEAD CONTRIBUTING.md命令来完成。
第三种情况：撤销对文件的修改。有时候我们可能并不想保留对某个（若干）文件的修改，git status也给出了详细的提示，告诉我们如何将文件还原成上次提交时的样子，即git checkout -- &amp;lt;file&amp;gt;，比如输入命令git checkout -- CONTRIBUTING.md，就会将CONTRIBUTING.md重置到上一次提交时的样子。
需要注意的是git checkout -- &amp;lt;file&amp;gt;是一个比较危险的命令，因为它仅仅是拷贝了另一个文件来覆盖当前文件，所以你对那个文件的所有修改都会消失，而且不可恢复。
远程仓库
前面我们都是在讲本地操作，远程仓库的使用是必不可少的技能。可以使用git remote命令查看每一个远程服务器的简写，对于已经克隆的仓库，它至少会包含一个origin，这是 Git 给克隆仓库服务器取的默认名字，它和其它服务器并没有什么区别，只是很少人会去修改这个默认名字而已。
如果想要给一个远程仓库重新取一个简写名，那么可以运行git remote rename来完成，比如git remote rename pb paul就是将pb重命名为paul。值得注意的是这样同样也会修改你的远程分支名字，那些过去引用pb/master的现在全引用paul/master。
当想要将自己的成果分享给他人时，就需要将其推送到上游，使用git push [remote-name] [branch-name]即可，比如你想要将master分支推送到origin服务器时，就可以运行git push origin master。
除了分享自己的成果，我们也需要获取他人的成果，即从仓库拉取自己没有的信息，比如git fetch origin，需要注意的是git fetch命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作，所以你还需要git merge来合并分支，实际上有一个git pull命令可以帮我们把这两个步骤都做了，你可以简单的将git pull理解为git fetch后面紧接着一个git merge。
分支管理
Git 的分支模型是它的必杀技特性，它处理分支的方式是难以置信的轻量，创建分支几乎是在一瞬间完成，而且在不同分支间的切换也非常的便捷，要理解 Git 的分支，我们必须要再次回顾 Git 是如何保存数据的。
下图是我们的一个工作流，可以看到所谓的分支实际上就是一个可以移动的指针而已，master、v1.0都仅仅是一个指针，而创建分支、切换分支等操作也都只是对指针的操作，因此就不奇怪为什么 Git 这么快了。

那么 Git 又是如何知道当前在哪一个分支上呢？它仅仅是用了一个名为HEAD的特殊指针，你可以将HEAD想象为当前分支的别名，HEAD指向哪个分支，就表示当前处于哪个分支。
分支创建与切换
我们可以使用git branch [branch-name]来创建一个新的分支，比如git branch testing；如果使用不带选项的git branch，那么它会列出当前所有的分支，这里需要注意的是master分支也不是特殊分支，它是运行git init时自动创建的默认分支，因为大家都懒得去改它，所以它就好像变得特殊了一样。
git branch [branch-name]只是创建了一个新分支，并不会切换到这个分支上面去，分支的切换说白了就是移动HEAD指针，我们只需要使用git checkout testing就可以切换到testing分支上去了。
当然我们可以使用git checkout -b [branch-name]来创建一个分支并同时切换到这个分支，把这个命令与git commit -a -m来对比，你就会发现它们的类似之处。
分支的合并与删除
当我们零时在一个新分支上解决了问题后，需要将其合并到master分支，只需要切换到master再运行git merge命令即可，Git 会自动找到这两个分支的共同祖先，然后做一个简单的三方合并。
当然理想情况下是直接合并成功，但是不免会遇到合并冲突的情况，一旦遇到冲突了，Git 会像下面这样来标记冲突内容，你需要做的是选择由=======分割的令部分的其中一个或者自行合并，当&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;，=======，和&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;这些行被完全删除了，你需要对每个文件使用git add将其标记为冲突已解决。
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html
&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
=======
&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;
 please contact us at support@github.com
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; testing:index.html

当合并完分支后，之前的分支一般就不会再要了，这时你可以运行git branch -d [branch-name]来删除指定分支，比如使用git branch -d testing来删除testing分支。
远程分支
远程分支以(remote)/(branch)的形式来命名。如下图所示，如果你克隆一个仓库下来，那么这个仓库除了会有一个本地的分支指针，还会有一个远程分支指针。如果你在本地的master分支做了一些工作，但是你并没有与origin服务器连接，那么你的origin/master指针就不会移动。

在这之前我们已经讲过通过推送分享自己的成果，在运行git push origin master命令时，Git 会自动的将master分支名字展开为refs/heads/master:refs/heads/master，即意味着推送本地的master分支来更新远程仓库上的master分支，所以你也可以运行git push origin master:testing来做类似的事，如果远程仓库没有testing分支，那它会自己创建一个新的testing分支。
我们肯定需要创建一个跟踪远程仓库的其它分支，最简单的就是运行git checkout -b [new-branch] [remote-name]/[branch]，该命令会以远端[branch]分支的内容来创建本地的[new-branch]分支，Git 也对该命令做了一个简化，git checkout --track [remote-name]/[branch]，该命令就会在本地创建一个[branch]分支用于跟踪远端的[branch]分支。
当然，我们还需要了解一个删除远程分支的命令git push origin --delete [branch]，需要注意的是这个命令基本上只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。
Git 常用命令
挑了一些比较重要 Git 命令，我把个人常用的命令使用代码块标记出来了。



命令
作用




git init
将一个目录转变成一个 Git 仓库


git clone
从远程克隆一个仓库到本地，它是多个命令的组合，


git add
将内容从工作目录添加到暂存区


git commit
将暂存区文件在数据库中创建一个快照，然后将分支指针移到其上


git commit -a -m [msg]
git add``和git commit```的组合


git status
展示工作区及暂存区域中不同状态的文件


git status -s
比git status展示的内容更加简洁


git diff
对比工作目录文件和暂存区快照之间的差异


git diff --cached
对比已暂存的差异


git reset
根据你传递给动作的参数来执行撤销操作


git rm
从工作区，或者暂存区移除文件


git clean
从工作区中移除不想要的文件的命令


git checkout
切换分支，或者检出内容到工作目录


git branch
列出你所有的分支、创建新分支、删除分支及重命名分支


git checkout -b [branch]
创建新分支并切换到该分支


git log
展示历史记录


git log --pretty=oneline
简洁版历史记录


git merge
合并一个或者多个分支到已检出的分支中


git stash
临时地保存一些还没有提交的工作


git pull
git fetch 和 git merge 命令的组合体


git push
将本地工作内容推送到远程仓库


git push origin local_branch:remote_branch
比git push更加详细的推送


git checkout --track [remote-name]/[branch]
在本地创建一个分支用于跟踪远程同名分支




参考内容：Pro Git book


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/shi-me-shi-qi-yue-ce-shi">
                        什么是契约测试？
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-10</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/ce-shi" class="post-tag i-tag
                            i-tag-warning">
            #测试
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/qian-hou-duan-fen-chi" class="post-tag i-tag
                            i-tag-warning">
            #前后端分离
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/shi-me-shi-qi-yue-ce-shi" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/shi-me-shi-qi-yue-ce-shi.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            契约测试全称为：消费者驱动契约测试，最早由 Martin Fowler 提出。契约这个词从字面上很容易理解，就是双方（多方）达成的共同协议，那又为什么需要契约测试这个东西呢？
在当前微服务大行其道的行业背景下，越来越多的团队采用了前后端分离和微服务架构，我们知道微服务是由单一程序构成的小服务，与其它服务使用 HTTP API 进行通讯，服务可以采用不同的编程语言与数据库，微服务解决了单体应用团队协作开发成本高、系统高可用性差等等问题。
但是微服务也引入了新的问题，假设 A 团队开发某服务并提供对应的 API，B 团队也在开发另一个服务，但是他们需要调用 A 团队的 API，为了产品的尽快发布，两个团队都争分夺秒，已经进入联调阶段了，然而出现了下面这样的尴尬情况。

随着越来越多的微服务加入，它们的调用关系开始变得越来越复杂，如果每次更改都需要和所有调用该 API 的团队协商，那沟通成本也未免太大了，试想下图的沟通成本。

为了保证 API 调用的准确性，我们会对外部系统的 API 进行测试，如果外部系统稳定性很差，或者请求时间很长的时候，就会导致我们的测试效率很低，当调用 API 失败时，你甚至无法确定是因为 API 被更改而导致的失败还是运行环境不稳定导致的失败。
A 团队提供的 API 不稳定，肯定会导致 B 团队效率低下，为了不影响 B 团队的进度，所以构建了测试替身，通过模拟外部 API 的响应行为来增强测试的稳定性和反应速度。

但是这样做真的就解决问题了吗？当所有内部测试都通过时，能拍着胸脯说真正的外部 API 就一定没有变化？很简单的一个解决方案就是：部分测试使用测试替身，另一部分测试定期使用真实的外部 API，这样既保证了测试的运行效率、调用端的准确性，又能确保当真实外部系统API改变时能得到反馈。

感觉剧情到这里就差不多该结束了，实际上真正的高潮部分开刚刚开始。如果外部 API 的反馈周期很长，那增加真实 API 测试间隔时间就又回到了最初的起点。现在我们回顾一下上面的方案。
在上面的场景中，我们都是已知外部 API 功能来编写相应的功能测试，并且使用直接调用外部 API 的方式来达到测试的目的，如此就不可避免的带来了两个问题：

API 调用者（消费者）对服务提供方（生产者）的更改是通过对 API 的测试来感知的；
直接依赖于真实 API 的测试效果受限于 API 的稳定性和反映速度。

解决方案首先是依赖关系解耦，去掉直接对外部 API 的依赖，而是内部和外部系统都依赖于一个双方共同认可的约定—“契约”，并且约定内容的变化会被及时感知；其次，将系统之间的集成测试，转换为由契约生成的单元测试，例如通过契约描述的内容，构建测试替身。这样，同时契约替代外部 API 成为信息变更的载体。
前后照应一下，我们现在再来看一下消费者驱动契约测试。它有两个不可或缺的角色：消费者是服务使用方；生产者（提供者）是服务提供方。采用需求驱动（消费者驱动）的思想。契约文件（比如 json 文件）由双方共同定义规范，一般由消费者生成，生产者根据这份契约去实现。
契约测试其中一个的典型应用场景是内外部系统之间的测试，另一个典型的例子是前后端分离后的 API 测试。行业内比较成熟的解决方案是 Swagger Specification 和 Pact Specification，这里不做展开讨论。
我们同样可以把契约测试的思想用到代码的编写中，契约测试通过一个契约文件来解耦依赖，那么对于需要用户定义很多规则的场景，我们同样可以将这些规则像契约文件一样抽取出来，这样就降低了代码之间的耦合度。
最后敲敲黑板，契约测试不是替代 E2E 测试的终结者，更不是单元测试的升级换代，它更偏向于服务和服务之间的 API 测试，通过解耦服务依赖关系和单元测试来加快测试的运行效率。

参考文章：
聊一聊契约测试 —— ThoughtWorks洞见
契约测试 —— 米阳
前后端分离了，然后呢？ —— 邱俊涛


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/shi-me-shi-qi-yue-ce-shi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-02-27">
                        刘小绪同学随笔（2019-02-27）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-02-27</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-other_1">
            #随笔
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/EE1uiCHgH" class="post-tag i-tag
                            i-tag-other_3">
            #个人总结
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-02-27" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/liu-xiao-xu-tong-xue-sui-bi-2019-02-27.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            建议读者大人们，如果自己经常一上火牙就疼，或者自己感觉牙已经有点问题了，可以提早预约医院的口腔科查一下，如果有问题早点预防，总是没有坏处的。抽烟的半年洗一次牙，不抽烟的一年洗一次牙。
因为智齿发炎被狠狠的折磨了近两周，我属于比较能忍得疼痛的人，这不周末才进行了一场春季骑行，唯有美景与美食不可辜负，什么病痛都是浮云，但回想起连续几晚上疼到睡不着觉的滋味，昨天毅然决然斩草除根，给拔掉了，今天就感觉好了很多。

前几天考研成绩出来了，估计现在大部分同学都在准备复试，我没有体验过考研的这个过程，毕业这半年有时候还是会想，我也应该体验一下考研的那个过程，已经很久没有体验过把所有时间都投入到一件事情上的快乐了。
但我还是不太建议读研，我这是无责任建议，毕竟自己没有读过研究生，在研究生实验室待了两年，算是有一半的硕士生经历吧。对于学历我一直以来的观点都是绝大部分人将它的作用放大了，总是认为名校成造就了强能力，而恰恰把因果关系给弄反了，是能力强的人都进了名校（本科）。当然，不否认像医学一类的专业是肯定要考研的，一棒子全打死肯定是不对的。

刘大发起的读书活动告一段落了，跟着小伙伴们泛泛的读了一遍《深入理解计算机系统》，只能用“痛并快乐着”来形容这个过程，每周输出一篇读书笔记，没有按时输出就罚钱的规矩很好，人还是需要自己逼自己才行。
这本书不适合初学者阅读，在豆瓣上的评分接近 10 分，不讲究速成，而是一本内功心法，如果是您是码农的话，读一读绝对会提高一个层级。现在已经开启了另一本书籍的阅读计划，刘大这个活动组织的超好。

春节回家发现了一个巨大的变化，我老家那种贫困县地区的村民们，也在开始讨论保险这一类产品了，我是觉得这个改变太大了，说明农民伯伯的经济水平也有很大的提升了。另外通过朋友圈还发现，我认识的大佬们貌似出身都并不是多好，反倒是大部分普通朋友家里的矿更多。
我们家族每年会组织祭祖活动，在正月初三一大家 50 人左右一同祭拜曾祖曾母，通过这么一个活动把整个大家族的年轻人联系起来，能搭建这样一个平台很棒，我正也在着手将家族信息数字化。

说到这里，想说一句家族群是个小江湖，亲戚之间也是暗暗较劲的，母亲不会抢群里几个特定的人发的红包，家里都是山路，车技不好的人很容易就寸步难行，一表叔就因为不到 10 米的距离，整个春节都在亲戚朋友面前抬不起头。
堂弟现在是民航飞行员在读，而另一个表弟今年正值高考，说要去考炮兵学院，将来好把飞机打下来，这一下可好了，这些话全部伯父被截屏保留了，将来某一天要是这俩兄弟闹矛盾了，估计有的好看。保二爷写的家族群不是群，是江湖...看起来更有趣一点。
在我身上更可悲的事情发生了，所有长辈一致认同应该由我来管理家族群，想想整个群里充斥的都是是那种要露不露、似露非露、就是不露的视频，或者是用粗糙都无法形容的大而泛的鸡汤文，整个头就大了，这可比解决技术问题难多了。

最近愈发觉得“大佬”之间的抄袭严重了，真大佬基本都是原创内容，或者是引用了别人的文字就标注出来，然而总是看到一些“大佬”原封不动发出来，还不表明出处，下面粉丝跟着继续做同样的事，我看到最多的一次是朋友圈连续 10 多条是一样的段子。

最后想无责任乱说一点科技相关的东西，5G 是当下的风口浪尖，各大厂商都希望在 5G 上有一席之地，搞芯片的搞芯片、做基站的做基站、整手机的整手机，5G + IPV6 肯定会带来无法想象的未来，5G 会大幅推动智能硬件的应用，但是手机这个应用场景是不是被夸大了呢？
现在的 4G 手机在线看一部高清电影不会有多卡顿的现象，广大吃瓜群众和各大媒体，一直都拿着 5G 手机来吹嘘，吃瓜群众跟随媒体引导的大流，我总觉得当拿到 5G 手机的那一刻，心里肯定会从喜悦急转失望的，就像目前的苹果产品一样。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/liu-xiao-xu-tong-xue-sui-bi-2019-02-27">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/MqqlYHD78">
                        Bootstrap-table 合并相同单元格
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-01-26</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/J_3GE6pBm" class="post-tag i-tag
                            i-tag-banana">
            #TypeScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-success">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/MqqlYHD78" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/MqqlYHD78.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Bootstrap-table 官方提供了合并单元格方法 mergeCells，它根据四个参数可以合并任意个单元格，我们要做的只是告诉它怎么合并。
要合并同一列相同的单元格，无非两种办法，一种是一边遍历一边合并，遍历完了再合并。这里采用第二种办法，这里不需要遍历所有数据，因为用户只能看到当前页的数据，所以只遍历当前页的数据更省时间。
下面是我实现的获取合并信息算法，最终返回的是一个哈希表，比如下面的这个表格，如果要对「性别」这一列进行合并，很明显前面两个“男”需要合并成一个单元格，再去看下 Bootstrap-table 提供的 API，它需要的是从哪个单元格开始，合并多少个单元格，也就是它需要的是两个数值类型的参数。



姓名
性别
年龄




张三
男
23


李四
男
19


王二
女
20


麻子
男
21



所以我把哈希表设置为，键存的是索引，值存的是从这个索引开始后面连续有多少个和它一样的单元格，那么上述表格性别这一列所得到的合并信息哈希表就为：
{
    0: 2,
    2: 1,
    3: 1
}

下面算法很简单，使用两个指针遍历指定的列，如果两个指针所指向的数据相同，那么就将键所对应的值进行加一操作，整个方法只会对该列数据遍历一边，所以时间复杂度为 O(n)。
let getMergeMap = function (data, index: number) {
    let preMergeMap = {};
    // 第 0 项为表头，索引从 2 开始为了防止数组越界
    for (let i = 2; i &amp;lt; data.length; i++) {
        let preText = $(data[i-1]).find(&#39;td&#39;)[index].innerText;
        let curText = $(data[i]).find(&#39;td&#39;)[index].innerText;
        let key = i - 2;
        preMergeMap[key] = 1;
        while ((preText == curText) &amp;amp;&amp;amp; (i &amp;lt; data.length-1)) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
            i++;
            preText = $(data[i - 1]).find(&#39;td&#39;)[index].innerText;
            curText = $(data[i]).find(&#39;td&#39;)[index].innerText;
        }
        // while循环跳出后，数组最后一项没有判断
        if (preText == curText) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
        }
    }
    return preMergeMap;
}

上述算法得到了单列数据的合并信息，下一步就是按照这个信息进行相同单元格的合并了，因此封装了下面的方法按照指定哈希表进行合并。
let mergeCells = function (preMergeMap: Object, target, fieldName: string) {
    for (let prop in preMergeMap) {
        let count = preMergeMap[prop];
        target.bootstrapTable(&#39;mergeCells&#39;, { index: parseInt(prop), field: fieldName, rowspan: count });
    }
}

到目前为止，我们实现的都只是对单列数据进行合并，要实现对多列数据进行合并，那么只需要对所有列都进行相同的操作即可。
export let mergeCellsByFields = function (data: Object[], target, fields) {
    for (let i = 0; i &amp;lt; fields.length; i++) {
        let field = fields[i];
        // 保证 field 与 i 是相对应的
        let preMergeMap = getMergeMap(data, i);
        let table = target.bootstrapTable();
        mergeCells(preMergeMap, table, field);
    }
}

因为我在程序中做了一点处理，保证了fields中每个值得索引与对应表头的索引是一样的，因此不需要额外传入索引信息。简单来说就是我所实现的表格会根据fields的顺序，实现列之间的动态排序。你需要注意的是这一点很可能和你不一样。
到现在已经能够合并所有的列了，查看 Bootstrap-table 的配置信息发现，它有个属性是 onPostBody 它会在 table body 加载完成是触发，所以把这个属性配置成我们的合并单元格方法即可。
// groups 为要合并的哪些列
onPostBody: function () {
    mergeCellsByFields($(&#39;#table&#39; + &#39; tr&#39;), $(&#39;#table&#39;), groups);
}

再说一点不太相关的，我实现的是让用户可以自己选可以合并多少列，即用了一个可多选的下拉列表框供用户选择，根据用户选择的数量去合并，所以传入了一个groups参数。
最后推荐一个排序插件 thenBy，你可以用它进行多字段排序，比如用在合并相同单元格的场景，在绘制表格前先对数据进行排序，那么最后合并的结果就是把所有相同的数据聚合到一起了，并且还将它们合并到一起了，起到了一个隐形的过滤查询功能。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/MqqlYHD78">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
                
                    <a href="https://mengxiaoxu.github.io//page/2/" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1569769416770)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <a href="https://www.douban.com/people/189583084/" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-facebook"></i></a>
                                        

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>