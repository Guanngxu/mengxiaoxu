<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1583656981045">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1583656981045" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                        Linux 中的零拷贝技术
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-18</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-other_2">
            #Linux
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-other_1">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/linux-zhong-de-ling-kao-bei-ji-zhu.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Two new system calls: splice() and sync_file_range()
Linux 中的零拷贝技术1
Linux 中的零拷贝技术2
Zero Copy I: User-Mode Perspective
Linux man-pages splice()

此前在Nginx 文件操作优化中有提到零拷贝技术，它可以有效的改善数据传输的性能，但是由于存储体系结构非常复杂，而且网络协议栈有时需要对数据进行必要的处理，所以零拷贝技术有可能会产生很多负面影响，甚至会导致零拷贝技术自身的优点完全丧失。
零拷贝就是一种避免 CPU 将一块存储拷贝到另一块存储的技术。它可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率，而且零拷贝技术也减少了内核态与用户态之间切换所带来的开销。进行大量的数据拷贝操作是一件简单的任务，从操作系统的角度来看，如果 CPU 一直被占用着去执行这项简单的任务，是极其浪费资源的。如果是高速网络环境下，很可能就出现这样的场景。
零拷贝技术分类
现在的零拷贝技术种类很多，也并没有一个适合于所有场景的零拷贝零拷贝技术，概括起来总共有下面几种：


直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统只是辅助数据传输，这类零拷贝技术可以让数据在应用程序空间和磁盘之间直接传输，不需要操作系统提供的页缓存支持。关于直接 I/O 可以参看Linux 中直接 I/O 机制的介绍。


避免数据在内核态与用户态之间传输：在一些场景中，应用程序在数据进行传输的过程中不需要对数据进行访问，那么将数据从页缓存拷贝到用户进程的缓冲区是完全没有必要的，Linux 中提供的类似系统调用主要有mmap()、sendfile()和splice()。


对数据在页缓存和用户进程之间的传输进行优化：这类零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统页缓存之间的拷贝操作，此类方法延续了传统的通信方式，但是更加灵活。在 Linux 中主要利用了「写时复制」技术。


前两类方法的目的主要是为了避免在用户态和内核态的缓冲区间拷贝数据，第三类方法则是对数据传输本身进行优化。我们知道硬件和软件之间可以通过 DMA 来解放 CPU，但是在用户空间和内核空间并没有这种工具，所以此类方法主要是改善数据在用户地址空间和操作系统内核地址空间之间传递的效率。
避免在内核与用户空间拷贝
Linux 主要提供了mmap()、sendfile()、splice()三个系统调用来避免数据在内核空间与用户空间进行不必要的拷贝，在Nginx 文件操作优化对sendfile()已经做了比较详细的介绍了，这里就不再赘述了，下面主要介绍mmap()和splice()。
mmap()
当调用mmap()之后，数据会先通过 DMA 拷贝到操作系统的缓冲区，然后应用程序和操作系统共享这个缓冲区，这样用户空间与内核空间就不需要任何数据拷贝了，当大量数据需要传输的时候，这样做就会有一个比较好的效率。
但是这种改进是需要代价的，当对文件进行了内存映射，然后调用write()系统调用，如果此时其它进程截断了这个文件，那么write()系统调用将会被总线错误信号SIGBUG中断，因为此时正在存储的是一个错误的存储访问，这个信号将会导致进程被杀死。
一般可以通过文件租借锁来解决这个问题，我们可以通过内核给文件加读或者写的租借锁，当另外一个进程尝试对用户正在进行传输的文件进行截断时，内核会给用户发一个实时RT_SIGNAL_LEASE信号，这个信号会告诉用户内核破坏了用户加在那个文件上的写或者读租借锁，write()系统调用就会被中断，并且进程会被SIGBUS信号杀死。需要注意的是文件租借锁需要在对文件进行内存映射之前设置。
splice()
和sendfile()类似，splice()也需要两个已经打开的文件描述符，并且其中的一个描述符必须是表示管道设备的描述符，它可以在操作系统地址空间中整块地移动数据，从而减少大多数数据拷贝操作。适用于可以确定数据传输路径的用户应用程序，不需要利用用户地址空间的缓冲区进行显示的数据传输操作。
splice()不局限于sendfile()的功能，也就是说sendfile()是splice()的一个子集，在 Linux 2.6.23 中，sendfile()这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过内部已经使用了splice()这种机制来实现了。
写时复制
在某些情况下，Linux 操作系统内核中的页缓存可能会被多个应用程序所共享，操作系统有可能会将用户应用程序地址空间缓冲区中的页面映射到操作系统内核地址空间中去。如果某个应用程序想要对这共享的数据调用write()系统调用，那么它就可能破坏内核缓冲区中的共享数据，传统的write()系统调用并没有提供任何显示的加锁操作，Linux 中引入了写时复制这样一种技术用来保护数据。
写时复制的基本思想是如果有多个应用程序需要同时访问同一块数据，那么可以为这些应用程序分配指向这块数据的指针，在每一个应用程序看来，它们都拥有这块数据的一份数据拷贝，当其中一个应用程序需要对自己的这份数据拷贝进行修改的时候，就需要将数据真正地拷贝到该应用程序的地址空间中去，也就是说，该应用程序拥有了一份真正的私有数据拷贝，这样做是为了避免该应用程序对这块数据做的更改被其他应用程序看到。这个过程对于应用程序来说是透明的，如果应用程序永远不会对所访问的这块数据进行任何更改，那么就永远不需要将数据拷贝到应用程序自己的地址空间中去。这也是写时复制的最主要的优点。
写时复制的实现需要 MMU 的支持，MMU 需要知晓进程地址空间中哪些特殊的页面是只读的，当需要往这些页面中写数据的时候，MMU 就会发出一个异常给操作系统内核，操作系统内核就会分配新的物理存储空间，即将被写入数据的页面需要与新的物理存储位置相对应。它最大好处就是可以节约内存，不过对于操作系统内核来说，写时复制增加了其处理过程的复杂性。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                        Vim 常用命令快速查询
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-01</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/vim" class="post-tag i-tag
                            i-tag-other_3">
            #Vim
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-success">
            #Linux
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/vim-chang-yong-ming-ling-kuai-su-cha-xun.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容
Learning Vim The Pragmatic Way
《鸟哥的 Linux 私房菜》

Vim 可以认为是 Vi 的高级版本，Vim 可以用颜色或下划线的方式来显示一些特殊信息，您可以认为 Vi 是一个文本处理工具，而 Vim 是一个程序开发工具，现在大部分 Linux 的发行版都以 Vim 替换 Vi 了。在 Linux 命令行模式下有很多编辑器，但是 Vi 文本编辑器是所有 Unix-like 系统都会内置的，因此学会 Vi/Vim 的使用时非常有必要的，对于 Vi 的三种模式（命令模式、编辑模式、命令行模式）这里就不在做说明了，下面是一些比较常用的命令。
一般命令模式下



命令
说明




h、j、k、l
与键盘的方向键一一对应，分别为左、下、上、右，在键盘上着几个字母是排在一起的


Ctrl+f、Ctrl+b
分别对应键盘的「Page Down」、「Page Up」，我更习惯于这两个键，而不是前面的组合键


0、$
分别对应键盘的「Home」、「End」，即移动到该行的最前面/后面字符处


n&amp;lt;Enter&amp;gt;
n 为数字，光标向下移动 n 行


/word、?word
向光标之上/下寻找一个字符串名称为 word 的字符串


n、N
如果我们刚刚执行了上面上面的 /word 或 ?word 查找操作，那么 n 则表示重复前一个查找操作，可以简单理解为向下继续查找下一个名称为 word 的字符串，N 则与 n 刚好相反


:n1,n2s/word1/word2/g
在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将这个字符串替换为 word2，如果前面的 n1,n2 使用 1,$ 代替则表示从第一行到最后一行，最后的 g 后面可以加个 c，即 :1,$s/word1/word2/gc，这样就会在替换钱显示提示字符给用户确认（confirm）


x、X
分别对应键盘的「Del」、「Backspace」键


dd、yy
删除/复制光标所在的那一整行


p、P
p 将已复制的数据在光标下一行粘贴，P 粘贴在光标上一行


u
恢复前一个操作，类似于 Windows 下的 Ctrl+Z


Ctrl+r
重做上一个操作


.
小数点，重复上一个操作



命令行模式下



命令
说明




:w
将编辑的数据写入硬盘中


:w!
若文件属性为只读，强制写入该文件，不过到底能不能写入，还是跟文件权限有关系


:q、:q!
与 w 一样，q 为关闭的意思


:r [filename]
在编辑的数据中读入另一个文件的数据，即将[filename]这个文件的内容追加到光标所在行的后面


:w [filename]
将编辑的数据保存为另一个文件


:set nu/nonu
显示/不显示行号



编辑模式下



组合键
作用




[ctrl]+x -&amp;gt; [ctrl]+n
通过目前正在编辑的这个文件的内容文字作为关键字，予以自动补全


[ctrl]+x -&amp;gt; [ctrl]+f
以当前目录内的文件名作为关键字补全


[ctrl]+x -&amp;gt; [ctrl]+o
以扩展名作为语法补充，以 Vim 内置的关键字予以补全



当我们在使用 Vim 编辑器的时候，Vim 会在与被编辑的文件目录下再建立一个名为.filename.swp的文件，我们对文件的操作都会记录到这个 swp 文件中去，如果系统因为某些原因掉线了，就可以利用这个 swp 文件来恢复内容。如果存在对应的 swp 文件，那么 Vim 就会主动判断当前这个文件可能有问题，会给出相应的提示。
我们也可以给 Vim 环境设置一些个性化的参数，虽然在命令行模式下可以使用:set来设置，但是这样每次设置实在是太麻烦，因此我们可以设置一些全局的参数。Vim 的整体设置值一般放在/etc/vimrc中，我们一般通过修改~/.vimrc这个文件（默认不存在）来设置一些自己的参数，比如：
&amp;quot; 该文件的双引号是注释
set nu &amp;quot;在每一行的最前面显示行号
set autoindent &amp;quot; 自动缩进
set ruler &amp;quot; 可显示最后一行的状态
set bg=dark &amp;quot; 显示不同的底色色调
syntax on &amp;quot;进行语法检验，颜色显示，比如 C 语言等

最后附上一张命令速查卡，此图来源于Learning Vim The Pragmatic Way，PDF 版下载链接在这里。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
                        刘小绪同学随笔（2019-10-28）
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-28</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-error">
            #随笔
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/liu-xiao-xu-tong-xue-sui-bi-2019-10-28.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            分享一个视频：施利伦法，利用折射率的不同使肉眼不可见的物质可视化，我把它下下来了，如下：


在一位做酱香酒的朋友那里学了个鉴别真伪飞天茅台的方法，我不会喝酒所以没什么研究，实用性还请读者大人自行判断，反正我喝茅台的感觉与喝二锅头差不多，到嘴里都是一个味。
方法一：如果「酒」字里面的那一横，是图一的那个样子，那是真酒；而如果是图二的样子则是假酒。


方法二：在如图左边仙女标红圈那个位置，如果线条的交汇点是穿出去的，则为真，反之为假。



看了2019·菠萝科学奖颁奖典礼，一个沙雕、严谨、有趣......的节目，处处都透漏着尴尬又不失礼貌的微笑，永远向好奇心致敬。我个人认为这个节目最大的优点就是把常人眼里那种无趣、严谨的科学以一种有趣的方式呈现出来，这可以让大多数人更喜欢科学，让科学家在科研的道路上坚持的更久。
在怎样才能开开心心的呢中有提到过降低对事物的期望值，这里再详细谈一下降低期望值对学习的促进作用。以这两年大量冒出来的线上英语阅读打卡为例，只要打卡多少天就有小礼物，全勤甚至可以返还学费，这么一想那公司还怎么赚钱呢？原因就在于绝大部分人都只能坚持短短的几天，和健身卡的套路基本一致。
我想读者大人肯定都知道复利曲线，其实并不需要给自己定多么多么高远的目标，只需要每天坚持花一点时间一直去做，就能达到复利曲线的效果。之所以坚持不下去无非是因为学习很痛苦，而如果把学习变成像玩游戏一样有趣，那你肯定不会拒绝学习。比如上面说的英语学习，每天去背单词没几个人坚持的下来，那如果是每天看一集美剧呢？
人是需要被成就感驱动的，给自己一下定的目标太高很容易就气馁了，降低自己的期望值，把目标定小一点点，说不定每天都可以获得满满的成就感，配上一些有趣的方式、方法，学习这件事做起来简直妙不可言，其它事情也是一样的道理。

最近取关了很多公众号，互联网时代不得不承认网上的好文不少，但是大部分人都没有那么多精力去读完，与其走马观花的读一遍，我更愿意精读一篇文章后再从中挖掘信息。之前一直不肯取关一些公众号，总是觉得某天会有个重要信息从那里得到，刘未鹏老师说这是源于人「不肯关上一扇门」的心理，而实际关上一扇门可能增大我们的收益，注意力不至于被滑不到底的信息流骚扰。读过了却不一定领悟了，愈发赞同人与人学习的差距不在资质上，而在于花在思考上的时间与思考的深度。
同样为了不让太多事物让自己分心，我周末也花了些时间把很久没用的东西，很久没有穿的衣物等等都扔了，屋子一下显得宽敞了许多，忘记此前在哪里看到一篇文章有讲太多的家具会让自己分心，不过当时是找了一圈没舍得扔，因为每一件物品我好像总能想到它在某个场景下的作用，而现实情况是那些场景可能是我幻想出来的，或者当那个场景出现的时候，对应的物品也因为放的太久而无法使用了，还不如扔了算了。

下面是一些比较有意思的文章。
tylervigen.com 专门收集那些看起来高度相关但实际上毫不相关的数据，比如美国在科学、太空、技术方面的投入，与采用上吊、勒死、窒息方式自杀的案例，这两组数据之间的相关性高达 99.79% 。
https://bruno-simon.com 是一个超酷的网站主页，网站的源码在 Github。页面用到了 3D 导航，你可以像玩游戏一样在里面探索，也可以把这个网页当成一个减压神器。
一些可能会颠覆你对世界的认识的照片 文章里面列举了大量可能颠覆你认知的照片，比如世界上第一张自拍花了 30 秒，即保持一个姿势 30 秒不动。
Youtube 上最近有个视频火了：美国加州某地的微波传输站失灵了，技术人员在微波天线罩里面发现了 300磅（136公斤）的橡子，大家都认为是松鼠干的，根据美国「国家地理」的文章 Meet the Bird that Filled an Antenna With Acorns 介绍，在微波天线罩里藏橡子的很可能不是松鼠，而是橡子啄木鸟。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2019-10-28">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">
                        Nginx 文件操作优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-19</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/nginx" class="post-tag i-tag
                            i-tag-info">
            #Nginx
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-banana">
            #Linux
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-success">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/nginx-wen-jian-cao-zuo-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Nginx AIO 机制与 sendfile 机制
sendfile 适用场景
扯淡 Nginx 的 sendfile 零拷贝的概念
浅析 Linux 中的零拷贝技术
Linux man-pages sendfile

今天在看 Nginx 配置的时候，看到了一个sendfile配置项，它可以配置在http、server、location三个块中，出于好奇就去查了一下sendfile的作用。
文件下载是服务器的基本功能，其基本流程就是循环的从磁盘读取文件内容到缓冲区，再将缓冲区内容发送到socket文件，程序员基本都会写出类似下面看起来比较高效的程序。
while((n = read(diskfd, buf, BUF_SIZE)) &amp;gt; 0)
    write(sockfd, buf , n);

上面程序中我们使用了read和write两个系统调用，看起来也已经没有什么优化空间了。这里的read和write屏蔽了系统内部的操作，我们并不知道操作系统做了什么，现实情况却是由于 Linux 的 I/O 操作默认是缓冲 I/O，上面的程序发生了多次不必要的数据拷贝与上下文切换。
上述两行代码执行流程大致可以描述如下：

系统调用read产生一个上下文切换，从用户态切换到内核态；
DMA 执行拷贝（现在都是 DMA 了吧！），把文件数据拷贝到内核缓冲区；
文件数据从内核缓冲区拷贝到用户缓冲区；
read调用返回，从内核态切换为用户态；
系统调用write产生一个上下文切换，从用户态切换到内核态；
把步骤 3 读到的数据从用户缓冲区拷贝到 Socket 缓冲区；
系统调用write返回，从内核态切换到用户态；
DMA 从 Socket 缓冲区把数据拷贝到协议栈。


可以看到两行程序共发生了 4 次拷贝和 4 次上下文切换，其中 DMA 进行的数据拷贝不需要 CPU 访问数据，所以整个过程需要 CPU 访问两次数据。很明显中间有些拷贝和上下文切换是不需要的，sendfile就是来解决这个问题的，它是从 2.1 版本内核开始引入的，这里放个 2.6 版本的源码。
系统调用sendfile是将in_fd的内容发送到out_fd，描述符out_fd在 Linux 2.6.33 之前，必须指向套接字文件，自 2.6.33 开始，out_fd可以是任何文件；in_fd只能是支持mmap的文件（mmap是一种内存映射方法，在被调用进程的虚拟地址空间中创建一个新的指定文件的映射）。
所以当 Nginx 是一个静态服务器时，开启sendfile配置项是可以大大提高 Nginx 性能的，但是当把 Nginx 作为一个反向代理服务器时，sendfile则没有什么用，因为当 Nginx 时反向代理服务器时，in_fd就是一个套接字，这不符合sendfile的参数要求。

可以看到现在我们只需要一次拷贝就可以完成功能了，但是能否把这一次拷贝也省略掉呢？我们可以借助硬件来实现，仅仅需要把缓冲区描述符和文件长度传过去，这样 DMA 直接将缓冲区的数据打包发送到网络中就可以了。
这样就实现了零拷贝技术，需要注意的是这里所说的零拷贝是相对操作系统而言的，即在内核空间不存在冗余数据。数据的实际走向是从硬盘到内存，再从内存到设备。
Nginx 中还有一个aio配置，它的作用是启用内核级别的异步 I/O 功能，要使aio生效需要将directio开启（directio对大文件的读取速度有优化作用），aio很适合大文件的传送。需要注意的是sendfile和aio是互斥的，不可同时兼得二者，因此我们可以设置一个文件大小限制，超过该阀值使用aio，低于该阀值使用sendfile。
location /video/ {
    sendfile on;
    sendfile_max_chunk 256k; 
    aio threads;
    directio 512k;
    output_buffers 1 128k;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/javascript-gao-ji-zhi-shi-ji-qiao">
                        JavaScript 高级知识技巧
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-13</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/javascript" class="post-tag i-tag
                            i-tag-other_3">
            #JavaScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-info">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/javascript-gao-ji-zhi-shi-ji-qiao">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/javascript-gao-ji-zhi-shi-ji-qiao.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            对象
Js 共有number、string、boolean、null、undefined、object六种主要类型，除了object的其它五中类型都属于基本类型，它们本身并不是对象。但是null有时会被当做对象处理，其原因在于不同的对象在底层都表示为二进制，在 js 中二进制前三位都为 0 的话就会被判定为object类型，而null的二进制表示全是 0， 所以使用typeof操作符会返回object，而后续的 Js 版本为了兼容前面埋下的坑，也就没有修复这个 bug。
&amp;quot;I&#39;m a string&amp;quot;本身是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度、访问某个字符等，那就需要将其转换为String类型，在必要的时候 js 会自动帮我们完成这种转换，也就是说我们并不需要用new String(&#39;I&#39;m a string&#39;)来显示的创建一个对象。类似的像使用42.359.toFixed(2)时，引擎也会自动把数字转换为Number对象。
null和undefined没有对应的构造形式，它们只有文字形式。相反，Date只有构造，没有文字形式。对于Object、Array、Function和RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。
Array 类型
数组类型有一套更加结构化的值存储机制，但是要记住的是，数组也是对象，所以有趣的是你也可以给数组添加属性。
var myArray = [&amp;quot;foo&amp;quot;, 42, &amp;quot;bar&amp;quot;];
myArray.baz = &amp;quot;baz&amp;quot;;
myArray.length; // 3
myArray.baz; // &amp;quot;baz&amp;quot;

数组类型的length属性是比较有特点的，它的特点在于不是只读的，也就是说你可以修改它的值。因此可以通过设置这个属性从数组末尾删除或添加新的项。
var colors = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;];
colors.length = 2;
console.info(colors[2]); // undefined
colors.length = 4;
console.info(colors[4]); // undefined
// 向后面追加元素
colors[colors.length] = &amp;quot;black&amp;quot;;

数组还有一些很方便的迭代方法，比如every()、filter()、forEach()、map()、some()，这些方法都不会修改数组中包含的值，传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。
Function 类型
在 ECMAScript 中，每个函数都是Function类的实例，而且都与其它引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。
在函数的内部有两个特殊的对象，this和arguments。arguments对象有callee和caller属性。caller用来指向调用它的function对象，若直接在全局环境下调用，则会返回null；callee用来指向当前执行函数，所以我们可以通过下面的方式来实现阶乘函数。
function factorial(num) {
    if (num &amp;lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}

每个函数都包含两个非继承而来的方法，apply()和call()，这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是Array的实例，也可以是arguments对象。call()方法与apply()方法的作用相同，它们的区别仅仅在于接收参数的方式不同，在使用call()方法时必须逐个列举出来。
window.color = &amp;quot;red&amp;quot;;
var o = {color: &amp;quot;blue&amp;quot;};
function sayColor() {
    console.info(this.color);
}
sayColor(); // red
sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
sayColor.apply(o); // blue

需要注意的是，在严格模式下未指定环境对象而调用函数，则this值不会转型为window，除非明确把函数添加到某个对象或者调用apply()或call()。
安全的类型检查
Js 内置的类型检查机制并不是完全可靠的，比如在 Safari（第5版前），对正则表达式应用typeof操作符会返回function；像instanceof在存在多个全局作用域（包含 frame）的情况下，也会返回不可靠的结果；前文提到的 Js 一开始埋下的坑也会导致类型检查出错。
我们可以使用toString()方法来达到安全类型检查的目的，在任何值上调用Object原生的toString()方法都会返回一个[object NativeConstructorName]格式的字符串，下面以检查数组为例。
Object.prototype.toString.call([]); // &amp;quot;[object Array]&amp;quot;
function isArray(val) {
    return Object.prototype.toString.call(val) == &amp;quot;[object Array]&amp;quot;;
}


作用域安全的构造函数
构造函数其实就是一个使用new操作符调用的函数，当使用new操作符调用时，构造函数内用到的this对象会指向新创建的对象实例，比如我们有下面的构造函数。
function Person(name, age) {
    this.name = name;
    this.age = age;
}

现在的问题在于，要是我们不使用new操作符呢？会发生什么！
let person = Person(&#39;name&#39;, 23);
console.info(window.name); // name
console.info(window.age); // 23

很明显，这里污染了全局作用域，原因就在于没有使用new操作符调用构造函数，此时它就会被当作一个普通的函数被调用，this就被解析成了window对象。我们需要将构造函数修改为先确认this是否是正确类型的实例，如果不是则创建新的实例并返回。
function Person(name, age) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
    } else {
        return new Person(name, age);
    }
}

高级定时器
大部分人都知道使用setTimeout()和setInterval()可以方便的创建定时任务，看起来好像 Js 也是多线程的一样，实际上定时器仅仅是计划代码在未来的某个时间执行，但是执行时机是不能保证的。因为在页面的生命周期中，不同时间可能有其它代码控制着 JavaScript 进程。
这里需要注意一下setInterval()函数，仅当没有该定时器的任何其他代码实例时，Js 引起才会将定时器代码添加到队列中。这样可以避免定时器代码可能在代码再次被添加到队列之前还没有完成执行，进而导致定时器代码连续运行好几次的问题。但是这也导致了另外的问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。
假设某个click事件处理程序使用setInterval()设置了一个 200ms 间隔的重复定时器。如果这个事件处理程序花了 300ms 多的时间完成，同时定时器代码也花了差不多了的时间，就会同时出现跳过间隔切连续运行定时器代码的情况。
为了避免setInterval()的重复定时器的这两个缺点，我们可以使用如下模式的链式setTimeout()，代码一看就懂什么意思了。
setTimeout(function() {
    // 处理中
    setTimeout(arguements.callee, interval);
}, interval)

消息队列与事件循环
如下图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。

右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。
JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。
来看个例子：执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&amp;gt; 5s）后，再点击两下，整个过程的输出结果是什么？
setTimeout(function(){
    for(var i = 0; i &amp;lt; 100000000; i++){}
    console.log(&#39;timer a&#39;);
}, 0)
for(var j = 0; j &amp;lt; 5; j++){
    console.log(j);
}
setTimeout(function(){
    console.log(&#39;timer b&#39;);
}, 0)
function waitFiveSeconds(){
    var now = (new Date()).getTime();
    while(((new Date()).getTime() - now) &amp;lt; 5000){}
    console.log(&#39;finished waiting&#39;);
}
document.addEventListener(&#39;click&#39;, function(){
    console.log(&#39;click&#39;);
})
console.log(&#39;click begin&#39;);
waitFiveSeconds();

首先，先执行同步任务。其中waitFiveSeconds是耗时操作，持续执行长达 5s。然后，在 Js 引擎线程执行的时候，&#39;timer a&#39;对应的定时器产生的回调、&#39;timer b&#39;对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于 Js 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务，最后，5s 后的两次 click 事件被放入消息队列，由于此时 Js 引擎线程空闲，便被立即执行了。因此会产生下面的输出顺序。
0
1
2
3
4
click begin
finished waiting
click
click
timer a
timer b
click
click


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/javascript-gao-ji-zhi-shi-ji-qiao">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/jia-li-de-gou">
                        家里的狗
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-12</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/san-wen" class="post-tag i-tag
                            i-tag-success">
            #散文
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-success">
            #随笔
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/jia-li-de-gou">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/jia-li-de-gou.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            为了防止晚上有人来家里偷东西，几乎家家户户都至少会养一只狗。在我的记忆中，我家一开始是没有狗的。
忘记是哪一年夏天的一个清晨，天还没有大亮，我隐约看见在牛棚后面的空地有个黑影，走近一点仔细一看，原来是一只不知道从哪里来的一只黑狗。
它惊恐的看着我，眼神中夹杂着恐惧与无助，佝偻的身子比弓还要弯，倒是很像一个活着的牛轭。他的身子还没有草高，露水把全身的毛都打湿了，还沾着一些不知名的植物种子。我和它对视着，恐惧慢慢填满了它的眼球，我害怕吓到它，赶紧走开去告诉妈。
妈远远看了一眼，让我别管它。随后妈把装着昨晚剩饭的猪食瓢放到牛棚后面的一块石头上，黑狗看见妈带着武器走近早就跑了，我吃早饭时还不时去望望它在不在，有没有吃妈给放在那里的饭。
妈已经把猪喂完准备下地干活了，仍旧没有再次发现黑狗的踪影，也没见猪食瓢有什么变化，我心里有一点点的失落，黑狗应该是已经逃走了吧。
晚上吃完饭妈去拿猪食瓢，告诉我里面的饭已经被吃的一粒不剩，我心里开始期待和它的再次见面。第二天早晨果然见到它了，身上已经没有昨天那么湿了，显然没有前一天来这里时钻的草丛多，妈依旧用猪食瓢装着米饭和米汤放在牛棚后的那个石头上。
就这样过了几日，黑狗走进了我家的屋檐，它的样子实在太丑了。每一根肋骨都清晰的扎眼，看起来爸的手指都比它的小腿粗，感觉下一秒它就会死去。
我并不喜欢它，甚至还有些讨厌它，我实在找不到更丑的词来形容它，不过是出于心里的怜悯与对生命的敬畏，会在吃饭的时候给它丢几个我不吃的肥肉，被烟熏黑的那一层肉边我也丢给它......
有一次同村的一个人路过家门口时，看见那只黑狗吓的赶紧往妈身后躲。“有我在，它不敢咬。”，妈说。邻居夸夸妈说：“这个狗儿喂得好肥”。妈自豪的告诉那个人这只狗每天还送林儿（我）上学。
是的，我也不知道什么时候我已经和大黑狗变得如此亲密了，它每天早上会把我送到山顶的学校，我每天下午回家做完作业会和它一起到田间追逐。在学校也常常会给同学们说大黑狗胸前的那长成了“人”字的一片白毛，我一直相信“人”字是老天爷特地印在它身上，用来告诉我大黑狗是他派来的使者。
大黑狗来我家时已经很老很老了，是我读三年级的某一天，它像往常一样把我送到学校，但是我下午回家却不见它的踪影，一直等到晚上都没有见它回来。那些天我放学回家第一件事就是朝我和它常去的那些地方大声的唤它。
不到一个月后的一天早晨，像大黑狗第一次来我家附近时的场景一样，湿漉漉的身子带着些杂草种子，不同的是它身旁还跟着一只背部有些黑毛的小黄狗，小黄狗胸前也有一个很明显的“人”字。我赶紧去用猪食瓢盛满饭放在它面前，它吃了几口就又走了。
就这样，大黑狗离开了我，给我留下了一只小小的黄奶狗。我不知道它是去找它原来的主人去了，还是觉得自己老了，不愿意让我看见它倒下的样子，反正它就是再也没有回来过。
小黄狗长成了大黄狗，我对这只大黄狗的印象很浅，只记得爸妈把这只黄狗送给了外婆家附近的亲戚，我们留下了它生的一只小黄狗。外婆知道我们把大黄狗送人，还狠狠的批评了爸妈，说自己来家里的狗不能送人。
自然小黄狗很快就长成了大黄狗，我像以前一样也偷偷给大黄狗吃肉，逐渐开始懂事的妹妹也会背着爸妈给它肉吃，我和妹都会夹几片我们压根就不吃的肥肉，离开饭桌假装是到外面吃饭，实际上是给大黄狗送肉去了。
我到离家 30 多公里的镇上读高中，每个月才回家一次。每次离家大黄狗都会送我到集市去赶车，我会在寒暑假的黄昏和它到新修的公路去追逐，带它去它自己一个人不敢去探索的地方。
上大学后和大黄狗相处的时间更少了，听爸妈说它会经常跑到外婆家，外婆好吃好喝的招待它，招呼都不打一声就又跑回来了。还经常和邻居家的狗到麦子地打闹，要把一大片麦子弄倒才肯回家。
每学期回家在离家还有四五百米的地方都会听到它的吠叫，因为它把我当陌生人了。但是只要我大喊一声，它就会立刻停止吠叫，飞奔到我这里，兴奋的往我身上爬，把它的前爪往我身上搭；我努力不让它碰到我的衣服，然而每次到家时我都带着一身泥巴做的狗爪印。
现在大黄狗已经 10 多岁了，它就像大黑狗当年送我一样每天送我妹上学。我也已经走入职场开始工作，待在家里的时间更少了，我不知道它还能活多久，生怕哪次爸妈打电话时会给我说大黄狗死了，只要爸妈没有在电话中提及大黄狗，我都是非常开心的，因为那就代表着它依旧健健康康的活着。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/jia-li-de-gou">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/o9IjztOrR">
                        怎样才能开开心心的呢？
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-08</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/Z_0XCM_Cy" class="post-tag i-tag
                            i-tag-other_1">
            #随笔
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/94PzxqinO" class="post-tag i-tag
                            i-tag-error">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/o9IjztOrR">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/o9IjztOrR.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            好几个月没有发文章了，主要是因为觉得自己太菜了，肚子里的东西太多浮于表面（实际上肚子也没有东西），也写不出来什么深度。不知道大家发现没有，现在很多公众号的味道都变了，一者是肚子里的货已经吐的差不多了，二者是在自媒体疯狂变现的年代，太多作者都开始为流量而写作，已经忘记了原来的初心。好友说长期不发文，突然发会掉粉的，我也想试试会掉下去多少。
说到为流量写作，其实并不是自媒体作者天天在干的事，专业的记者也在做这些事情。从商业角度来看，一篇有深度而没有阅读量的文章肯定是比不上一篇适合大众口味但阅读量高的文章。
媒体总是会挑那些吸引眼球的事件来报道，因为负面故事总比中性或正面故事更具有戏剧性，而且人在进化的过程中保留了对一些事物的恐惧感，这些恐惧感根植于我们大脑的深处，它们对我们祖先的生存是有帮助的。在现在的这个时代，你也很容易就把眼球放到那些能够激发我们本能的故事上。
包含地震、恐怖袭击、战争、疾病、难民等等字眼的标题总是容易成为头版头条（现在朋友圈肯定都在传四川内江的地震），而像“在过去 100 年，死于自然灾害的人数几乎减少了四分之三”一类的标题总是不会收获多少阅读量，就更不具备什么商业价值了。大家都在说信息茧房，人类的本能也是造成信息茧房的原因之一。

周四和一个同事一起散步的时候，他问了我一句话：“小老虎，你为什么总是能保持这么开心呢？”（小老虎是在部门大家对我的称呼）我思考了几秒，不知道怎么回答同事的问题。对哦，我是怎么保持每天都这么开心的？是我给他们的错觉还是我确实就这么开心呢？于是给了同事一个简单的答案：“当你变得没心没肺的时候，你就会超开心；另外降低对事物的期望值，这样你就总能收到正反馈，会把你的开心加成。”
像之前一样，我又成长为同事圈子里的小开心果了。其实我也不是一直开心的，可能就是我这个人比较逗比，我一直认为逗比是一种生活态度。但在公司我同样怼大叔、怼领导，不管我是不是真的开心，既然给大家的印象是开开心心的，那就假装我是一直都开心的吧。
我常常开玩笑说的一句话：“你对它笑，它就会对你笑，如果它不对你笑，那就对它多笑几次”。你对它笑，你肯定希望对方也给你回一个笑，但是我和大多数人不同的是我降低了期望值，我从来不期望对方能给我一个笑容，于是当对方给了你一个笑容的时候，那就是意外地收获，如果是一个大大的甜甜的笑容，就会突然冒出来幸福来的太突然了感觉。降低期望值也是一个很适合长期学习某项技能的方法，过高的期望值总是会让你放弃。
很多人说情商是为了别人高兴，话外音就是不想委屈自己迁就别人。但是你让别人高兴了就是与人方便，那对方自然会给你方便，自己方便了不就是高兴吗，所以对这个世界好一点，降低对它的期望值，你就总是能开开心心的过日子。

毕业这一年认识了很多人，现在我日常接触的圈子差不多有四个，同事这个圈子没啥特别的，团队氛围比较好，时常在晚上悄悄定个会议室，大家一起打王者；推特、微信等软件里面结交的互联网大佬圈我插不上话，不敢说；然后是我两任房东带我进的圈子，和高校毕业人群所建立的圈子完全不一样。
这群人大部分对我都很好，我目前比较害怕见到现任房东，因为基本上见到他就是出去吃饭。我住在房东隔壁，刚搬过来的时候一出门见到他：“小光，走，去吃饭。”房东的吃饭一般是两场，一场到餐厅点菜吃到 11：00-12：00 的样子，然后再继续下半场烧烤，在房东的带领下，我一个月长了 10 多斤。
于是我现在出房门的时候，先瞅瞅房东在不在，如果不在就直接坐电梯下楼，如果在就先下到 5 楼，再坐电梯。所以我们现在更多的是没事喝喝茶，偶尔吃吃饭，体重总算控制住了。
当然这个圈子也有不太好的人，有借了我钱后人就跑的没了踪影的人。但是我很庆幸我能这么早遇到这样的人，因为现在我借出去的并不多，如果再等 10 年我才能遇到这样的人，那我的损失可能就是很多很多倍了。

另外一个对我很重要的圈子就是校友会，我不清楚学校其它地区校友会是什么情况，更不清楚其它学校校友会是怎么样的，深圳校友会确实给了我一个温馨的感觉。校友之间都很单纯，学长学姐们都愿意带年轻人，最大有 79 级的师姐，最小的 15 级也已经到来，老人都会给新人讲他们所经历的事情，给年轻人传授经验。
当然由于学校带着军校的基因，校友里面没有什么非常非常出名的企业家，但是大家都是很尽心尽力的相互帮助。仅仅靠校友情能达到这样的效果，这一点确确实实是出乎我的意料了，校友会目前是对我开心的加成作用很大。
举个例子，一个学长新开了烧烤店，现在还没有开始对外营业，处于内测阶段。这一周每天店内至少有一半都是校友，店内的设计、装修、监控等等校友都在出力，当然像我这种没资源的学弟只能试吃给出改进意见了，一个人在外地能成为这样大家庭中的一员是很幸福的。

高校毕业生一年比一年多，媒体每年的标题都差不多一个意思：史上最难就业季。不得不承认独自一人到外地打工确实辛苦，大家都是独自承受着来自各方的压力，杭州闯红灯小伙的突然崩溃就是一个极端的例子。
我之前的住的地方，仅仅我知道的就有三个年龄比我还小的女孩被包养，仅从外部观察来看，她们过的其实挺好的，嘴角也常常挂着 45 度的微笑，倒是包养她们的人过的不是多随性。其中一个还开了一家奶茶店，我有幸也喝了几杯免费奶茶。
另外还有一些像我一样的打工者，我和前任房东也常常喝茶吃饭（现在也是），听他说住在那里的女孩子很多没有男朋友，但是她们晚上经常会带不同的男生回来，我想这对她们来说也是一种释压方式，当然住那里的男生可能只是没有带回来，房东不知道而已。

我不是太喜欢天天去研究某个业界名人所讲的话，也对各种各样的产品不是多感冒，不否认有些营销文案、产品功能、讲话内容是公司有意精心为之，但是有没有另外一种可能呢？是领导背错了台词、或者是说错了，而我们却非得去给它找出各种各样的原理。
周末闲着去感受了一下农民工的圈子，我去的是潮州彩塘镇的抛光厂，才知道我们平时用的那些锅碗瓢盆那么亮不是因为镀上了一层，而是硬生生给磨掉了一层，给磨亮的。最后再说一个，不知道你有没有注意到马路边的人行道上，总是会有一列地砖是有凸起的，有的是条状凸起，有的是圆点凸起，有没有想过为什么是这样的呢？
凸起是盲人走的道路，条状代表直走，圆点代表拐弯。是不是觉得这个世界对每个人都是美好的，既然这个世界对我们这么美好，那干嘛要不开心呢？

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/o9IjztOrR">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/bian-liang-ti-sheng-yu-zuo-yong-yu">
                        变量提升与作用域
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-08</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/javascript" class="post-tag i-tag
                            i-tag-error">
            #JavaScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-other_2">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/bian-liang-ti-sheng-yu-zuo-yong-yu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/bian-liang-ti-sheng-yu-zuo-yong-yu.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
lhs rhs是啥意思
《Javasript 高级程序设计（第三版）》
《你不知道的 JavaScript（上卷）》

几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为作用域。
编译原理
我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。
传统语言在执行之前会经历三个步骤：分词/词法分析、解析/语法分析、代码生成，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。
我们需要先了解三个名词。引擎：从头到尾负责整个 js 程序的编译及执行过程；编译器：负责词法分析及代码生成；作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
var a = 2;，我们以这段程序为例，它首先声明了变量a，然后将2赋值给变量a。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
变量提升
用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码
console.log(a);
var a = 2;

上述代码在a声明之前访问了变量a，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是undefined。
回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理。所以我们前面列出来的代码实际上会变成下面这个样子。
var a;
console.log(a);
a = 2;

这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。
foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}

这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。
function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};

可以看到，虽然var foo出现在function foo()之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。
LHS 和 RHS 查询
LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是赋值操作符的左侧和右侧。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。
RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。
console.info(a);我们深入研究一下这句代码。这里对a的引用是 RHS 引用，因为这里a并没有赋予任何值，相应的需要查找并取得a的值，这样才能传递给console.info()。
a = 2;对a的引用则是一个 LHS 引用，因为实际上我们并关心a当前的值是什么，只是想为= 2这个赋值操作找到一个目标。
function foo(a) {
    console.info(a);
}
foo(2);

为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行foo()函数的调用需要对foo进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给foo()函数时，2 会被分配给参数a，为了给参数a（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了a = 2的语句。
前文已经说过了console.info(a);会对a进行一次 RHS 查询，需要注意的是console.info()本身也需要一个引用才能执行，因此会对console对象进行 RHS 查询，并检查得到的值中是否有一个log方法。
为什么区分 LHS 和 RHS
我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。
function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);

第一次对b进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。
引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。

需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。

接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。
作用域链
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。
每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。
当代码在环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。
var color = &amp;quot;blue&amp;quot;;

function changeColor() {
    var anotherColor = &amp;quot;red&amp;quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();

下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。
window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor

作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：
var color = &amp;quot;blue&amp;quot;;

function getColor() {
    var color = &amp;quot;red&amp;quot;;
    return color;
}

console.info(getColor()); // &amp;quot;red&amp;quot;

在getColor()中沿着作用域链在局部环境中已经找到了color，所以搜索就停止了，也就是说任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/bian-liang-ti-sheng-yu-zuo-yong-yu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/duo-xing-zai-ru-han-shu">
                        惰性载入函数
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-06</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/javascript" class="post-tag i-tag
                            i-tag-warning">
            #JavaScript
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/duo-xing-zai-ru-han-shu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/duo-xing-zai-ru-han-shu.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考资料：
《JavaScript 高级程序设计（第三版）》
JavaScript专题之惰性函数
深入理解javascript函数进阶之惰性函数

因为不同厂商的浏览器相互之间存在一些行为上的差异，很多 js 代码包含了大量的if语句，将执行引导到正确的分支代码中去，比如下面的例子。
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        if (typeof arguments.callee.activeXString != &#39;string&#39;) {
            var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
            var i, len;
            for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (e) {
                    // skip
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&#39;No XHR object available.&#39;);
    }
}

我们可以发现，在浏览器每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查，但是很明显当第一次检查之后，我们就应该知道浏览器是否支持我们所需要的能力，因此除第一次之外的检查都是多余的。即使只有一个if语句也肯定要比没有if语句慢，所以if语句不必每次都执行，那么代码可以运行的更快一些，惰性载入就是用来解决这种问题的技巧。
函数重写
要理解惰性载入函数的原理，我们有必要先理解一下函数重写技术，由于一个函数可以返回另一个函数，因此可以在函数内部用新的函数来覆盖旧的函数。
function sayHi() {
    console.info(&#39;Hi&#39;);
    sayHi = function() {
        console.info(&#39;Hello&#39;);
    }
}

我们第一次调用sayHi()函数时，控制台会打印出Hi，全局变量sayHi被重新定义，被赋予了新的函数，从第二次开始之后的调用都会打印出Hello。惰性载入函数的本质就是函数重写，惰性载入的意思就是函数执行的分支只会发生一次。
惰性载入
我们来看一个例子（例子来源于冴羽所写的JavaScript专题之惰性函数）。现在需要写一个foo函数，这个函数返回首次调用时的Date对象，注意是首次。
方案一
var t;
function foo() {
    if (t) return t;
    t = new Date()
    return t;
}
// 此方案存在两个问题，一是污染了全局变量
// 二是每次调用都需要进行一次判断

方案二
var foo = (function() {
    var t;
    return function() {
        if (t) return t;
        t = new Date();
        return t;
    }
})();
// 使用闭包来避免污染全局变量，
// 但是还是没有解决每次调用都需要进行一次判断的问题

方案三
function foo() {
    if (foo.t) return foo.t;
    foo.t = new Date();
    return foo.t;
}
// 函数也是一种对象，利用这个特性也可以解决
// 和方案二一样，还差一个问题没有解决

方案四
var foo = function() {
    var t = new Date();
    foo = function() {
        return t;
    };
    return foo();
};
// 利用惰性载入技巧，即重写函数

惰性载入函数有两种实现方式，第一种是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一种按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行分支了。
第二种实现方式是在声明函数时就指定适当的函数。这样第一次调用时就不会损失性能了，而是在代码首次加载时会损失一点性能，即是利用闭包写一个自执行的函数。
改进 createXHR
有了上面的基础，我们就可以将createXHR()改进为下列形式，这样就不用每次调用都进行判断了。
// 第一种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        createXHR = function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}

// 第二种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        return function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/duo-xing-zai-ru-han-shu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">
                        非设计师需要知道的四个设计原则
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-06-22</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/i4kET55EC" class="post-tag i-tag
                            i-tag-error">
            #翻译
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/vhSkGeYf1D" class="post-tag i-tag
                            i-tag-success">
            #设计
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
作者：Anna 4erepawko Mészáros，UI/UX 设计师。
关注作者： Medium、Twitter

这篇文章是写给无力邀请专业设计师的所有内容创作者的，以及设计师异常忙碌的团队的非设计师们。如果您按照这些简单的步骤进行操作，我保证您的设计会变得更好。
这些 Tips 来源于我对身边非设计朋友的多年观察，家人与同事在日常生活中也需要设计他们的东西。比如简历、作品集，Facebook 和 Instagram 上帖子要使用的图片，YouTube 视频的缩略图等。
所有这些人都向我寻求帮助与建议，希望能让他们的东西看起来更好。我坚信「授人以鱼不如授人以渔」，所以我试图提供更有价值的建议，以便他们在未来也能解决类似的问题。
随着时间的推移，我意识到我一直在给所有人提供相同的建议，虽然每次所使用的措辞不同，但我所有的建议都可以提炼为以下四个原则。
这些 Tips 会帮您创造出美丽动人的设计吗？答案是不会！它们只会帮您创造出色、清晰且易于理解的设计。是每个人都可以轻松理解和互动吗？那当然，所以不多说废话，下面我就向您逐一展示。
对比
确保所有元素之间有足够的对比度。为什么？因为那些略有差异但是又不够不同东西，创造了一种恐怖谷。人类的眼睛会排斥它们，对它们感到厌恶、难以理解。我们不希望它们出现在我们的设计中，难道不是吗？

恐怖谷理论，是一个关于人类对机器人和非人类物体的感觉的假设。如果一个非人类实体不够拟人，那么它身上的人类特征会很容易辨认；而当它足够拟人时，他身上的非人类特征则会变得很容易辨认。因此会在人类观察者眼中产生一种古怪的感觉，想想您看到病患者或者尸体时的感觉。

因此您设计的元素要么完全相同，要么具有显著差异。
您可以从下面四个方面来突出对比：
1、颜色：浅色上使用暗色，反之亦然
示例： 切勿在浅蓝色上使用浅灰色或浅粉红色等灰色组合，它们会造成阅读/互动上的极大困难。

2、大小：相邻元素要么大小完全相同，要么大小区别很大
示例： 不要将 32pt 和 36pt 的文本放在一起；18pt 和 36pt 放在一起会显得更加协调。

3、粗细：与大小一样，相邻元素的粗细要么完全相同，要么有明显的区别
示例： 不要将相同字体的粗体与黑体放在一起，因为它们看起来太相似了；将黑体与细体放在一起会显得很协调。

4、风格：不要将一个斜体类型放在另一个斜体类型旁边，或者在一个衬线字体旁边放置另一个衬线字体。应该组合不同的东西。
示例： 不要将 Times New Roman 与 Georgia 放在一起，它们看起来太相似了，应该组合完全不同的风格。

一致性
确保相似的元素以相似的方式出现。为什么呢？首先，通过确保确保事物一致性，您可以让用户将注意力集中在设计的重要方面，而不是被随时变化的元素分散注意力。
其次，一致性也增加了用户对您的信任，使事物看起来实际上是设计的，而不是简单快速拼凑出来的。
一旦你选择了具体的风格，就要毫不犹豫的坚持下去，这里所说的风格包括字体、颜色、阴影、栅格、对齐、装饰风格等等。

当您处理许多相邻的不同部分时（比如 YouTube 的视频缩略图或是中型文章的封面），您应该为所有部分选择一种整体风格，并坚持使用。
奥卡姆剃刀 减少视觉噪音
在您的设计中，使用的元素越少越好。为什么呢？因为人类的大脑很难在输入过载的情况下处理信息并作出决策。您应该使用尽可能少的装饰元素（字体、颜色、阴影、图标等等）。
将奥卡姆剃刀应用于所有内容。如果只需要两个元素就能满足需求，那么就不要使用 3 个元素；如果 10 个元素实现所需的功能，那么就不要用 20 个元素。

如果您不喜欢古老的英国哲学家风格，更喜欢您在 Netflix（一家美国流媒体提供商）上看到的东西。请将怦然心动的人生整理魔法应用到您的设计中。

《怦然心动的人生整理魔法》是美国流媒体提供商Netflix于2019年1月1日首播的一档真人实境秀节目。节目由日本“整理咨询顾问” 近藤麻理惠主创。她在每集节目中拜访一个家庭，帮助他们整理自己的房间。
近藤麻理惠认为整理房间时应当将物品分为五类：衣物、书籍、纸张文件、杂物和情感纪念品；在整理时拿起每件物品，如果能使自己“怦然心动”则留下，如果不能则要感谢物品的贡献然后与其告别。

间距
元素的位置会发送关于其含义的元级别消息。为什么这很重要？因为了解如何放置元素以及在它们周围预留了多少空间有助于降低设计的复杂性，因此会使人更加愉悦，并且更容易交互。
在您的设计中使用间距来传达下面 3 个方面的信息：
1、接近度 = 相关性
与其它元素相比，彼此更接近的事物被认为它们有更强的相关性。这是最重要的，因为我觉得它常常容易被忽视。
它可以以很多不同的方式应用，比如行与行之间应该有一定的间距，而不是一行中每个单词之间的间距那么小；同样不同段落之间的空间也比段落内的行空间要大。

元素之间的间距应该小于元素与组合边缘之间的间距。

标签和支撑信息应该位于其相关元素附近。

2、留白
结合奥卡姆剃刀，给您的设计尽可能留白，去整理它们，使它们的意义更加明显。
如果把太多元素放在有限的空间里，就像同时听三首不同的哥，很难理解别人在说什么。

3、重要性与顺序
这是一个很普通的常识，但是我还是要在这里提到它。
最重要的事情放在第一位，使它们占据最大的空间，用一系列的事物来传达秩序。
结束语
恭喜您！如果您按照这些 Tips 进行设计，那么按照行业标准，它可能看起来非常好。
For everything else, there is always a designer.

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/fei-she-ji-shi-xu-yao-zhi-dao-de-si-ge-she-ji-yuan-ze">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
            <a href="https://mengxiaoxu.github.io/" class="page-btn btn">上一页</a>
            
                
                    <a href="https://mengxiaoxu.github.io/page/3/" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1583656981045)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin">MySQL 中的索引</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua">Schema 与数据类型优化</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2020-02-18">刘小绪同学随笔（2020-02-18）</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">MySQL 架构与历史</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">浅析正则表达式原理</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>