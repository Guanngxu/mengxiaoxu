<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1569597530875">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1569597530875" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/aSkANU6p0">
                        记录在南京大学的半天
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-12-12</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/94PzxqinO" class="post-tag i-tag
                            i-tag-banana">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/aSkANU6p0" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/aSkANU6p0.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            因为工作需要，到南京出差了半个月，中间利用周末和最好的朋友疯了一天，之后自己又一个人到南京大学鼓楼校区逛了逛。

不会勾搭妹子的我总是能勾搭到老爷爷，到南大就勾搭了一个 86 岁高龄的老教授，他毕业于中山大学，年轻时候是做地质工作的。
我就像个熊孩子一样要爷爷给我讲有趣的故事，要听他讲我们这一代人或者是大部分人都不知道的历史。
爷爷虽然已经是快到耄耋之年的人了，但是对年轻时候的事记得很清楚，只是对最近的事记不起来。这篇文章仅仅是记录一下爷爷所讲的趣事。
爷爷年轻时候接到中科院的任务，前往内蒙古考察。在考察期间他们用汽车压死过一只狼，而且当时吃了狼肉，一行 30 多个人都吃过那匹狼的心，但是没有吃过狗肺。
据爷爷说，狼是很狡猾的动物，他们用汽车去追狼，狼就在原地不跑，等到你离它只有 10 来米的时候，突然拐弯跑了，这样的情况他们一共遇到了 6 次。这和《狼图腾》一书中的描写基本一致，狼有先进的军事文化。

爷爷告诉我，南大起源于金陵大学，南京大学的标志性建筑「北大楼」是个教堂的样子，金陵大学本来是个教会大学，现在的「北大楼」就是原来的「钟楼」。
南大的地下有隧道，是当年毛主席提倡「深挖洞、广积粮、不称霸」时挖的，目的是为了防空。后来被南京食品公司用来存放香蕉，就是那种没有熟的香蕉，在隧道里面放熟了，再拿出来卖。不过现在隧道所有的口都没堵上了，完全废弃了。
在南大，有一些楼中间有 5 层，然后到两遍就只有 3 层了，整体看来像是个三角形。实际上这些楼当年都是要修 8 层的，因为那时候没钱，建着建着发现没资金了，所以就封顶了。
但是南大计算中心那栋楼只有 3 层却不是因为没钱，而是因为它旁边是消防大队，本来也是要建 8 层的，消防队说建高了挡住了他们视线，不能及时发现火情。爷爷笑着对我说：“但是也没见他们在上面拿个望远镜望啊！”。
我们都知道「五四运动」，但是却很少有人知道「四五运动」，这个运动的起源就在南大，当时 300 多学生（我回来查资料说是 400）发起了这个运动，后来演变为全国性的运动，直接带动了半年后四人帮被粉碎。
那是爷爷是个老师，他说他们教职工是很支持这些学生的，但是不敢公开性的支持。学生们很聪明，把标语刷到火车上，但是所有出南京的火车都被四人帮用水把标语给冲刷掉了，学生们就用沥青往火车上面写，才通过火车把这项运动的信息带到了全国各地。

我回来后查了一点资料，「四五运动」的起源是因为周恩来总理的去世，四人帮居然压制人民群众悼念周恩来，诬陷邓小平，而那时的毛主席也已经病到无法行动。


人们把花圈都放到人民英雄纪念碑前悼念周总理，却被四人帮给清理了，北京广大人民群众在“还我花圈，还我战友”的口号下行成了天安门广场大规模的群众抗议运动。


那也是一个诗意的年代，人们通过写诗来表达自己心中的愤怒，把小瓶子挂在树上，蕴意着期待邓小平的归来。那段时间四人帮应该是很难过的，从姚文元的日记就可以看出来。

爷爷还给我讲了一点他们的研究，他们研究行政规划的很多人认为，中国现在的行政划分有很多缺点的，中国应该划分 50~80 个省级单位。现在中国的行政级别也有问题，宪法规定行政层级只有三级（这一点我没查），而现在很多地方县下面是镇，镇下面还有乡，严格讲这是违宪的。
快到午饭时间时，爷爷还教我写了一会儿字，有的简体字很难看，比如「龍飛鳳舞」用繁体字写出来很好看，但是用简体字写出来就特难看。要想练好毛笔字，把三个字写好了就行了，然而我现在只记得一个“飛”字了，这可能就是老师们常说的「你又还给我了」。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/aSkANU6p0">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/SpXxa8r-v">
                        为什么处理排序数组比未排序数组快
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-28</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-info">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/SpXxa8r-v" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/SpXxa8r-v.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            今天在群里看到一个有意思的问题——为什么处理排序数组比处理没有排序的数组要快，这个问题来源于 StackoverFlow，虽然我看到代码略微知道原因，但是模模糊糊不够清晰，搜了很多博客也讲的不够明白，所以就自己来总结了。
首先来看一下问题，下面是很简单的一段代码，随机生成一些数字，对其中大于 128 的元素求和，记录并打印求和所用时间。
import java.util.Arrays;
import java.util.Random;

public class Main
{
    public static void main(String[] args)
    {
        // Generate data
        int arraySize = 32768;
        int data[] = new int[arraySize];

        Random rnd = new Random(0);
        for (int c = 0; c &amp;lt; arraySize; ++c)
            data[c] = rnd.nextInt() % 256;

        // !!! With this, the next loop runs faster
        Arrays.sort(data);

        // Test
        long start = System.nanoTime();
        long sum = 0;

        for (int i = 0; i &amp;lt; 100000; ++i)
        {
            // Primary loop
            for (int c = 0; c &amp;lt; arraySize; ++c)
            {
                if (data[c] &amp;gt;= 128)
                    sum += data[c];
            }
        }

        System.out.println((System.nanoTime() - start) / 1000000000.0);
        System.out.println(&amp;quot;sum = &amp;quot; + sum);
    }
}

我的运行结果：分别在对数组排序和不排序的前提下测试，在不排序时所用的时间比先排好序所用时间平均要多 10 ms。这不是巧合，而是必然的结果。
问题就出在那个if判断上面，在旧文顺序、条件、循环语句的底层解释中其实已经提到了造成这种结果的原因，只是旧文中没有拿出具体的例子来说明。
为了把这个问题搞明白，需要先对流水线有一定的了解。计算机是指令流驱动的，执行的是一个一个的指令，而执行一条指令，又要经过取指、译码、执行、访存、写回、更新六个阶段（不同的划分方式所包含的阶段不一样）。
六个阶段使用的硬件基本是不一样的，如果一条指令执行完再去执行另一条指令，那么在这段时间里会有很多硬件处于空闲状态，要使计算机的速度变快，那么就不能让硬件停下来，所以有了流水线技术。
流水线技术通过将指令重叠来实现几条指令并行处理，下图表示的是三阶段指令时序，即把一个指令分为三个阶段。在第一条指令的 B 阶段，A 阶段相关的硬件是空闲的，于是可以将第二条指令的 A 阶段提前操作。

很明显，这种设计大幅提高了指令运行的效率，聪明的你可能发现问题了，要是不知道下一条指令是什么怎么办，那提前的阶段也就白干了，那样流水线不就失效了？没错，这就是导致开篇问题的原因。
让流水线出问题的情况有三种：1、数据相关，后一条指令需要用到前一条指令的运算结果；2、控制相关，比如无条件跳转，跳转的地址需要在译码阶段才能知道，所以跳转之后已经被取出的指令流水就需要清空；3、结构相关，由于一些指令需要的时钟周期长（比如浮点运算等），长时间占用硬件，导致之后的指令无法进入译码等阶段，即它们在争用同一套硬件。
代码中的if (data[c] &amp;gt;= 128)翻译成机器语言就是跳转指令，处理器事先并不知道要跳转到哪个分支，那难道就等知道了才开始下一条指令的取指工作吗？处理器选择了假装知道会跳转到哪个分支（不是谦虚，是真的假装知道），如果猜中了是运气好，而没有猜中那就浪费一点时间重新来干。
没有排序的数组，元素是随机排列的，每次data[c] &amp;gt;= 128的结果也是随机的，前面的经验就不可参考，所以下一次执行到这里理论上还是会有 50% 的可能会猜错，猜错了肯定就需要花时间来修改犯下的错误，自然就会浪费更多的时间。
对于排好序的数组，开始几次也需要靠猜，但是猜着猜着发现有规律啊，每次都是往同一个分支跳转，所以以后基本上每次都能猜中，当遍历到与 128 分界的地方，才会出现猜不中的情况，但是猜几次之后，发现这又有规律啊，每次都是朝着另外一个相同分支走的。
虽然都会猜错，但是在排好序的情况下猜错的几率远远小于未排序时的几率，最终呈现的结果就是处理排序数组比未排序数组快，其原因就是流水线发生了大量的控制相关现象，下面通俗一点，加深一下理解。

远在他方心仪多年的姑娘突然告诉你，其实她也喜欢你，激动的你三天三夜睡不着觉，决定开车前往她的城市，要和她待在一起，但是要去的路上有很多很多岔路，你只能使用的某某地图导航，作为老司机并且怀着立马要见到爱人心情的你，开车超快，什么样罚单都不在乎了。
地图定位已经跟不上你的速度了，为了尽快到达，遇到岔路你都是随机选一条路前进，遗憾的是，自己的选择不一定对（我们假设高速可以回退），走错路了就要重新回到分岔点，这就对应着未排序的情况。
现在岔路是有规律的，告诉你开始一直朝着一边走，到某个地点后会一直朝着另一边走，你只需要花点时间去探索一下开始朝左边还是右边，到了中间哪个地点会改变方向就可以了，相比之下就能节省不少时间了，尽快见到自己的爱人，这对应着排好序的情况。

最后的故事改编自两个人的现实生活，一位是自己最好的朋友之一，谈恋爱开心的睡不着觉；另一位是微信上的一位好友，为了对方从北京裸辞飞到了深圳。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/SpXxa8r-v">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/github-shi-da-zui-jia-shi-jian">
                        Github 十大最佳实践
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-28</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/git" class="post-tag i-tag
                            i-tag-info">
            #Git
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/i4kET55EC" class="post-tag i-tag
                            i-tag-other_1">
            #翻译
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/github-shi-da-zui-jia-shi-jian" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/github-shi-da-zui-jia-shi-jian.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            1、保护主分支不受直接提交的影响
主分支中的任何一次提交都应该是可以直接部署的，所以永远不要直接提交默认分支，同时也是 Gitflow workflow 成为标准的原因。使用分支保护可以帮你防止直接提交，当然，所有的事情都应该使用pull requests来管理。

2、避免基础信息的混乱
或许你在一个新的环境工作，或者你并没有注意到自己的 git 配置是不正确的，因此提交代码时伴随着错误的邮箱地址。如果提交没有关联到正确的用户信息，那将导致无法追溯到是谁写的代码。
保证你的 git 客户端配置是正确的邮箱地址，并且关联到你的 github 账户。评审代码时注意检查你的pull requests是否存在无法识别的提交。

3、为每个仓库定义 CODEOWNERS
使用 CODEOWNERS 功能可以定义哪些团队和人员被自动选为仓库的审阅者。此功能会自动请求仓库所有者进行审核。如今。组织拥有很多的仓库，而 CODEOWNERS 可以选择定义组织中的维护者。

4、从源代码中分离出秘密凭证
在构建云原生程序时，我们保护了许多的机密信息，比如账户密码、API 秘钥、私人令牌、SSH 秘钥等。绝对不要将任何机密信息提交到你的代码中，而应该采用从安全存储外部注入的环境变量。
你可以使用 Vault、AWS Secrets Manager 之类的工具来管理产品中的机密信息。
有很多超棒的工具可以识别代码中的机密信息，例如 Git-secrets 可以帮助你识别代码中的密码；使用 Git Hooks 可以构建一个预提交钩子，并检查每个pull requests中的机密信息。

5、不要提交项目的依赖
将项目的依赖提交到仓库中会增加仓库的大小。应该将你项目的所有依赖都从仓库中移除，让你的包管理器负责去下载它们。如果你担心“依赖可用性”，可以考虑使用 Jfrog 或 Nexus Repository 这样的二进制存储库管理器。
6、从源代码中分离配置文件
建议不要将本地配置文件提交到版本控制器，通常这些都是你不想推送到远程的私有配置文件，因为它们包含机密信息。个人的偏好，历史信息等应该保存在本地环境中。
7、为项目创建一个有意义的 .gitignore 文件
每个仓库都必须使用.gitignore文件来忽略预定义的文件和目录，它可以帮助你保护代码中的机密信息、依赖项和其他可能的差异。你可以从 Gitignore.io 选择相关的模板。

8、将死库归档
随着时间的推移，由于各种原因，我们发现自已拥有不再维护的仓库。或许你为一个临时用例新建了仓库，或者有一些包含旧的和不相关代码的仓库。它们存在的问题是相同的，这些仓库在达到其目的之后不在被积极的维护开发，因此你不希望再维护它们或不希望其他人依赖/使用它们，最好的方式是将这些仓库归档，这样对每个人都是“只读”的。

9、锁定依赖包的版本
你的依赖配置文件中包含所有软件包版本的信息，以便在每次安装应用程序时，在不破坏代码的前提下保持一致的结果。最好的方式是使用配置锁定文件来避免差异，并确定每次都获得相同的软件包版本。

10、对齐包的版本
虽然你使用的是相同的软件包，但是不同的版本会使得在不同项目中重用代码和测试变得困难。
如果你有一个在多个项目中使用的包，请至少尝试在不同的仓库中使用相同的主要版本。

原文链接：https://datree.io/blog/top-10-github-best-practices/

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/github-shi-da-zui-jia-shi-jian">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/JFfO3d0iF">
                        刘小绪同学的 2018
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-26</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/EE1uiCHgH" class="post-tag i-tag
                            i-tag-error">
            #个人总结
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/94PzxqinO" class="post-tag i-tag
                            i-tag-info">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/JFfO3d0iF" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/JFfO3d0iF.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这个总结写的还算认真，回头看，我真的运气很好，遇到了很多大佬，在我还未毕业时并没有嫌弃我傻，教我的不仅仅是技术，还有理财、为人处世，下面是我这一年的成长经历。
有一段时间因为华为 34 岁以上员工被裁、中兴程序员跳楼等事件的发生，各种蹭热点讨论“中年危机”的文章漫天飞，那时我正忙于找工作。
当时一个微信群里面大家各种讨论中年危机，都在给自己制造焦虑，刚好群里有个大神可能看大家过于焦虑，就在群里发了几条消息，教大家如何避免中年危机，并且推荐了两本书。
还是学生的我下意识的就发了一个添加好友请求，庆幸的是他同意了我的好友请求，当然我们没有什么交流，我的问题过于浅显，我明白自己这个水平问问题，会浪费人家时间，当时的想法是看看大神的朋友圈，他平时都接触什么，自己学习一段时间。
大神推荐的书是李笑来写的《把时间当做朋友》、《财富自由之路》，两本书在学校图书馆都没有，我就给学校图书馆荐购系统提交了这两本书，图书馆效率也挺高，不到一周就把书给买回来了，我立马就借回来阅读。
书中的内容刷新了我以前狭隘的认知，自己从来没有像书中那样考虑问题，除了对作者的佩服之外，更多的是思考自己这种学生思维局限性太大了，要慢慢的将它摒弃。
有个定律是你关心什么就会来什么，后面陆续碰到几位像大神一样的人士，并加了他们的微信，但是都仅仅是通过他们朋友圈的蛛丝马迹去找知识，通过他们朋友圈的分享内容，我知道了“简七理财”、“码农翻身”公众号，然后知道了《富爸爸穷爸爸》、《小狗钱钱》，于是我通过微信读书，读完了这两本书，逐渐培养了理财理念。
后来没隔多久，简七出书了，我第一时间就买了她写的《好好赚钱》（同期还有刘大也出了《码农翻身》一书，我也第一时间买了），简七写的内容通俗易懂，很容易理解。
刘大在群里开了几次公开课，作为计算机专业的我，被刘大对技术的理解之深给折服了，正是业界浮躁的时候，成千上万人想着人工智能、大数据、区块链，而刘大一直能沉下心来去了解技术的原理，这给了我一个很好的榜样，我也逐渐沉下心来，开始去补最基础的知识，像《深入理解计算机系统》一类书也能尽下心来慢慢去啃（当时没啃完，最近又在啃），这种不浮躁的特质对我的技术成长是很有帮助的。
此后有一天，另一个大神在朋友圈分享了曹大写的《从校园到职场系列文章》，喜欢深入挖掘信息的我，以曹大公众号为源头，又找到了冯大、池大、二爷等人的公众号。
作为自由的大四学生，因为不用担心第二天起不来，我那段时间经常熬夜阅读他们的文章，再阅读的过程中我也开始思考自己此前哪些想法狭隘，哪些品质又是值得继续保持的。
也是那时开始接受知识付费的，那时候已经有小密圈（现在叫知识星球）了，出于对几位大佬的信任，我第一次大胆的花了几百块钱加入了刘大、曹大、冯大、程序员小灰的小密圈，其中的内容比网上蹭热点的文章好不知多少倍，一贯爱捕捉蛛丝马迹的我，又通过评论信息发现了 angela zhu、子柳老师、陈利人老师等，然后去找他们的文章，他们输出的内容要比水军写的文章好太多。
自己也是从那时候开始坚持写文章记录自己的心得的，通过写文章，我认识了很多优秀的人，比如吴小龙同学、了不起的杰克、java 小咖秀等公众号的作者，和他们交流的很少，但是却很受用，他们的积极向上也影响着我一直保持着乐观豁达的心态。
自己写的文章也被几个资深程序员赞同，同时还收到了两个出版社发来的出书邀请，让我体会到了无心插柳柳成荫的收获。
让我坚持一直写文章的动力不是赚钱，而是我切切实实体会到了它给我个人带来的成长，为了自己日后再看时能立刻就找到清晰的逻辑，我把都尽可能把文章写得有理有据，掌握自己的节奏，尽量提高文章质量。此前写的谈一下写作的重要性一文有说写作可以带来的好处。
现在已经不把自己当新人了，而且有同龄人甚至比我年龄还大的人向我咨询问题时，我也能给出合理建议，都得到了他们的肯定。最近发现和周围伙伴最明显的一个区别就是，对于同一个新闻，我经常早于他们半天甚至一两天知道，而且掌握的信息比他们还准确，我认为这就是整体认知水平的提升。
想说的是，执行力与信息素养很重要，执行力强的人会与你拉开越来越大的距离，信息素养也是一个关键品质，现在网络上充斥着大量的虚假信息，如何去分别这些信息的真假，在相同条件下如何获得更多的有效信息，是必备的能力。
当前年龄 23，刚大学毕业几个月，没读研。按十年为期给自己定了几个小小的目标：
父母是地地道道的农民，智能手机都不会用，十年之类给自己和父母把重疾险、意外险之类的保险配置齐全，虽然父辈一直反对买保险。
提高获取信息的能力，虽然现在对信息的掌握都比周边伙伴要早半天至几天，但是都不是自己的分析结果，学习以时间的纬度跟踪事件的发展。
学习理财知识，现在只对信用卡、基金有一点点的了解，不管炒不炒股，金融知识都还是要学的，这方面通过看书、阅读、小额实操学习。
提升自己的技术实力，职业是程序员，前后端都做，但是自己对技术的热情不是多么高涨（至少比身边一半人要高涨），以我对自己的了解，我在技术的道路上成长为小公司一个的架构师应该不成问题，再高层级怕是不行。
慢慢做到不止一份收入来源，这方面不是多清晰，现在每个月平均会有 200 左右的非工资收入（帮助别人时发的红包等），十年后做到其它收入基本和工资持平。不至于因为钱的问题而忍受心中的不快，至少得有能指着老板的鼻子说“老子不干了”的底气。
世界那么大，应该去看看，国内除了西北地区，中国很多地方已经留下了我的足迹，旅游不仅仅是玩耍，更是提升见识、获得灵感的有效途径，十年至少得把自己的脚印印到 5 个国家的土地上吧。
十年之后应该已经结婚了，房子是现在最遥不可及的目标，但是心里莫名有一股自信，这个后面会实现的，虽然不知道哪里来的这股自信。
最后一个，趁年轻，多学习，做一个终身学习的人，时刻保持学习的态度，多做有利于他人的事，现在水平不高，我能帮助到的大部分都是硕士及以下。努力提高自己，帮助更多的人。更大的目标是能给山区学校带去一些更好的教育资源。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/JFfO3d0iF">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/cYbqHG1mh">
                        函数调用与空间分配
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-18</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-primary">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/cYbqHG1mh" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/cYbqHG1mh.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            我们在编程序的时候，都会把某一个特定功能封装在一个函数里面，对外暴露一个接口，而隐藏了函数行为的具体实现，一个大型的复杂系统里面包含了很多这样的小函数，我们称之为过程。
过程是相对独立的小模块，系统的运行需要这些过程的紧密合作，这种合作就是函数调用。
在一个函数执行时调用别的函数，比如 P 调用 Q，需要执行一些特定的动作。传递控制，在调用 Q 之前，控制权在 P 的手里，既然要调用 Q，那么就需要把控制权交给 Q；传递数据，就是函数传参；分配与释放内存，在开始时，Q 可能需要位局部变量分配空间，结束时又必须释放这些存储空间。
大多数语言都使用栈提供的先进后出机制来管理内存，x86-64 可以通过通用寄存器传递最多 6 个整数值（整数或地址），如果超过 6 个，那就需要在栈中分配内存，并且通过栈传递参数时，所有数据的大小都要向 8 的倍数对齐。将控制权从 P 转交给 Q，只需要将 PC（程序计数器）的值置为 Q 代码的起始位置，并记录好 P 执行的位置，方便 Q 执行完了，继续执行 P 剩余的代码。
在函数的传参、执行中，多多少少都需要空间来保存变量，局部数据能保存在寄存器中就会保存在寄存器中，如果寄存器不够，将会保存在内存中。除了寄存器不够用的情况，还有数组、结构体和地址等局部变量都必须保存在内存中。分配内存很简单，只需要减小栈指针的值就行了，同样释放也只需要增加栈指针。
在函数执行过程中，处理栈指针%rsp，其它寄存器都被分类为被调用者保存寄存器，即当过程 P 调用过程 Q 时，Q 必须保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。
所以递归也就不难理解了，初学算法总觉得递归有点奇妙，怎么自己调用自己，而实际上对于计算机来说，它和调用其它函数没什么区别，在计算机眼里，没有自身与其它函数的区别，所有被调用者都是其它人。
数组是编程中不可或缺的一种结构，“数组是分配在连续的内存中”这句话已经烂熟于心了，历史上，C 语言只支持大小在编译时就能确定的多维数组，这个多多少少有一些不便利，所以在ISO C99标准中就引入了新的功能，允许数组的维度是表达式。
int A[expr1][expr2]

因为数组是连续的内存，所以很容易就能访问到指定位置的元素，它通过首地址加上偏移量即可计算出对应元素的地址，这个偏移量一定意义上就是由索引给出。
比如现在有一个数组A，那么A[i]就等同于表达式* (A + i)，这是一个指针运算。C 语言的一大特性就是指针，既是优点也是难点，单操作符&amp;amp;和*可以产生指针和简介引用指针，也就是，对于一个表示某个对象的表达式expr，&amp;amp;expr给出该对象地址的一个指针，而对于一个表示地址的表达式Aexpr，*Aexpr给出该地址的值。
即使我们创建嵌套（多维）数组，上面的一般原则也是成立的，比如下面的例子。
int A[5][3];

// 上面声明等价于下面
typedef int row3_t[3];
row3_t A[5];

这个数组在内存的中就是下面那个样子的。

还有一个重要的概念叫做数据对齐，即很多计算机系统要求某种类型的对象的地址必须是某个值 K（一般是2、4 或 8）的倍数，这种限制简化了处理器和内存接口之间的设计，甚至有的系统没有进行数据对齐，程序就无法正常运行。
比如现在有一个如下的结构体。
struct S1 {
    int i;
    char c;
    int j;
}

如果编译器用最小的 9 字节分配，那么将是下面的这个样子。

但是上面这种结构无法满足 i 和 j 的 4 字节对齐要求，所以编译器会在 c 和 j 之间插入 3 个字节的间隙。

在极客时间专栏中有这样一段代码。
int main(int argc, char *argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i &amp;lt;= 3; i++){
        arr[i] = 0;
        printf(&amp;quot;Hello world!\n&amp;quot;);
    }
    return 0;
}

这段代码神奇的是在某种情况下会一直循环的输出Hello world，并不会结束，在计算机系统漫游（补充）中也提到过。
造成上面这种结果是因为函数体内的局部变量存在栈中，并且是连续压栈，而 Linux 中栈又是从高向低增长。数组arr中是 3 个元素，加上 i 是 4 个元素，刚好满足 8 字节对齐（编译器 64 位系统下默认会 8 字节对齐），变量i在数组arr之前，即i的地址与arr相邻且比它大。
代码中很明显访问数组时越界了，当i为 3 时，实际上正好访问到变量i的地址，而循环体中又有一句arr[i] = 0;，即又把i的值设置为了 0，由此就导致了死循环。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/cYbqHG1mh">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">
                        顺序、条件、循环语句的底层解释
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-11</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-error">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            顺序结构
数据传送指令
我们都清楚，绝大多数编译器都把汇编语言作为中间语言，把汇编语言程序变成可运行的二进制文件早就解决了，所以现在的高级语言基本上只需要把自己翻译成汇编语言就可以了。
汇编指令总共只有那么多，大多数指令都是对数据进行操作，比如常见的数据传送指令mov。不难理解，被操作数据无非有三种形式，立即数，即用来表示常数值；寄存器，此时的数据即存放在指定寄存器中的内容；内存引用，它会根据计算出来的地址访问某个内存位置。
需要注意的是，到了汇编层级，就不像高级语言那样随随便便int就能和long类型的数据相加减，他们在底层所占有的字节是不一样的，汇编指令是区分操作数据大小的，比如数据传送指令，就有下面这些品种（x86-64 对数据传送指令加了一条限制：两个操作数不能都指向内存位置）。

压栈与弹栈
对于栈，我想不必多讲，IT 行业的同学都清楚，它是一种线性数据结构，其中的数据遵循“先进后出”原则，寄存器%rsp保存着栈顶元素的地址，即栈顶指针。一个程序要运行起来，离不开栈这种数据结构。
栈使用最多的就是弹栈popq和压栈pushq操作。比如将一个四字值压入栈中，栈顶指针首先要减 8（栈向下增长），然后将值写到新的栈顶地址；而弹栈则需要先将栈顶数据读出，然后再将栈指针加 8。所以pushq和popq指令就可以表示为下面的形式。
// 压栈
subq $8, %rsp
movq %rbp, (%rsp)

// 弹栈
movq (%rsp), %rax
addq $8, %rsp

其他还有算术、逻辑、加载有效地址、移位等等指令，可以查阅相关文档了解，不作过多介绍，汇编看起来确实枯燥乏味。
条件结构
前面讲的都是顺序结构，我们的程序中不可能只有顺序结构，条件结构是必不可缺的元素，那么汇编又是如何实现条件结构的呢？
首先你需要知道，除了整数寄存器，CPU 还维护着一组条件码寄存器，我们主要是了解如何把高级语言的条件结构转换为汇编语言，不去关注这些条件码寄存器，只需要知道汇编可以通过检测这些寄存器来执行条件分支指令。
if-else 语句
下面是 C 语言中的if-else语句的通用形式。
if(test-expr){
    then-statement
}else{
    else-statement
}

汇编语言通常会将上面的 C 语言模板转换为下面的控制流形式，只要使用条件跳转和无条件跳转，这种形式的控制流就可以和汇编代码一一对应，我们以 C 语言形式给出。
    t = test-expr;
    if(!t){
        goto false;
    }
    then-statement;
    goto done;
false:
    else-statement;
done:

但是这种条件控制转移形式的代码在现代处理器上可能会很低效。原因是它无法事先确定要跳转到哪个分支，我们的处理器通过流水线来获得高性能，流水线的要求就是事先明确要执行的指令顺序，而这种形式的代码只有当条件分支求值完成后，才能决定走哪一个分支。即使处理器采用了非常精密的分支预测逻辑，但是还是有错误预测的情况，一旦预测错误，那将会浪费 15 ~ 30 个时钟周期，导致性能下降。

在流水线中，把一条指令分为多个阶段，每个阶段只执行所需操作的一小部分，比如取指令、确定指令类型、读数据、运算、写数据以及更新程序计数器。流水线通过重叠连续指令的步骤来获得高性能，比如在取一条指令的同时，执行它前面指令的算术运算。所以如果事先不知道指令执行顺序，那么事先所做的预备工作就白干了。

为了提高性能，可以改写成使用条件数据传送的代码，比如下面的例子。
v = test-expr ? then-expr : else-expr；

// 使用条件数据传送方法
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t){
    v = ve;
}

这样改写，就能提高程序的性能了，但是并不是所有的条件表达式都可以使用条件传送来编译，一般只有当两个表达式都很容易计算时，编译器才会采用条件数据传送的方式，大部分都还是使用条件控制转移方式编译。
switch 语句
switch语句可以根据一个整数索引值进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。为了让switch的实现更加高效，使用了一种叫做跳转表的数据结构（Radis 也是用的跳表）。跳转表是一个数组，表项 i 是一个代码段的地址，当开关情况数量比较多的时候，就会使用跳转表。
我们举个例子，还是采用 C 语言的形式表是控制流，要理解的是执行switch语句的关键步骤就是通过跳转表来访问代码的位置。
void switch_eg(long x, long n, long *dest){
    long val = x;
    switch(n){
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
        case 103:
            val += 11;
            break;
        case 104:
        case 105:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}

要注意的是，上面的代码中有的分支没有break，这种问题在笔试中会经常遇到，没有break会继续执行下面的语句，即变成了顺序执行。上面的代码会被翻译为下面这种控制流。
void switch_eg(long x, long n, long *dest){
        static void *jt[7] = {
            &amp;amp;&amp;amp;loc_A, &amp;amp;&amp;amp;loc_def, &amp;amp;&amp;amp;loc_B,
            &amp;amp;&amp;amp;loc_C, &amp;amp;&amp;amp;loc_D, &amp;amp;&amp;amp;loc_def,
            &amp;amp;&amp;amp;loc_D
        };
        unsigned long index = n - 100;
        long val;
        if(index &amp;gt; 6){
            goto loc_def;
        }
        goto *jt[index];
    loc_A:
        val = x * 13;
        goto done;
    loc_B:
        x = x + 10;
    loc_C:
        val = x + 11;
        goto done;
    loc_D:
        val = x * x;
        goto done;
    loc_def:
        val = 0;
    done:
        *dest = val;
}

循环结构
C 语言中有do-while、while和for三种循环结构，它们的通用形式一般都长下面那样。
// do-while
do
    body-statement
    while(test-expr);
    
// while
while(test-expr)
    body-statement
    
// for
for(init-expr; test-expr; update-expr)
    body-statement

do-while的特点是body-statement一定会执行一次，所以我们可以将do-while翻译成下面的控制流形式，很容易就能联想到它的汇编形式。
loop:
    body-statement;
    t = test-expr;
    if(t){
        goto loop;
    }

while循环我们给出两种形式的控制流，其中一种包含do-while形式，如下所示。
// 第一种形式
t = test-expr;
if(!t){
    goto done;
}
do
    body-statement;
    while(test-expr);
done:


// 第二种形式
    goto test;
loop:
    body-statement;
test:
    t = test-expr;
    if(t){
        goto loop;
    }

面试的时候，有的面试官会问你for循环的执行顺序，现在深入理解了三种循环的机制，再也不怕面试官啦。for循环可以转换成如下的while形式。
init-expr;
while(test-expr){
    body-statement;
    update-expr;
}

有了这种形式的for循环，我们只需要将其中的while部分再翻译一下就好了，前文给出了两种while翻译的方式，而具体采用哪种方式，取决于编译器优化的等级。
总结
计算机就是用那么几条简简单单的指令就完成了各种复杂的操作，不得不折服于计算机科学家们的魅力。现在人工智能被炒的很火热，然后人是事件、情感驱动的，而计算机是控制流驱动的，所以从架构上就决定了，冯诺依曼体系计算机实现的都是弱人工智能。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/shun-xu-tiao-jian-xun-huan-yu-ju-de-di-ceng-jie-shi">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/wei-xin-shi-yong-ji-qiao">
                        微信使用技巧
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-11-07</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/gong-ju-ji-qiao" class="post-tag i-tag
                            i-tag-other_1">
            #工具技巧
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/wei-xin-shi-yong-ji-qiao" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/wei-xin-shi-yong-ji-qiao.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            文中的技巧来源于对正记录分享内容的整理，我做了小部分的添加。
重要事件提醒
我们经常会在微信上答应别人一些事情，为此可能去找一些清单软件来提醒自己，问题是清单软件又不常打开，常常会导致事情的忘记，给别人留下一个言而无信的形象。其实微信自身就已经带了提醒功能，长按任何一条消息，上面有一个提醒按钮，点击设置提醒时间，到了提醒时间后，会在「服务通知」中有推送的提醒。
改善公众号阅读体验
微信公众号阅读文章的体验不佳，不支持分组，也不支持进行上一次阅读，这时可以选择公众号任意一篇文章，点击右上角之后找到「在微信读书中打开」，如果没有这个功能，可能需要升级微信或者下载微信读书 App。

建立一个人的微信群
怎么建立只有一个人的微信群呢？选择 -&amp;gt; 添加朋友 -&amp;gt; 面对面建群 -&amp;gt; 输入数字 -&amp;gt; 建群完成。这个只有自己的群就相当于一个信息分组，可以把自己平时的想法、待阅读的文章、写作灵感等发到里面，就自己一个人看，而且还可以对微信群进行置顶操作，不会受到其他微信群信息的影响，处理完的信息也可以像删聊天记录一样删掉，当然也可以选择发给文件助手或者自己。
使用微信编辑图片
我们有时候为了别人能更方便的理解自己想表达的意思，或者图片上的某些位置不想被别人看到，可以在添加图片的时候选择「预览」，就可以对图片进行编辑了。最实用的就是斗图的时候，对方一张图过来，如果手里没有合适的图片，可以直接基于对方的图片进行编辑，怼回去。
利用微信收藏快速拼图
选择「收藏」，在里面添加图片，然后选择右上角三个...的按钮，之后选择保存为图片，这样你添加的图片就拼接为了一张长图了，非常方便的操作，有的朋友喜欢分享聊天记录，就可以这么拼接。

善用「搜一搜」
微信的「搜一搜功能很强大，比如有一天你无意在朋友圈看到一条信息，当时没有发现它的价值，过了一段时间因为其他事，突然恍惚记起了以前某条朋友圈提到过相关的情况，想查一查。这时就可以通过「搜一搜」来快速查找了。除此之外，「搜一搜」还能搜索文章，方便你快速查看与某个主题相关的文章；以及表情包搜索等功能，在斗图的时候不会再为没有表情包而烦恼。

僵尸粉检测
相信很多人都遇到过别人给你发一条消息，上面注明是为了清僵尸粉的，但是这样会打扰到绝大部分微信好友，也给别人留下很不好的印象，我很反感收到别人的清粉消息。如果你怀疑某个人删除了你，你试着转账测试一下就可以了；如果需要大批量的检测，可以使用 WeTool ：https://www.wxb.com/wetool，需要在Windows电脑上进行操作。

推荐几个小程序
微信发票助手，经常出差的朋友或者行政小姐姐，常遇到的问题是在开公司发票的时候，需要填写一些信息，一般有记不住的，可以使用这个小程序填写好，之后每次需要的时候打开就好了，或者别人需要的时候，你分享二维码给他就可以了。发票信息填完后，会在「个人信息」底部多一个「我的发票抬头」，很方便的哦。

微信指数，有时候可能会做一些调查，比如写文章的朋友，文章标题到底是用“旅游”还是“旅行”好呢？这个时候就可以用微信指数来做调查，可以查看不同词汇之间的热度。

文章截图，IOS 用户比较苦恼的应该就是截长图了吧，有人就专门做了一个小程序，只需要把文章的链接复制过去，就可以自动生成截图，还可以生成 PDF 文件哦。

蚂蚁清单，很多人都有使用待办事项管理软件，但是有时候又忘记打开，这时不妨把它放到日常打开频率最高的微信里面去，而且还能为手机节省一点空间，蚂蚁清单的体验很好，可以自己去尝试。

一条人生经验
敏感和违法不和谐的话题不要聊。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/wei-xin-shi-yong-ji-qiao">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li">
                        信息的表示和处理
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-10-19</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-warning">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/xin-xi-de-biao-shi-he-chu-li.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            字数据大小
前面已经提到过信息=位+上下文，但是基本上的计算机都没有将位作为最小的可寻址单位，而是将字节作为了最小的可寻址单位，内存就是一个非常大的字节数组，它的的每个字节都由一个唯一的数字来标识（这个数字是不需要存的），所有可能的地址集合就是虚拟地址空间。
我们常说的 32 位、64 位指的是一台计算机的字长，用于指明指针数据的的标称大小。有的面试官在面试的时候会问这样一个问题：在 C/C++ 中指针的大小是多少？如果你一下就回答出来时多少个字节了，那基本上不必再问了，因为一个指针的大小取决于计算机的字长，所以应该分 32 位机还是 64 位机的情况。
字长还会决定一个极为重要的系统参数——虚拟地址空间。比如现在有一个 32 位机，每一位可以取值 1 或 总共 32 位，能组合的出局就有 232 个，所以它能访问 232 个地址，其大小也就是 4G，因此你如果给 32 位机装上 8G 的内存条，是起不了多大作用的。
我们平时所说的 32 位程序和 64 位程序并不是指机器的字长，它们的区别在于程序时如何编译的，而不是其运行的机器类型，高版本都应该做到向后兼容，所以 32 位程序一般都能运行在 64 位机器上，而 64 位程序时不能运行在 32 位机上面的。下面两种伪指令就分别用于编译 32 位程序和 64 位程序。
gcc -m32 prog.c
gcc -m64 prog.c

C 语言在 32 位机和 64 位机上所表现的差别在于long数据类型，一般在 32 位机上是 4 个字节，而在 64 位机上是 8 个字节，而作为程序员要力图程序能在不同的机器上进行编译执行，要做到这一点就需要保证程序对不同数据类型的确切大小不敏感。

曾经某运营商的一个基站版本因为数据范围的不同而造成了巨大的损失，在编程环境中使用的是 32 位机，而基站所使用的处理器没有 32 位，最后表现的效果就是大概每隔 40 天，基站就自动复位了。定位到这个问题都花费了巨大的财力和人力资源。

寻址及字节顺序
上文已经提到，有很多的对象实际上不止占用一个字节，而是占用了多个字节，此时就涉及到如何排列这些字节了，以及如何存储这些字节。以11001100 11001100为例，它占用了两个字节，我们可以选择将这两个字节放在连续的内存中，也可以将两个字节分开放在不连续的内存中；另外我们可以将左边的字节当做起始位置，也可以将右边的字节当做起始位置（更专业的称为大端法和小端法）。
对于字节的排列，到底是用大端法还是小端法，没有技术上的争论，只有社会政治论题的争论，而且机器它对程序员是完全不可见的。几乎所有的机器都将多字节对象存储为连续的字节序列，所使用字节中最小的地址作为对象的地址。
那么什么时候需要注意字节的顺序规则呢，那就是编写网络应用程序的时候，试想你传输的数据是用大端法表示的，而用户的计算机采用的是小端法，那还会有用户使用你的产品吗。所以编写网络程序时需要遵循已经建立的关于字节顺序的规则。
整数表示
程序员对二进制不会不知道，比如 11111111表示的是 255（不考虑补码），很容易就能转换为我们所熟悉的 10 进制数据。这种方式我们默认它是无符号数，如果要加入有符号数就开始变得有趣了。
几乎所有的计算机都是采用有补码来表示有符号整数的，它与无符号整数的区别在于最高位被解释为负权，举个例子：将1111看做补码的话，它的值就为：-23 + 22 + 21 + 20 = -1。
在程序中不可避免的会使用强制类型转换，C 语言中强制类型转换并没有改变数据的位值，只是改变了解释这些位的方式。比如将无符号数（unsigned） 53191 转换为有符号数的结果为 -12345，它们的位值是完全没有相同的。
最容易入坑的地方是，对两个不同类型的数据进行运算时，C 语言将会隐式的将有符号数转换为无符号数，所以就有下面这样一个神奇的结果。
// u 代表无符号数
-1 &amp;lt; 0u
// 结果为 0
// 因为 -1 的补码表示为：11...11
// 转换为无符号数后就是范围内最大的数

如果需要扩展一个数的位表示，那么放心的扩展就好了，小的数据类型都能安全的向大的数据类型转换，补码表示的数会在前面补上符号位，原码表示的直接在前面补上 0 即可，而需要注意的是从大往小转，这会不可避免的截断位，造成信息的丢失，所以千万不要这么干。
加法、乘法运算
在编程入门的时候可能都知道两个正数相加的结果可能为负数，还有一个更奇怪的现象就是：x &amp;lt; y和 x - y &amp;lt; 0两个表达式可能会得出不一样的结果，这些神奇的结果都和计算机整数的底层表示和运算有着密切的关系。
C 语言中有无符号数与有符号数之分，而在 Java 中只有有符号数，下面的内容还是基于 C 语言进行说明，毕竟更 C 比 Java 更接近底层嘛。
无符号加法
假设我们使用 w 位来表示无符号数，那么两个加数取值范围即为：0 ≤ x, y ＜2w，理论上它们的和的范围为：0 ≤ sum ＜ 2w+1，因为只有 w 位表示无符号数（要把和表示出来就需要 w+1 位），所以超过 zw的部分就会造成溢出，如下图所示。

对于无符号数的溢出，计算机采用的处理方式是丢掉最高位，直观的结果就是，当发生溢出了，就将采用取模运算（或者说是减去 2w），举个例子。
只用 4 为来表示无符号数，即 w = 4，现在有 x [1001] 和 y [1100] 相加，其结果应为：[10101] ，但是没有 5 位用来表示，所以丢掉最高位的1，剩下的值为 5 [0101]，也就是 21 mod 16 = 5。
那么如何检测是否发生溢出呢？设求和结果为 s，对于加法有 x + y ≥ x 恒成立，即只要没有发生溢出，肯定有 s ≥ x。另一方面，如果确实发生溢出了，就有 s = x + y - 2w，又有 y - 2w ＜ 0，因此 s = x + y - 2w ＜ x。
补码加法
和前面一样，对于两个给定范围的加数 - 2w-1 ≤ x, y ≤ 2w-1 - 1，它们的和的范围就在 - 2w ≤ sum ≤ 2w - 2。要想把整个和的范围表示出来，依旧需要 w+1 位才行，而现在只有 w 位，因此还是需要采用将溢出部分截断。

可以发现，当发生正溢出时，截断的结果是从和数中减去了 2w；而当发生负溢出时，截断结果是把和数加上 2w。
那么对于补码加法如何检测溢出结果呢？通过分析可以发现，当且仅当 x ＞ 0, y ＞ 0，但和 s ≤ 0 时为正溢出；当且仅当 x ＜ 0, y ＜ 0，但 s ≥ 0 时发生负溢出。
无符号乘法
有了前面的基础，乘法就变得简单一些了，对于溢出情况，计算机仍然采用的是求模，比如 0 ≤ x, y ≤ 2w - 1，它们乘积的范围为 0 到 22w - 2w+1 + 1 之间，这可能需要 2w 位来表示，溢出部分直接截掉，如下所示。

补码乘法
对于补码，两个乘数的范围为：- 2w-1 ≤ x, y ≤ 2w-1 + 1，那么其乘积表示范围就为 - 22w-2 + 2w-1 到 22w-2 之间，补码乘法和无符号乘法基本是一样的，只是在无符号基础上多加了一步转换，即将无符号数转换为补码。

乘以常数
我们知道，计算机做加减法、位级运算的速度最快（1 个指令周期），而做乘除法很慢（10 个甚至更多指令周期），平时编写的程序中常常会乘以一个常数，为了使程序运行的更快，编译器可能会帮我们做一些处理。
首先我们考虑常数是 2 的幂。x * 21 可以表示为 x &amp;lt;&amp;lt; 1，x * 22 可以表示为 x &amp;lt;&amp;lt; 2，依次类推即可。
对于不是 2 的幂的常数，比如 x * 14 可以表示为：(x&amp;lt;&amp;lt;3) + (x&amp;lt;&amp;lt;2) + (x&amp;lt;&amp;lt;1)，因为 14 = 23 + 22 + 21；聪明的你可能发现 14 还有另一种表示方法，即 14 = 24 - 21，这种表示比前一种表示方法又少了运算量，所以 x * 14 还可以表示为：(x&amp;lt;&amp;lt;4) - (x&amp;lt;&amp;lt;1)。
实际上，这里有一个通用的解决方案，对于任何一个常数 K，其二进制可以表示为一组 0 和 1 交替的序列：[(0...0)(1...1)(0...0)(1...1)]，14可以表示为：[(0...0)(111)(0)]，考虑一组从位位置 n 到位位置 m 的连续的 1 （n ≥ m），（对于 14 有 n = 3，m = 1）可以有两种形式来计算位对乘积的影响。

这个优化不是一定的，大多数编译器只在需要少量移位、加减法就足够的时候才使用这种优化。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/xin-xi-de-biao-shi-he-chu-li">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you">
                        计算机系统漫游
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-10-10</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-success">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/ji-suan-ji-xi-tong-man-you.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            计算机中的信息
对于程序员来说，HelloWorld 程序再熟悉不过了，下面是 C 语言写的 HelloWorld 程序。
#include&amp;lt;stdio.h&amp;gt;

int main()
{
	printf(&amp;quot;hello, world\n&amp;quot;);
	return 0;
}

这段程序很简单，仅仅是在屏幕上输出hello world，对于程序员很容易阅读，但是从计算机的角度来看，也是这么简单吗？
我们都知道，计算机的世界只有 0 和 1组成的位（比特），这对于人类来说太不友好了，因此计算机科学家们设计了 ASCⅡ 码来表示现实世界的符号。每 8 个位构成一个组（称为一个字节），用一个组来表示一个符号，上面的 C 程序用 ASCⅡ 表示就是下面的样式。

因此对于计算机来说，所有的数据都是由一串比特表示的，要区分这些数据对象的唯一方法就是读到它们时的上下文。
信息 = 位 + 上下文

那么什么是上下文呢？举个例子来讲。在磁盘中有一段二进制数据1010010111010010，如果有一段程序将其当做整数读出来（不考虑补码），那么它的值就是 42450，如果把它当做浮点数读出来将是另一个结果，而JVM 将其当做字节码读出来的话，那又是完全不同的结果。只有把位放在具体的程序、环境中（即上下文）才会有意义，单个位是没有意义的。
源程序编译
虽然我们把 C 语言程序编写完成了，但是它并不能运行，因为它目前还仅仅是由 ASCⅡ 字符构成的文本文件，计算机并不能运行文本文件。
想要得到 HelloWorld 的可执行文件，需要经过预处理、编译、汇编、链接四个阶段。
预处理阶段，预处理器会根据以字符#开头的命令去修改源程序，预处理器去读取系统头文件stdio.h中的内容，并将其直接插入程序文本中，结果就得到了另一个 C 程序—— hello.i。
编译阶段，编译器会把 hello.i 程序翻译成汇编语言程序 hello.s，汇编语言本质上就是机器语言，此时的程序仍然是文本文件。
汇编阶段，汇编器会将 hello.s 翻译成机器语言指令，保存在 hello.o 文件中，此时得到的就是二进制文件了。
程序中使用了 printf 函数，这是由编译器提供的标准 C 库中的函数，它存储在 printf.o 文件中，链接器会将这个文件合并到 hello.o 中，结果就得到一个可执行的 hello 文件，存储于磁盘中。

系统组成及程序运行
在运行可执行文件 hello 文件之前，应该先了解一下系统的硬件组成，一个典型系统的硬件组织如下图所示。

为了运行 hello 程序，我们需要在 shell 中输入指令./hello，指令通过键盘经 I/O 总线 --&amp;gt; I/O 桥 --&amp;gt; 总线接口 --&amp;gt; 寄存器 --&amp;gt; I/O 桥存于主存中，当敲击回车键时，等于告诉 shell 程序，命令的属于已经结束， shell 将会执行一系列指令来加载 hello 文件。
利用**直接存取（DMA）**技术，hello 文件不需要通过寄存器就能到达主存，当目标文件 hello 到达主存中，处理器就开始执行 hello 程序的机器指令。其指令即将 &amp;quot;hello, world\n&amp;quot; 字符串的字节从主存复制到寄存器，再从寄存器复制到显示设备中，最终显示在屏幕上面。
我们发现这个简单的 HelloWorld 程序会让系统花费大量的时间把信息从一个地方挪到另一个地方，而我们都清楚，寄存器、主存、磁盘之间的访问速度是相互差了好几个数量级的，而这种复制的开销会严重减慢程序的运行，为了加快这些复制操作的速度，系统设计者就引入了高速缓存。
抽象的重要性
计算机科学中最为重要的概念之一就是抽象，指令集提供了对硬件处理器的抽象，操作系统同样通过进程、虚拟内存、文件（磁盘、键盘、网络都可以看成文件）这几个抽象概念为应用程序提供简单一致的机制来控制低级硬件设备，同时防止硬件被失控的应用程序滥用。

进程是对正在运行的程序的抽象，在一个系统上可以同时运行多个进程，但是每个进程看起来都好像在独占的使用硬件，CPU 看上去是在并发的执行多个进程，这就需要操作系统进行上下文切换。
在我们还没有输入./hello之前，只有 shell 进程在运行，当我们让其运行 hello 程序时，shell 会通过系统调用来执行我们的请求。操作系统首先保存 shell 进程的上下文（PC、寄存器等信息），然后创建一个新的 hello 进程，并将控制权转交给 hello 进程。

并发和并行
并发是一个通用的概念，指同时具有多个活动的系统；并行是指用并发来使一个系统运行的更快，人类都是很懒的，不仅想要计算机能做的更多，还想它效率更高，这样的想法一致促进着技术的前进。
编程的人都知道，为了使程序运行的更快，我们可以编写多线程程序（虽然多线程程序有些难调），在一个进程里面执行多个控制流，线程级的并发可以让计算机运行的更快。
再向底层看看，在计算机体系结构的课堂上都会做流水线实验，通过将一条指令划分成不同的步骤，一条指令的执行时间能够从原来的 3~10 个时钟周期，缩短为接近于 1 个时钟周期，这是指令级的并行。条件判断和循环结构又会增加指令执行的时钟周期，如果能对这部分知识作深入了解，你编写的程序应该会高一个档次。
除了上面两种并行，还可以使用特殊的硬件，这种硬件可以允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/ji-suan-ji-xi-tong-man-you">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io//post/MYYZrm7wn">
                        如何解决跨域请求问题
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-09-18</time>
                    
                        <a href="https://mengxiaoxu.github.io//tag/S57Vp3Suu" class="post-tag i-tag
                            i-tag-info">
            #计算机网络
        </a>
                        
                        <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-other_1">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io//post/MYYZrm7wn" class="post-feature-image" style="background-image:url(https://mengxiaoxu.github.io//post-images/MYYZrm7wn.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
刚毕业入职，大部分时间还在培训，中间有一段时间的空闲时间，就学习了下 Angular，在学校都是编写的单体应用，所有代码都放在同一个工程下面，到公司使用的是前后端分离了，虽然后端程序也是我自己写的，但是有一些数据是从公司现有接口去拿的，然后就遇到让我纠结了两小时的跨域请求问题，为了避免出现上图中的尴尬场面，在这里做一个简单的总结输出。
什么是跨域请求
跨域请求问题是浏览器的同源策略造成的，该策略不允许执行其它网站的脚本，是浏览器施加的安全限制。什么是同源？最初是指网页  A 设置的 Cookie 不能被网页 B 打开，包括三个相同：协议、域名、端口。这个同源是从 URL 判断的，不是从 IP 判断的，如果同一个服务器对应连个域名，这两个域名是不同源的。
http://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 非跨域

http://www.nealyang.cn/index.html 调用 http://www.neal.cn/server.php 跨域,主域不同

http://abc.nealyang.cn/index.html 调用 http://def.neal.cn/server.php 跨域,子域名不同

http://www.nealyang.cn:8080/index.html 调用 http://www.nealyang.cn/server.php 跨域,端口不同

https://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 跨域,协议不同

localhost 调用 127.0.0.1 跨域

同源政策的目的是为了保护用户信息的安全，防止恶意网站窃取数据，随着互联网的发展，同源政策更加严格了，下面三种行为都会受到限制。
（1） Cookie、LocalStorage 和 IndexDB 无法读取。
（2） DOM 无法获得。
（3） AJAX 请求不能发送。

所有的现代浏览器都对网络连接进行了安全限制，包括 XMLHttpRequest，如果你的 web 应用程序和其使用的数据在同一个服务器，你不会遇到跨域请求问题。但是当你的 web 应用程序和 web 服务数据不在同一个服务器时，就会被浏览器限制连接了。
常用解决方案
对于跨域请求有很多的解决方案，最常用的解决方案是在你的 web 服务器上面设置代理。在设置代理之前就通过，应用程序直接去请求另一个服务器下的数据；设置代理之后，应用程序从自己的 web 服务器中请求数据，再由代理去请求数据，这样 web 服务器拿到数据之后返回给应用程序即可。从浏览器角度看，就是从同一个服务器拿的数据，并没有进行跨域请求。

通俗易懂的说，你家的宠物狗不会吃别家的食物，因为它担心别人的食物会把自己给药死，所以你的狗狗只管找你要食物，你是它的主人，它绝对相信你，而你可以鉴别别人给的食物是不是安全的。类比，小狗就是浏览器，你就是代理。
Angular 中的解决办法
上面所说的解决方案在开发过程中不方便操作，每新发一个接口都到服务器中去配置一下，不仅麻烦而且效率低下。首先说一下在 Angular 中一个人比较常用的解决方法，默认你在使用angular-cli构建你的项目，我们可以创建一个代理配置文件proxy.conf.json（假设你的后端服务的访问地址为10.121.163.10:8080），代理配置文件如下：
{
  &amp;quot;/api&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;http://10.121.163.10:8080&amp;quot;,
    &amp;quot;secure&amp;quot;: false
  }
}

然后修改package.json文件中的启动命令为&amp;quot;start&amp;quot;: &amp;quot;ng serve --proxy-config proxy.conf.json&amp;quot;，启动项目时使用npm start即可解决跨域请求问题。
上述解决方案仅在开发时使用，你当然可以使用 tomcat、nginx 配置代理，但是这很麻烦，需要打包代码部署，为了保证效率，我们想写完了立刻测试，同时也不想麻烦做后端的同学，在项目发布时，应该把代理配置到服务器中去；修改启动命令也不是必须的，你也可以选择每次使用 ng serve --proxy-config proxy.conf.json命令启动项目；示例代理配置文件内容可以有更多的属性，可以通过网络查阅相关资料。
后端解决办法
我的后端是是用 tornado 实现的，然后我又写了一个单独的页面用于在大屏幕上展示相关数据，没有用 Angular 了，要通过 AJAX请求数据，又怎么解决跨域请求问题呢？这时就需要设置请求头了，让后端允许跨域请求。
这时需要了解一下简单请求和非简单请求了，简单请求就是只发送一次请求的请求；非简单请求会发送数据之前先发一次请求做预检，通过预检后才能再发送一次请求用于数据传输。
更清晰区别，满足下列两大条件的属于简单请求，而非简单请求就是请求方法为PUT或DELETE，或者 Content-Type字段是application/json的请求。

1.请求方法为 GET、POST、HEAD之一
2.HTTP头信息不超出字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type，并且 Content-Type 的值仅限于 application/x-www-form-urlencoded、multipart/form-data、text/plain。

对于简单请求，只需要设置一下响应头就可以了。
class TestHandler(tornado.web.RequestHandler):
    def get(self):
        self.set_header(&#39;Access-Control-Allow-Origin&#39;, &amp;quot;*&amp;quot;)
        # 可以把 * 写成具体的域名
        self.write(&#39;cors get success&#39;)

对于复杂请求，需要设置预检方法，如下所示：
class CORSHandler(tornado.web.RequestHandler):
    # 复杂请求方法put
    def put(self):
        self.set_header(&#39;Access-Control-Allow-Origin&#39;, &amp;quot;*&amp;quot;)
        self.write(&#39;put success&#39;)
    # 预检方法设置
    def options(self, *args, **kwargs):
        #设置预检方法接收源
        self.set_header(&#39;Access-Control-Allow-Origin&#39;, &amp;quot;*&amp;quot;)
        #设置预复杂方法自定义请求头h1和h2
        self.set_header(&#39;Access-Control-Allow-Headers&#39;, &amp;quot;h1,h2&amp;quot;)
        #设置允许哪些复杂请求方法
        self.set_header(&#39;Access-Control-Allow-Methods&#39;, &amp;quot;PUT,DELETE&amp;quot;)
        #设置预检缓存时间秒,缓存时间内发送请求无需再预检
        self.set_header(&#39;Access-Control-Max-Age&#39;, 10)

本人不太懂前端知识，更多的前端跨域解决方案可以参考下面列出的文章，除第一篇外，其他都介绍了前端跨域解决方法。
参考资料及推荐文章
标题：JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls
链接：https://developer.yahoo.com/javascript/howto-proxy.html?guccounter=1

标题：别慌，不就是跨域么!
链接：https://mp.weixin.qq.com/s/A0Oi-fUrmboRPPeNEjG3aw

标题：跨域资源共享 CORS 详解
链接：http://www.ruanyifeng.com/blog/2016/04/cors.html

标题：AJAX请求和跨域请求详解（原生JS、Jquery）
链接：http://www.cnblogs.com/tkqasn/p/5869175.html

标题：JavaScript跨域总结与解决办法
链接：http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io//post/MYYZrm7wn">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
            <a href="https://mengxiaoxu.github.io//" class="page-btn btn">上一页</a>
            
                
                    <a href="https://mengxiaoxu.github.io//page/3/" class="page-btn btn">下一页</a>
                    
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1569597530875)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <a href="https://www.douban.com/people/189583084/" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-facebook"></i></a>
                                        

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>