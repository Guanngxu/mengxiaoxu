<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1578671811564">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1578671811564" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/rang-https-jian-dan-yi-dong">
                        让 HTTPS 简单易懂
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-08-26</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/i4kET55EC" class="post-tag i-tag
                            i-tag-other_2">
            #翻译
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/S57Vp3Suu" class="post-tag i-tag
                            i-tag-other_1">
            #计算机网络
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/rang-https-jian-dan-yi-dong">
                            <img class="post-feature-image" src="/post-images/rang-https-jian-dan-yi-dong.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            充满各种数学证明的密码学是令人头疼的，一听到密码、黑客、攻击等词的时候，就给人一种神秘又高大上的感觉，但除非你真的从事密码学相关工作，否则你并不需要对密码学有多么深刻的理解。
这是一篇适合在饭后的品茶时光中阅读的文章，咱们虚构一个故事来讲解，虽然故事看起来很随性，但是 HTTPS 也是这么工作的。里面有一些术语你也应该听过，因为它们经常出现在技术文献里面。
故事背景
一天，一个男子到河边抓鱼给母亲吃，而河岸的另一头是一大户人家的小姐和她的丫鬟在散步。突然，一个不小心，对面小姐不慎跌入水中，而丫鬟又不会游泳，这可把小丫鬟急的呀！！！正在抓鱼的男子见此状况，来不及脱掉身上的衣物，就像箭一样窜入水中.....想必看客已经猜到了，小姐被救起，男子抱着迷迷糊糊小姐走上岸的过程中，小姐感觉自己像触电了一样，觉得这个男人很安全，只要靠着他，就算天塌下来也不怕，而男子把小姐放下的那一刻，也很不舍，好像把她放下就失去了活下去的希望。
小姐回到家中，给父亲大人说了这件事，父亲很高兴，就叫下人去把这位男子请到家中表示感谢，结果一问，这小伙幼年丧父，现在家中还有病弱的老母亲，连一间屋子都没有，一直和母亲寄住在城外的破庙里面，不过他毕竟救了自己的女儿，父亲让下人拿出了五十两黄金以表谢意，但不允许他和小姐再有任何来往。
.....此处省略五千字。
我们姑且称小姐为小花，称男子为小明，他们不能相见了，但是又备受相思之苦，因此只能通过写信的方式来传达彼此的思念了。
最简单的通信方式
如果小花想给小明写信，那么她可以把写好的信让信鸽给小明送去，小明也可以通过信鸽给小花回信，这样他们就能知道彼此的感情了。
但是很快这种方式出问题了，因为他们都隐约感觉到收到的来信不是对方写的，因为从信件上看，双方都表示不再喜欢彼此。凭借着对彼此的信任，他们才知道是小花的父亲从中阻挠他们。每次他们写的信都被父亲的下人拦下了，然后换上他们事先准备好的信件，目的就是为了让小花和小明断了感情。
HTTP 就是这样的工作方式。
对称加密
小花是博冠古今的人，这怎么能难倒她呢。他们彼此约定，每次写信都加上密码，让信鸽传送的信件是用密文书写的。他们约定的密码是把每个字母的位置向后移动三位，比如 A → D 、 B → E ，如果他们要给对方写一句 &amp;quot;I love you&amp;quot; ，那么实际上信件上面写的就是 &amp;quot;L oryh brx&amp;quot; 。现在就算父亲把信件拦截了，他也不知道里面的内容是什么，而且也没办法修改为有效的内容，因为他不知道密码，现在小花和小明又能给对方写情书了。
这就是对称加密，因为如果你知道如何加密信息，那也能知道如何解密信息。上面所说的加密常称为凯撒密码，在现实生活中，我们使用的密码肯定会更复杂，但是主要思想是一样的。
如何确定密钥
显然对称加密是比较安全的（只有两个人知道密码的情况下）。在凯撒密码中，密码通常是偏移指定位数的字母，我们使用的是偏移三位。
可能你已经发现问题了，在小花和小明开始写信之前，他们就已经没办法相见了，那他们怎么确定密钥呢，如果一开始通过信鸽告诉对方密钥，那父亲就能把信鸽拦下，也能知道他们的密钥，那么父亲也就可以查看他们信件的内容，同时也能修改信件了。
这就是典型的中间人攻击，唯一能解决这个问题的办法就是改变现有的加密方式。
非对称加密
小花想出了更好的办法，当小花想给小明写情书的时候，她将会按照下面的步骤来进行：

小花给小明送一只没有携带任何信件的鸽子；
小明让信鸽带一个没有上锁的空箱子回去，钥匙由小明保管；
小花把写好的情书放到箱子里面，并锁上箱子
小明收到箱子后，用钥匙打开箱子就可以了。

使用这种方式，父亲大人就没办法拦截信鸽了，因为他没有箱子的钥匙。同样如果小明想给小花写情书，也采用这种方式。
这就是非对称加密，之所以称之为非对称加密，是因为即使你能加密信息（锁箱子），但是你却无法解密信息（开箱子），因为箱子的钥匙在对方那里。在技术领域，把这里的箱子称作公钥，把钥匙称作私钥。
认证机构
细心的你可能发现问题了，当小明收到箱子后，他如何确定这个箱子的主人是谁呢，因为父亲也可以让信鸽带箱子给小明啊，所以父亲如果想知道他们的信件内容，那只需要把箱子偷换掉就好了。
小花决定在箱子上面签上自己的名字，因为笔迹是不能模仿的，这样父亲就没办法伪造箱子了。但是依旧有问题，小花和小明在不能相见之前并没有见过彼此写的字，那么小明又如何识别出小花的字迹呢？所以他们的解决办法是，找张三丰替小花签名。
众所周知，张三丰是当世的得道高人，他的品德是世人都认可的，大家都把他奉为圣人，而且天下肯定不止一对有情人遇到小花和小红这样的问题。张三丰只会为合法居民签名。
张三丰会在小花的盒子上签名，前提是他确定了要签名的是小花。所以父亲大人是无法得到张三丰代表小花签名的盒子，否则小明就会知道这是一个骗局，因为张三丰只在验证了人们的身份后才会代表他们给盒子签名。
张三丰在技术领域的角色就是认证机构，你现在阅读这篇文章所使用的浏览器是附带了各种认证机构的签名的。所以当你第一次访问某个网站时，你相信这不是一个钓鱼网站，是因为你相信第三方认证机构，因为他们告诉你这个箱子是合法的。
箱子太重了
虽然现在小花和小明有了一个可靠的通信系统，但是信鸽带个箱子飞的慢啊，热恋中的人是“一日不见如隔三秋”，信鸽飞慢了怎么行呢。
所以他们决定还是采用对称加密的方式来写情书，但是对称加密的密钥要用箱子来传递，也就是用非对称加密方式来传递对称加密密钥，这样就可以同时获得对称加密和非对称加密的优点了，还能避免彼此的缺点。
需要注意的是，在网络世界中，信息不会像鸽子传送的那么慢，只不过只用非对称加密技术加密信息要比对称加密慢，所以只用它来交换密钥。
以上就是 HTTPS 的工作过程。
一个故事

这个故事你可能早就知道了，我只是在写文章的过程中突然想起了它，就是笛卡尔的爱情故事。


具体细节你可以网上去查，笛卡尔每天给自己喜欢的公主写信，但是信都被国王拦截了，笛卡尔给公主写的第十三封信中只有一个数学方程，但是这个方程国王看不懂，所以就把这封信交给了公主，公主一看方程，立刻着手把方程的图形画了出来，发现这是一颗心的形状。


参考内容：https://medium.freecodecamp.org/https-explained-with-carrier-pigeons-7029d2193351

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/rang-https-jian-dan-yi-dong">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/yong-scrapy-pa-qu-dou-ban-250">
                        用 Scrapy 爬取豆瓣250
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-07-27</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/pa-chong" class="post-tag i-tag
                            i-tag-">
            #爬虫
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/yong-scrapy-pa-qu-dou-ban-250">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/yong-scrapy-pa-qu-dou-ban-250.jpeg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            最好的学习方式就是输入之后再输出，分享一个自己学习scrapy框架的小案例，方便快速的掌握使用scrapy的基本方法。
本想从零开始写一个用Scrapy爬取教程，但是官方已经有了样例，一想已经有了，还是不写了，尽量分享在网上不太容易找到的东西。自己近期在封闭培训，更文像蜗牛一样，抱歉。
Scrapy简介
Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。
其最初是为了 页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。

如果此前对scrapy没有了解，请先查看下面的官方教程链接。
架构概览：https://docs.pythontab.com/scrapy/scrapy0.24/topics/architecture.html
Scrapy入门教程：https://docs.pythontab.com/scrapy/scrapy0.24/intro/tutorial.html
爬虫教程
首先，我们看一下豆瓣TOP250页面，发现可以从中提取电影名称、排名、评分、评论人数、导演、年份、地区、类型、电影描述。

Item对象是种简单的容器，保存了爬取到得数据。其提供了类似于词典的API以及用于声明可用字段的简单语法。所以可以声明Item为如下形式。
class DoubanItem(scrapy.Item):
    # 排名
    ranking = scrapy.Field()
    # 电影名称
    title = scrapy.Field()
    # 评分
    score = scrapy.Field()
    # 评论人数
    pople_num = scrapy.Field()
    # 导演
    director = scrapy.Field()
    # 年份
    year = scrapy.Field()
    # 地区
    area = scrapy.Field()
    # 类型
    clazz = scrapy.Field()
    # 电影描述
    decsription = scrapy.Field()

我们抓取到相应的网页后，需要从网页中提取自己需要的信息，可以使用xpath语法，我使用的是BeautifulSoup网页解析器，经过BeautifulSoup解析的网页，可以直接使用选择器筛选需要的信息。有一些说明写到代码注释里面去了，就不再赘述。
Chrome 也可以直接复制选择器或者XPath，如下图所示。

class douban_spider(Spider):

    count = 1

    # 爬虫启动命令
    name = &#39;douban&#39;

    # 头部信息，伪装自己不是爬虫程序
    headers = {
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&#39;,
    }

    # 爬虫启动链接
    def start_requests(self):
        url = &#39;https://movie.douban.com/top250&#39;
        yield Request(url, headers=self.headers)

    # 处理爬取的数据
    def parse(self, response):

        print(&#39;第&#39;, self.count, &#39;页&#39;)
        self.count += 1

        item = DoubanItem()
        soup = BeautifulSoup(response.text, &#39;html.parser&#39;)

        # 选出电影列表
        movies = soup.select(&#39;#content div div.article ol li&#39;)

        for movie in movies:
            item[&#39;title&#39;] = movie.select(&#39;.title&#39;)[0].text
            item[&#39;ranking&#39;] = movie.select(&#39;em&#39;)[0].text
            item[&#39;score&#39;] = movie.select(&#39;.rating_num&#39;)[0].text
            item[&#39;pople_num&#39;] = movie.select(&#39;.star span&#39;)[3].text

            # 包含导演、年份、地区、类别
            info = movie.select(&#39;.bd p&#39;)[0].text
            director = info.strip().split(&#39;\n&#39;)[0].split(&#39;   &#39;)
            yac = info.strip().split(&#39;\n&#39;)[1].strip().split(&#39; / &#39;)

            item[&#39;director&#39;] = director[0].split(&#39;: &#39;)[1]
            item[&#39;year&#39;] = yac[0]
            item[&#39;area&#39;] = yac[1]
            item[&#39;clazz&#39;] = yac[2]

            # 电影描述有为空的，所以需要判断
            if len(movie.select(&#39;.inq&#39;)) is not 0:
                item[&#39;decsription&#39;] = movie.select(&#39;.inq&#39;)[0].text
            else:
                item[&#39;decsription&#39;] = &#39;None&#39;
            yield item

        # 下一页：
        # 1，可以在页面中找到下一页的地址
        # 2，自己根据url规律构造地址，这里使用的是第二种方法
        next_url = soup.select(&#39;.paginator .next a&#39;)[0][&#39;href&#39;]
        if next_url:
            next_url = &#39;https://movie.douban.com/top250&#39; + next_url
            yield Request(next_url, headers=self.headers)

然后在项目文件夹内打开cmd命令，运行scrapy crawl douban -o movies.csv就会发现提取的信息就写入指定文件了，下面是爬取的结果，效果很理想。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/yong-scrapy-pa-qu-dou-ban-250">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/nian-qing-bu-yao-gei-zi-ji-she-xian">
                        年轻不要给自己设限
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-07-02</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/EE1uiCHgH" class="post-tag i-tag
                            i-tag-other_2">
            #个人总结
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/94PzxqinO" class="post-tag i-tag
                            i-tag-error">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/nian-qing-bu-yao-gei-zi-ji-she-xian">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/nian-qing-bu-yao-gei-zi-ji-she-xian.jpeg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            大学毕业时，选择了火车这一交通工具回家，再看一次从东北到西南的沿途风景，无奈火车居然能晚点两小时，这篇文章是为打发时间写的，希望对您有所帮助。
记得大一入学前，买了一本覃彪喜写的《读大学，究竟读什么》，那时候对于里面有一些观点不赞同，觉得大学这么神圣的地方，怎么被作者写成那样，读完一遍只是抱有一种怀疑的态度，四年之后的今天，我觉得这本书值得一看，大部分内容还是有用的，不过有一些内容还是很偏激的，自己过滤掉就好了。
现在回头看，大学最需要的应该是经历，我也是大三才算明白这个道理吧（这个道理应该不止学生能实用）。我认为本科阶段是容错率最高的阶段，这个时候你干什么都不怕，犯了错也没有什么大碍，最重要的是犯错（不犯错更好）的那个过程。
年轻人做什么都是学习，不要给自己设限，在一无所有的年龄就应该多经历，因为这时候的容错率很高，试错成本低就要勇于试错。（这句话可能之前的文章说过，大同小异的话你也能在别的好文章里面见到）
现在的家长，也包括孩子，大多数喜欢拿一些证书、奖杯出来炫耀，而现在大学里面的个性化保研政策看的就是各种奖项。我更看重的是比赛的过程，但是在学校有一个怪现象：我不想办事，只想你给我挂一个名，到出去比赛的时候，看到所报的项目自己不是第一作者，都不愿意去比赛，觉得是在浪费时间。
我个人在这里面算一股清流了，我很喜欢跟着出去比赛，因为比赛的过程能教会你很多在学校学不到的东西，给不给我奖状无所谓，只要给我报销差旅费就行了，这一点对我这种穷学生来说跟重要，想出去看看世界长长见识，自己又没有钱，学生群体中随随便便就拿出几千块钱的人还是不多，所以这是我找到的最好的长见识的方法了，上大学前连小县城都没出过的我，通过比赛到过佛山、深圳、重庆、日照等地，这对我算是一生的财富。
写到这里，脑子里面满满的全是回忆，发现想说的太多，全写出来可能会上万字，先不写了，以后分开写个系列的也行，下面说几句干货道理吧，过来人的总结。
第一，少拿学校的光环往自己身上套，和你没关系，对于我的学校动不动就拿哈军工说事（中国人都喜欢把自己和名家扯上关系，看起来显得有一些历史文化底蕴），完全是不自信的表现。作为唯一一个首批进入211缺不是985的学校，我觉得学校一直在啃老底。类似的文章还有之前写的谈一点关于名校的话题和刘大写的除去大公司的光环，你还剩点啥？
第二，学校教不了你多少东西，大学阶段和高中阶段最大的区别是，高中有人赶着你学，而且还有人给你指明学习的方向，但是大学没有人告诉你学什么，也没有人赶着你学习，所以培养自学能力和判断选择能力很重要，我个人认为这是大学阶段最应该学习到的东西。
第三，如果大学只学习了课本中的内容，那还不如不上大学，不得不承认，大学课本内容都属于经典中的经典，但是学校的要求太低，所以要自己去练习，而且很多老师所教授的东西属于过时的知识，有的课就应该逃掉，利用这个时间去做更有用的事情。
第四，真诚待人，学生阶段所交的朋友没多少功利性，能交几个铁哥们最好。我个人觉得比较实用的一个看人标准，你只需要看某个人对待其他人是什么样，就大概知道他对你会是什么样了；好比谈恋爱，你不要妄想渣男渣女到你这里就不渣了（小概率事件）。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/nian-qing-bu-yao-gei-zi-ji-she-xian">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/tan-yi-xia-xie-zuo-de-chong-yao-xing">
                        谈一下写作的重要性
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-06-20</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/EE1uiCHgH" class="post-tag i-tag
                            i-tag-primary">
            #个人总结
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/94PzxqinO" class="post-tag i-tag
                            i-tag-primary">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/tan-yi-xia-xie-zuo-de-chong-yao-xing">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/tan-yi-xia-xie-zuo-de-chong-yao-xing.jpeg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            关于写作的重要性，你可能在其他地方也见过一些描述，大致的说法都差不多，如果本文某些字句与你已经见过的文章有雷同，那纯属巧合，我仅从个人这几个月的感受出发来说。
我从三月份开始，在公众号上面发一些文章，其实从这几个月的表现来看，是把公众号当作博客来用了，我的初衷没有想着靠公众号赚钱，所以我的分享很随意，主要是技术、认知、阅读方面的东西。如果不喜欢，主动权在你手里，大可取关；如果喜欢，我的文章能让你少走一些弯路，那么我自己的目的达到了，给不给赞赏无所谓，其实心里还是希望你给的，咱没必要把自己放的太清高。
今天微信订阅号改版了，新版的订阅号基本形态变成了信息流，关于产品我还不太懂，但是我觉得这次改版对于作者的个人品牌形成不利，没内容的公众号应该会被取关很多粉丝，但是忠实粉丝也更难找到自己喜欢的“博主”了，所以以后，请认准作者。
很多人也有撰写博客的习惯，我很赞同这个做法，关于写作的好处我觉得有以下几点，只有认真去做了，才能体会到它带给自己的成长。
第一，写作是整理自己思维的过程，写作能力是一种重要的能力，不一定要多好的文采，但是不是每个人都能把语言组织的有条有理。现在的时代，没有铁饭碗，你需要不停的学习才能立于不败之地，很多人觉得写作是浪费时间，其实不然，写作是对已学知识的整理过程，输出其实是更高层次的输入。拿我之前写的朴素贝叶斯实现拼写检查器来说，其中那个贝叶斯公式推导是我花了很多分钟才想出来的，就好像老师教给学生一碗水，那么老师就必须具备一桶水才行。
第二，写作是个人品牌的建立过程，可以说微信已经成为了中国互联网的小小代名词，农村大叔大妈手机上面最可能出现的软件就是微信，微信打通中国互联网的最后一环，在这么大的平台上，你分享的内容对别人来说是有帮助的，那么你的个人品牌就已经逐渐在形成了，这是个人影响力的提升。个人品牌在以后一定会很重要，个人品牌在日常生活其实有体现，我相信每个人的微信都会屏蔽几个人的朋友圈信息吧，经常在朋友圈发一些无用信息、垃圾信息，这其实就是个人品牌的损失。
第三，通过写作你能交到很多朋友，而且通过这种方式所交到的朋友都是优秀的，他们会对你的成长起到促进作用，而你也会因为和他们交流而在不知不觉中得到提升，真正的朋友是相互促进的。我这几个月交到的朋友，刷新了我的认知，偏见来源于无知，在这个过程，我的认知得到了很大的提升，认知这玩意也不太好描述。举个例子，大概在大二的时候，我看到一篇文章说高中物理中所学的电子、质子等概念是错的，将要被新的知识体系取代，那时二话不说就转发朋友圈了，但没过几天就发现这其实是一个虚假信息；前段时间，中兴被美国制裁了，然后就有一些自媒体作者为了吸引流量，乱写一通什么华为宣布将要退出美国市场的消息，我的第一直觉就是这是虚假信息，然后我去验证了自己猜测的正确性，而周围很多人竟无脑式的选择了相信这条消息，还给我分析为什么华为要退出美国市场。这在我看来就是认知水平的一个体现，或者贴切一点叫信息素养（这个词不是我发明的），我现在对于信息的掌握已经明显快于周围的同学了，而且掌握的也比周围同学更加全面。
最后说一点，没必要为了写作而写作，经常在知识星球看到有人问问题，说自己的写不出东西来，怎么办？这就是自己的输入不够，自己体内没有实质的东西，如何能达到输出呢？更别说高质量的输出了。
我以后的文章主要是机器学习和提升认知方面的，最近更文有点慢，其一是自己也刚开始接触机器学习不久，要写出一篇比较好的文章，需要几天的输入；其二马上要毕业了，繁忙于各种琐碎的事情无法自拔。
总的来说，写作利大于弊，如果你有闲心，看一下我几个月前发的文章，再和我现在的文章做个对比，你能看到我的变化，在文章逻辑、排版等等方面都或多或少的有一些提升，所以我建议你如果空闲时间比较多，也可以尝试尝试写作，自己的成长过程会在字里行间被记录下来。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/tan-yi-xia-xie-zuo-de-chong-yao-xing">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/jing-ji-ze-ren-shen-ji-zhi-shi-tu-pu-gou-jian-fang-fa-zong-jie">
                        经济责任审计知识图谱构建方法总结
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-05-07</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/zi-ran-yu-yan-chu-li" class="post-tag i-tag
                            i-tag-warning">
            #自然语言处理
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/jing-ji-ze-ren-shen-ji-zhi-shi-tu-pu-gou-jian-fang-fa-zong-jie">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/jing-ji-ze-ren-shen-ji-zhi-shi-tu-pu-gou-jian-fang-fa-zong-jie.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            自 2012 年 Google 提出“知识图谱”的概念以来，知识图谱就一直是学术研究的重要方向，现在有很多高校、企业都致力于将这项技术应用到医疗、教育、商业等领域，并且已经取得了些许成果。Google 也宣布将以知识图谱为基础，构建下一代智能搜索引擎。
现在已经可以在谷歌、百度、搜狗等搜索引擎上面看到知识图谱的应用了。比如在 Google 搜索某个关键词时，会在其结果页面的右边显示该关键字的详细信息。在几个常用的搜索引擎中搜索知识时，返回的答案也变得更加精确，比如搜索“汪涵的妻子”，搜索引擎会直接给出答案“杨乐乐”，方便了用户快速精准的获取想要的信息。不过目前的搜索引擎只有少部分搜索问题能达到这种效果。
关于知识图谱是什么，我想就不用介绍了，这种通过搜索引擎就能轻松得到的结果写在这里有点浪费篇章，并且我对知识图谱的理解也不深，不敢夸夸其谈，只是把自己这一段时间以来的工作做一个总结。
本文只相当于以经济责任审计这一特定领域构建了一个知识图谱，仅仅是走了一遍流程，当作入门项目，构建过程中参考甚至抄袭了别人的很多方法与代码，末尾都会给出参考的项目等等。

上图是我构建经济责任审计知识图谱的流程，看起来很繁琐，但只要静下心看，个人觉得相对还算清晰，箭头都有指向。下面就一步一步进行说明。
数据获取
数据获取主要分为两部分数据，一部分是新闻类数据，我把它用作文本分类模型的训练集；另一部分是实体数据，为了方便，我直接把互动百科抓取的词条文件作为实体，省了属性抽取这一环节。
因为本文构建的是一个经济责任审计领域的知识图谱，所以作为文本分类模型训练集的数据也应该是经济责任审计领域的。这里主要抓取了审计署、纪检委、新浪网的部分新闻。

像上面的图一样，新闻类网站一般都有搜索框，为了简单，所以我直接用搜索框搜索“经济责任审计”，然后从搜索结果中抓取新闻数据，即认为是经济责任审计相关的文本。抓取新闻类网站使用了 chrome 模拟用户进行访问。最终获得了 3500 多条新闻文本。
领域词汇判定
领域词汇判定，本文构建的不是开放领域的知识图谱，所以需要采用一种方法来判定所抓取的内容是否属于经济责任审计领域。领域词汇本文的方法实际上是领域句子判定，直接使用了大神的项目。CNN-RNN中文文本分类，基于tensorflow。也看到有人通过改进逻辑回归算法，在进行领域词汇的判定。
实体关系抽取
知识图谱的基本单位为（实体1，关系，实体2）这样的三元组，实体是直接从互动百科获取的词条，关系由两部分组成，一部分来自 wikidata 所提供的关系，这一部分直接从 wikidata 爬取即可得到，另一部分使用的是基于依存句法分析的开放式中文实体关系抽取，已经在前面的文章发过了。
知识存储
有了实体和实体关系，那么把这些数据进行筛选，然后入库，通过直观的页面展示，就可以了。这里使用的数据库是 neo4j，它作为图形数据库，用于知识图谱的存储非常方便。知识的展示使用了别人的项目，仅仅是把里面的数据换掉了而已，感谢大神的无私。
最后放几张效果图

下面是以“职业”为关系查询条件所得出的结果。

总结一下
只是对几个月工作的梳理，大多数核心代码都改自现有的代码，所有的数据都来自于网络，与知识图谱相关的公开技术较少，我也只是尝试着做了一下，虽然很菜，也可以对大致的技术路线、流程有一个简单的了解，主要工作都是自然语言处理的内容。后期可以利用现在的知识图谱构建智能问答系统，实现从 what 到 why 的转换。
感谢
汉语言处理包 HanLP：https://github.com/hankcs/HanLP
中文文本分类：https://github.com/gaussic/text-classification-cnn-rnn
农业知识图谱：https://github.com/qq547276542/Agriculture_KnowledgeGraph
事实三元组抽取：https://github.com/twjiang/fact_triple_extraction
中文自然语言处理相关资料：https://github.com/mengxiaoxu/Awesome-Chinese-NLP
开放中文实体关系抽取：http://www.docin.com/p-1715877509.html

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/jing-ji-ze-ren-shen-ji-zhi-shi-tu-pu-gou-jian-fang-fa-zong-jie">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/ji-yu-yi-cun-ju-fa-fen-xi-de-kai-fang-shi-zhong-wen-shi-ti-guan-xi-chou-qu">
                        基于依存句法分析的开放式中文实体关系抽取
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-26</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/zi-ran-yu-yan-chu-li" class="post-tag i-tag
                            i-tag-">
            #自然语言处理
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/ji-yu-yi-cun-ju-fa-fen-xi-de-kai-fang-shi-zhong-wen-shi-ti-guan-xi-chou-qu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/ji-yu-yi-cun-ju-fa-fen-xi-de-kai-fang-shi-zhong-wen-shi-ti-guan-xi-chou-qu.jpeg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这一段时间一直在做知识图谱，卡在实体关系抽取这里几个月了，在 Github 上面看到有人使用卷积神经网络训练模型进行抽取，自己也尝试了一下，但是一直苦于没有像样数据去训练，而标注训练集又太费时间了，我不太愿意干体力活。所以采用了一个低档次的方法，基于依存句法分析的实体关系抽取，记录一下心得，方便日后忘记可以再找回来。
本方法参考了 Github 上面的项目和一篇论文，在文章末尾给出，使用的分词工具是 HanLP，感谢相关作者。
论文给出了 8 种中文关系的表达方式，并且最后给出了一个采用正则表达式语法指出表达，核心就是谓语动词表示关系，即关系表述中一定得有动词。
状语*动词+补语?宾语?

我不太赞同把宾语也当作关系表述的一部分，论文指出“p4生于山西”应该抽出（p4，山西，生于山西），我认为关系不应该表述为“生于山西”，所以我把关系表述改为下面的样子了。
状语*动词+补语?

这篇文章只是作为一个方法介绍，我自己先看了一遍，能够保证我下次看到这篇文章，可以立马回忆起自己的实现方法，希望你看了也能了解方法，看不懂的话，我表示抱歉，浪费您的时间了，我已经尽可能写到简单了。
先来看几个简单句子吧：
主谓宾关系：刘小绪 生于 四川
// 这个三元组很明显：（刘小绪，生于，四川）


动补结构：刘小绪 洗 干净 了 衣服
// 如果套用主谓宾关系就是：（刘小绪，洗，衣服）
// 但是这里描述的是一个状态，是刘小绪把衣服洗干净了
// “干净”是动词“洗”的补语，所以还应该提取出一个如下三元组
// （刘小绪，洗干净了，衣服）

状动结构：父亲 非常 喜欢 跑步
// 这句和上面很像，主谓宾关系是：父亲喜欢跑步
// “非常”用于修饰“喜欢”
// （父亲，非常喜欢，跑步）

介宾关系：刘小绪 就职 于 学校
// 如果直接把这个三元组抽取为（刘小绪，就职，学校），很别扭
// “于”和“学校”是介宾关系，它们的关系应该是：就职于
// （刘小绪，就职于，学校）

宾语前置：海洋 由 水 组成
// “海洋”是“组成”的前置宾语
// “由”是“组成”的状语
// “水”和“由”是介宾关系
// 所以上面的句子没有明确的主谓关系，需要我们判断
// 抽出的三元组应该为：（水，组成，海洋）

HanLP 提供了两种依存句法分析的器，默认采用的是基于神经网络的依存句法分析器。依存句法分析就是将句子分析成一棵依存句法树，描述各个词语之间的依存关系，即指出词语之间在句法上的搭配关系。
有了上面所说的依存句法树，其实我们只需要进行各种判断就可以了。先做出下面的一点说明，就拿第一个例子来说。
原文：刘小绪生于四川

# 这是分词结果
[刘小绪/nr, 生于/v, 四川/ns]

#这是句法分析结果
刘小绪 --(主谓关系)--&amp;gt; 生于
生于 --(核心关系)--&amp;gt; ##核心##
四川 --(动宾关系)--&amp;gt; 生于

为了方便理解，也为了方便程序的编写，我把他们组织成了下面的形式，为每一个词语都建一个依存句法字典。
刘小绪：{}
生于：{主谓关系=[刘小绪], 动宾关系=[四川]}
四川：{}

然后只需要写出类似于下面的程序段就可以抽出关系了。
// 主谓宾关系：刘小绪生于四川
// dic是这个词语的依存句法字典
if (dic.containsKey(&amp;quot;主谓关系&amp;quot;) &amp;amp;&amp;amp; dic.containsKey(&amp;quot;动宾关系&amp;quot;)){
    
    // 当前的词语，用上面的例子来说，relation=“生于”
    String relation = curWord.LEMMA;


    // 用循环遍历，是因为关系列表里面不一定只有一个词语
    for (CoNLLWord entity1:
            dic.get(&amp;quot;主谓关系&amp;quot;)) {

        for (CoNLLWord entity2:
                dic.get(&amp;quot;动宾关系&amp;quot;)) {

            System.out.println(entity1.LEMMA + &amp;quot;,&amp;quot; + relation + &amp;quot;,&amp;quot; + entity2.LEMMA);
        }

    }
}

对于分词后的每个词语都进行上面程序段的操作。“刘小绪”和“四川”，关系字典都为空。而对于“生于”，关系列表里面既有主谓也有动宾，而自己本身就是动词，主谓宾就出来了。直接从主谓关系中拿出来词语作为 entity1，再拿上自己作为关系，最后拿出动宾关系中的词语作为 entity2。很明确的三元组（刘小绪，生于，四川）就出来了。
最后给出一个程序运行结果图吧。

我个人觉得效果还行，在简单句子上面表现的差强人意，在长句子上面表现的差劲。
参考：
HanLP 自然语言处理
基于依存分析的开放式中文实体关系抽取方法
命名实体三元组抽取参考自fact_triple_extraction

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/ji-yu-yi-cun-ju-fa-fen-xi-de-kai-fang-shi-zhong-wen-shi-ti-guan-xi-chou-qu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou">
                        简单理解磁盘结构
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-24</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku" class="post-tag i-tag
                            i-tag-other_1">
            #数据库
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-other_1">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/jian-dan-li-jie-ci-pan-jie-gou.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            数据库系统总会涉及到辅助存储（大多都是磁盘），因为它们能够存储大量需要长期保存的数据，因此我们有必要先了解了解磁盘的相关知识。
根据机械原理，存储器的容量越大其速度就越慢。但是速度越快的存储器，其单位字节的价格就越贵。现代计算机系统可以包含几个不同的可以存储数据的部件，就形成了存储器的层次结构，但是需要注意的是「虚拟内存」是操作系统与操作系统运用机器硬件的产物，它不是存储器的层次之一。
磁盘结构
传统的硬盘盘结构是像下面这个样子的，它有一个或多个盘片，用于存储数据。盘片多采用铝合金材料；中间有一个主轴，所有的盘片都绕着这个主轴转动。一个组合臂上面有多个磁头臂，每个磁头臂上面都有一个磁头，负责读写数据。

磁盘一般有一个或多个盘片。每个盘片可以有两面，即第一个盘片的正面为0面，反面为 1 面；第二个盘片的正面为 2 面......依次类推。磁头的编号也和盘面的编号是一样的，因此有多少个盘面就有多少个磁头。盘面正视图如下图，磁头的传动臂只能在盘片的内外磁道之间移动。因此不管开机还是关机，磁头总是在盘片上面。关机时，磁头停在盘片上面，抖动容易划伤盘面造成数据损失，为了避免这样的情况，所以磁头都是停留在起停区的，起停区是没有数据的。

每个盘片的盘面被划分成多个狭窄的同心圆环，数据就存储在这样的同心圆环上面，我们将这样的圆环称为磁道 (Track)。每个盘面可以划分多个磁道，最外圈的磁道是0号磁道，向圆心增长依次为1磁道、2磁道......磁盘的数据存放就是从最外圈开始的。

根据硬盘的规格不同，磁道数可以从几百到成千上万不等。每个磁道可以存储数 Kb 的数据，但是计算机不必要每次都读写这么多数据。因此，再把每个磁道划分为若干个弧段，每个弧段就是一个扇区 (Sector)。扇区是硬盘上存储的物理单位，现在每个扇区可存储 512 字节数据已经成了业界的约定。也就是说，即使计算机只需要某一个字节的数据，但是也得把这个 512 个字节的数据全部读入内存，再选择所需要的那个字节。

柱面是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为柱面 ，即各盘面上面相同位置磁道的集合。需要注意的是，磁盘读写数据是按柱面进行的，磁头读写数据时首先在同一柱面内从 0 磁头开始进行操作，依次向下在同一柱面的不同盘面(即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面。因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。数据的读写是按柱面进行的，而不是按盘面进行，所以把数据存到同一个柱面是很有价值的。
磁盘被磁盘控制器所控制（可控制一个或多个），它是一个小处理器，可以完成一些特定的工作。比如将磁头定位到一个特定的半径位置；从磁头所在的柱面选择一个扇区；读取数据等。

现代硬盘寻道都是采用CHS(Cylinder Head Sector)的方式，硬盘读取数据时，读写磁头沿径向移动，移到要读取的扇区所在磁道的上方，这段时间称为寻道时间(seek time)。因读写磁头的起始位置与目标位置之间的距离不同，寻道时间也不同。磁头到达指定磁道后，然后通过盘片的旋转，使得要读取的扇区转到读写磁头的下方，这段时间称为旋转延迟时间(rotational latencytime)。然后再读写数据，读写数据也需要时间，这段时间称为传输时间（transfer time）。
根据上文的信息，我们可以得出磁盘容量的计算公式为：
硬盘容量 = 盘面数 × 柱面数 × 扇区数 × 512字节

笔试题实战
下面的题目是腾讯某一年校招笔试中的一个题目，题干信息描述为：数据存储在磁盘上的排列方式会影响I/O服务的性能，一个圆环磁道上有10个物理块，10个数据记录R1~R10存放在这个磁道上，记录的安排顺序如下表所示。



物理块
1
2
3
4
5
6
7
8
9
10




逻辑记录
R1
R2
R3
R4
R5
R6
R7
R8
R9
R10



假设磁盘的旋转速度为20ms，磁盘当前处在R1的开头处，若系统顺序扫描后将数据放入单缓冲区内，处理数据的时间为4ms（然后再读取下个记录），则处理这10个记录的最长时间是多少？

答案：磁盘会一直朝某个方向旋转，不会因为处理数据而停止。本题要求顺序处理 R1 到 R10，起始位置在 R1，一周是 20ms，共 10 个记录，所以每个记录的读取时间为 2ms。首先读 R1 并处理 R1，读 R1 花 2ms，读好后磁盘处于 R1 的末尾或 R2 的开头，此时处理 R1，需要 4ms，因为磁盘一直旋转，所以 R1 处理好了后磁盘已经转到 R4 的开始了，这时花的时间为 2+4=6ms。这时候要处理 R2，需要等待磁盘从 R5 一直转到 R2 的开始才行，磁盘转动不可反向，所以要经过 8*2ms 才能转到 R1 的末尾，读取 R2 需要 2ms，再处理 R2 需要 4ms，处理结束后磁盘已经转到 R5 的开头了，这时花的时间为 2*8+2+4=22ms。等待磁盘再转到 R3 又要 8*2ms，加上 R3 自身 2ms 的读取时间和 4ms 的处理时间，花的时间也为 22ms，此时磁盘已经转到 R6 的开头了，写到这里，就可以看到规律了，读取并处理后序记录都为 22ms，所以总时间为 6+22*9=204ms。

如何加速对磁盘的访问
对于理解数据库系统系统特别重要的是磁盘被划分为磁盘块（或像操作系统一样称之为页），每个块的大小是 4~64KB。磁盘访问一个磁盘块平均要用 10ms，但是这并不表示某一应用程序将数据请求发送到磁盘控制器后，需要等 10ms 才能得到数据。如果只有一个磁盘，在最坏的情况下，磁盘访问请求的到达个数超过 10ms 一次，那么这些请求就会被无限的阻塞，调度延迟将会变的非常大。因此，我们有必要做一些事情来减少磁盘的平均访问时间。
按柱面组织数据：前这一点在前文已经提到过了。因为寻道时间占平均块访问时间的一半，如果我们选择在一个柱面上连续的读取所有块，那么我们只需要考虑一次寻道时间，而忽略其它时间。这样，从磁盘上读写数据的速度就接近于理论上的传输速率。
使用多个磁盘：如果我们使用多个磁盘来替代一个磁盘，只要磁盘控制器、总线和内存能以 n 倍速率处理数据传输，则使用 n 个磁盘的效果近似于 1 个磁盘执行了 n 次操作。因此使用多个磁盘可以提高系统的性能。
磁盘调度：提高磁盘系统吞吐率的另一个有效方法是让磁盘控制器在若干个请求中选择一个来首先执行，调度大量块请求的一个简单而有效的方法就是电梯算法。回忆一下电梯的运行方式，它并不是严格按先来后到的顺序为乘客服务，而是从建筑物的底层到顶层，然后再返回来。同样，我们把磁盘看作是在做横跨磁盘的扫描，从柱面最内圈到最外圈，然后再返回来，正如电梯做垂直运动一样。
预取数据：在一些应用中，我们是可以预测从磁盘请求块的顺序的。因此我们就可以在需要这些块之前就将它们装入主存。这样做的好处是我们能较好的调度磁盘，比如采用前文的电梯算法来减少访问块所需要的平均时间。
磁盘故障
如果事情都像我们一开始设计的那样进行，那世界肯定会变得特别无聊。磁盘偶尔也会耍耍小脾气，甚至是罢工不干了。比如在读写某个扇区一次尝试没有成功，但是反复尝试后有成功读写了，我们称之为间歇性故障。
一种更为严重的故障形式是，一个或多个二进制位永久的损坏了，所以不管我们尝试多少次都不可能成功，这种故障称之为介质损坏。
另一种相关的错误类型称之为写故障，当我们企图写一个扇区时，既不能正确的写，也不能检索先前写入的扇区，发生这种情况的一种可能原因就是在写过程中断电了。
当然肯定最严重的就是磁盘崩溃，这种故障中，整个磁盘都变为永久不可读，这是多么可怕的事情。
既然会出现上面所述的各种大小故障，那么我们就必须要采取各种措施去应对大大小小的变故，保证系统能正常运行。
规避故障
我们尝试读一个磁盘块，但是该磁盘块的正确内容没有被传送到磁盘控制器中，就是一个间歇性故障发生了。那么问题是控制器如何能判断传入的内容是否正确呢？答案就是使用校验和，即在每个扇区使用若干个附加位。在读出时如果我们发现校验和对数据位不合适，那么我们就知道有错误；如果校验和正确，磁盘读取仍然有很小的可能是不正确的，但是我们可以通过增加趣多校验位来降低读取不正确发生的概率。
此处我们使用奇偶校验来举例，通过设置一个校验位使得二进制集合中 1 的个数总是偶数。比如某个扇区的二进制位序列是 01101000，那么就有奇数个 1，所以奇偶位是 1，这个序列加上它后面的奇偶位，就有 011010001；而如果所给的序列是 11101110，那么奇偶位就是 0。所以每一个加上了奇偶位构成的 9 位序列都有偶数奇偶性。
尽管校验和几乎能正确检测出介质故障或读写故障的存在，但是它却不能帮助我们纠正错误。为了处理这个问题，我们可以在一个或多个磁盘中执行一个被称为稳定存储的策略。通常的思想是，扇区时成对的，每一对代表一个扇区内容 X。我们把代表 X 的扇区对分别称为左拷贝 XL和右拷贝XR。这样实际上就是每个扇区的内容都存储了两份，操作XL失败，那么去操作XR就可以了，更何况我们还在每个扇区中有校验和，把错误的概率就大大降低了。
到现在为止，我们讨论的都是简单的故障，但是如果发生了磁盘崩溃，其中的数据被永久破坏。而且数据没有备份到另一种介质中，对于银行金融系统这将是巨大的灾难，遇到这种情况我们应该怎么办呢？
数据恢复
应对磁盘故障最简单的方式就是镜像磁盘，即我们常说的备份。回忆一下写毕业论文时的做法，那时候大部分同学还不会用版本控制器，所以基本采用每天备份一次数据，并且在文件名称中标注日期，以此来达到备份的效果。
第二种方式是使用奇偶块，比如一个系统中有 3 个磁盘，那么我们再加一个磁盘作为冗余盘。在冗余盘中，第 i 块由所有数据盘的第 i 块奇偶校验位组成。也就是说，所有第 I 块的第 j 位，包括数据盘和冗余盘，在它们中间必须有偶数个 1，冗余盘的作用就是让这个条件为真。
我们举个简单例子，假设快仅由一个字节组成，我们有三个数据盘和一个冗余盘，对应的位序列如下。其中 盘4 为冗余盘，它的位序列是根据前面三个盘计算出来的。
盘 1：11110000
盘 2：10101010
盘 3：00111000
盘 4：01100010

假设现在某个盘崩溃了，那么我们就能根据上面的序列来恢复数据，只需要让每一列 1 的个数为偶数就可以了，但是这种冗余方式也存在很大的不足。
第一个缺陷是，如果是两个盘同时崩溃了，那数据也恢复不出来了。第二个问题在于，虽然读数据只需要一次 I/O 操作即可，但是写数据时就不一样了，因为需要根据其他数据盘来计算冗余盘中的位序列，假设共有 n 个盘，其中一个为冗余盘，所以每次写数据时，都需要进行 n+1 次 I/O 操作（读不被写入的 n-1 个盘，被重写数据盘的一次写，冗余盘的一次写），而 I/O操作又是非常耗时的操作，所以这种方法会大大拖慢系统性能。
另一种方案是没有明显的冗余盘，而是把每个磁盘作为某些块的冗余盘来处理。比如现在有 4 个盘，0 号磁盘将作为编号为 4、8、12 等柱面的冗余，而 1 号磁盘作为编号为 1、5、9 等块的冗余......
一种更为先进的方式使用海明码来帮助从故障中恢复数据，它在多个磁盘崩溃的情况下也能恢复出数据，也是 RAID 的最高等级，由于本人水平有限，用文字表达不清楚，就不作介绍了，嘿嘿。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/FoEH1GV6f">
                        阅读高于自己的作品，远离精神毒品
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-19</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/94PzxqinO" class="post-tag i-tag
                            i-tag-">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/FoEH1GV6f">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/FoEH1GV6f.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            关于阅读与写作的重要性，可能每个人都多少有一些概念。阅读打开世界的大门，写作提升语言组织能力。
还在读大一大二的时候，我很崇拜那些随随便便就能做一个网站、写一个复杂算法的大神。那时候仅仅盯着技术，认为只要技术好，怎么样都行，因此在大二阶段，我没有读过一本技术之外的书籍，现在看来是眼界狭隘了。
专业能力是生存之本，但是其他方面的能力也同样重要，大学能交给我们的只是一个在社会上赖以生存的本领（实际上一部分连赖以生存的本领都没有从大学学到），其他的技能需要靠自己的主动学习。
阅读是一种了解知识的重要手段，但并不是所有的阅读都是有效的，甚至有的阅读是精神毒品。
阅读需要挑选高于自己的作品，要能仰视它，才能攀登。现在的生活节奏很快，碎片化阅读成了很多人的阅读方式；有人抨击碎片化阅读，也有人提倡碎片化阅读，每个人由不同的观点，我个人是赞同碎片化阅读的。
来自互联网的阅读内容和自己大多是平等的，每个人都在使用微信，但我相信很多人都有屏蔽一些人朋友圈的习惯，因为你会选择跟你脾气相同、你喜欢的、跟你水平接近内容去阅读；现在的 APP 也很多，而且很多首次注册都会让你选择自己感兴趣的内容，所以也就会失去挑战自我的机会。
阅读是提升认知的重要手段，人与人之间的根本差距在于认知，如果读了一本书之后能让自己的认知得到提升，那么这就没白读；当然，如果读完一本书或是一篇文章之后能让有很大程度的转变，那这种认知的提升我相信是宝贵的财富，而且认识是伴随终身的。能达到这样效果的好文章、好书肯定少之又少，对我个人影响的最大的一本书是《把时间当作朋友》，我很推荐这本书，接触这本书算我认知上的一个转折点。
也有一些阅读是日积月累对自己产生影响的。我曾经关注了近 150 个公众号，从里面精挑细选了一部分原创公众号留下，涉及技术、新闻、产品、理财等方面。我现在每天的阅读主要就是公众号阅读和付费加入的几个知识星球，以及得到上面的付费知识。
日积月累，我筛选有效信息的能力也更强了，我认为筛选信息能力在这个信息爆炸的时代是很重要的。
有一次听到朋友说：“文章太长了，我不想看”。我没说话，只给了一个无奈的眼神，因为他只想要一个结论，因为这可以很轻松的获得一种愉悦感，而且对大脑来说，也是最容易接受的，但是慢慢地，大脑就会失去独立思考的能力。
从产品角度讲，不得不佩服头条对人性的洞察，为了“懂你”，在自己的产品上加入推荐算法，但实际上是让你把时间花在他们产品的身上，把产品做到这种程度，不得不说是很牛的。
但是像抖音、快手、头条、微博这些产品我认为基本都是在浪费用户时间（我还没有用过快手和微博，评价它们有点冒昧了），他们无异于精神毒品，吞噬你的时间。我并不是讨厌这些产品，我自己也喜欢体验新的产品，我只是觉得把宝贵的时间放到更有价值的事情上去，那么就会比周边人更加优秀。
需要选择的是高于自己内容阅读，而不是把时间都花在那种不需要思考就能得到的愉悦上去；如果把大部分时间都花在轻易就能获得的愉悦感上，那么你应该正在一步步颓废。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/FoEH1GV6f">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/8-A2fl99e">
                        告别囤干货，你才能真正进步
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/94PzxqinO" class="post-tag i-tag
                            i-tag-other_3">
            #生活感悟
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/8-A2fl99e">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/8-A2fl99e.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这两天，没事整理了自己的微信收藏和 QQ 收藏文件夹下面的文章。发现了一个在大多数人身上都存在的问题，那就是囤干货。
我使用微信的时间比较晚，从14年才开始，但是仅仅不到4年的时间，在微信收藏里面就有几百篇文章，有一些传授技能的文章，比如 word、ps 等简单教程；其他一些属于心灵鸡汤类文章（现在反倒不觉得这类文章值得看），还有一些搞笑的文章，当然里面也夹杂着些许的优秀视频。文章数量数 14 年和 15 年最多。
现在回头看，我当时就陷入了囤文章的陷阱了，或者说自己是在“假装阅读”。仔细一想，其实生活中大多数人都有类似的举动。早成起床、饭后的一段时间、晚上睡觉前，这些时间大多数人都习惯性的去翻翻公众号、朋友圈，这里面不乏有好文章、干货文章。然而没多少人会静下心来把文章读完，而是在大概读到一半的时候，选择收藏这篇文章，然后在心里告诉自己，明天要好好读一下这篇文章。到了明天，其实又是重复了今天的这样一个过程。
记得大概一年前也无意中看到大学认识的一位师弟发的说说，内容如下：

上面的图是我特地翻出来的，一年后这个师弟又发了一条说说，存满了两个云盘，应该是有 5000 G 左右的资源。
我认为这都是在假装学习，而且假装学习的人不计其数。为什么上学的时候，那些每天都静静的待在教室学习的同学，成绩反倒不是很好呢？而且大多数这样的学生在班级都是排在中等，而成绩好的学生却不是学习投入最多的人。背后的原因显而易见。
我囤课最严重的时间段是也是 14 年和 15 年，网上有不少干货资源，什么 Linux、各种项目实战、计算机网络等等培训视频不计其数。那时候干的第一件事就是，上百度云把这些资源下下来，而且一个资源往往要下一周甚至更久；然后告诉自己，下周开始每天看一段视频，但是最终的结果是过去了 N 个下周，依然没有去处理这些资源。
现在博客、公众号也有一些不知道是为了获取更多人的关注，还是仅仅是做公益，文章末尾会标注：关注公众号，回复“XXXXX”，即可获得多少多少G的资源，这个多少一般是在 500 以上。我个人现在是对这类文章没有什么兴趣的，因为几百 G 甚至上千 G 的东西，我是不可能看完的，我清楚自己的能力，我也不否认可能有人有毅力能看完，那肯定是凤毛菱角了，我一个普通人不与凤毛菱角对比。
当然，我现在的认识相比几年前，得到了一些提升，至少我现在不糊干囤课之类的事了，仅仅是把干货囤在那里，其时你还是昨天的自己，并没有进步。现在我都会把自己收藏的好文章在一周之内处理掉。
所以要想真正取得进步，首先就需要告别囤课的习惯，不能假装学习，如果学习是为了给比别人看，那还不如不学。文章仅是我个人的一点感悟，没有文采逻辑和言，总之希望与你共勉。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/8-A2fl99e">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/CY4_BQLR4">
                        正则表达式语法
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-03-29</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/JYJKwJM69" class="post-tag i-tag
                            i-tag-info">
            #编译原理
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/QjCHA76i_r" class="post-tag i-tag
                            i-tag-info">
            #编程基础
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/CY4_BQLR4">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/CY4_BQLR4.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这两天一直在时不时的和 Neo4j 图数据库打交道。它的查询语句可以使用正则表达式，有一段时间没有自己写过正则表达式了，现在处于能看懂别人写的正则表达式，但是自己写不出来，语法规则都忘了。为了方便接下来的工作，所以特地复习复习正则表达式的语法。
正则表达式简介
正则表达式是用来匹配字符串的一系列匹配符，具备简介高效的特点，在很多语言中都有支持（java、python、javascript、php 等等）。在 windows 的 cmd 命令中也同样支持，例如使用命令 dir j*，那么只会罗列出所有以j开头的文件和文件夹。
正则表达式基本语法
正则表达式在在不同语言的支持语法略有不同，本文采用js的进行说明。js 中使用正则表达式的方法为str.match(/表达式/)，即需要加两个斜杠。以下所有的代码段第一行为代码，第二行为返回结果，实验是在 chrome 控制台进行的。
一直认为最好的学习方式就是实际操作，理论谁都能讲一大堆，但是实际做没做出来还真不知道。一个奇葩现象就是教软件工程的老师可能并没有在软件行业待过。
普通匹配符
普通匹配符能匹配与之对应的字符，默认区分大小写。
&amp;quot;Hello Regx&amp;quot;.match(/H/)
[&amp;quot;H&amp;quot;, index: 0, input: &amp;quot;Hello Regx&amp;quot;, groups: undefined]

正则标记符

i ：不区分大小写
g ：全局匹配
m ：多行匹配（暂不管它，我用的少）

参数直接加在最后一个斜杠的后面，比如&amp;quot;Hello Regx&amp;quot;.match(/regx/i)，可以加多个参数。
&amp;quot;Hello Regx&amp;quot;.match(/regx/i)
[&amp;quot;Regx&amp;quot;, index: 6, input: &amp;quot;Hello Regx&amp;quot;, groups: undefined]

之前是表达式一旦匹配成功，就不再向字符串后面查找了，加上 g 后，表示进行全局查找。最后返回的是一个数组。
&amp;quot;Hello Regx&amp;quot;.match(/e/g)
(2) [&amp;quot;e&amp;quot;, &amp;quot;e&amp;quot;]

多匹配符

\d ：匹配数字，即 0~9
\w ：匹配数字、字母、下划线
. ：匹配除换行的所有字符

需要注意的是，上面所有的匹配符都只能匹配一个字符。
&amp;quot;Hello 2018&amp;quot;.match(/\d/g)
// 使用\d,匹配字符串中的所有数字
(4) [&amp;quot;2&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;8&amp;quot;]


&amp;quot;Hello 2018&amp;quot;.match(/\w/g)
// 使用\w，匹配所有的数字和字母，需要注意没有匹配到空格
(9) [&amp;quot;H&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;8&amp;quot;]


&amp;quot;Hello 2018&amp;quot;.match(/./g)
// 使用.，匹配所有字符，包括空格
(10) [&amp;quot;H&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;8&amp;quot;]


&amp;quot;Hello 2018&amp;quot;.match(/\d\w./g)
// 分析一下这个为什么匹配到的是201，
// 首先\d找到第一个数字2，匹配成功，紧接着\w匹配到0，然后.匹配到1
// 整个正则表达式匹配成功，返回201
[&amp;quot;201&amp;quot;]


&amp;quot;Hello 20\n18&amp;quot;.match(/\d\w./g)
// 这里匹配不成功，因为.不能匹配换行符，所以返回null
null


&amp;quot;Hello 2018&amp;quot;.match(/\w.\d/g)
// 首先看这个正则式，\w.\d，它要求最后一个字符是数字
// \w.能一直匹配到空格，但是因为得满足\d，所以第一个匹配成功的是0 2
// 因为是全局匹配，所以会接着匹配后面的018，也匹配成功
(2) [&amp;quot;o 2&amp;quot;, &amp;quot;018&amp;quot;]

自定义匹配符
比如中国的手机号都是以 1 开头，第二位只能是 3、4、5、7、8，第 3 位只要是数字就行。如何匹配这样的字符串？

[] ：匹配[]中的任意一个字符

&amp;quot;152&amp;quot;.match(/1[34578]\d/)
// 第二个字符可以选择中括号中的任意一个
[&amp;quot;152&amp;quot;, index: 0, input: &amp;quot;152&amp;quot;, groups: undefined]

如果在 [] 添加了 ^,代表取反。即 [^] 表示除了中括号中的字符都满足。
&amp;quot;152&amp;quot;.match(/1[^34578]\d/)

null


&amp;quot;1a2&amp;quot;.match(/1[^34578]\d/)
// 只要不是[]中的字符，都满足，包括回车符
[&amp;quot;1a2&amp;quot;, index: 0, input: &amp;quot;1a2&amp;quot;, groups: undefined]

修饰匹配次数
我们的手机号有 11 位，除了前 2 位有要求，其他9位度没有要求，那么是不是正则表达式就应该这样写呢？
1[^34578]\d\d\d\d\d\d\d\d\d

很明显，这样写太麻烦，肯定有更好的方式，这里就可以修饰一下匹配次数啦。

? ：最多出现 1 次
+ ：至少出现 1 次
* ：出现任意次数
{} ：分下面四种情况

{n}代表前面的匹配符出现 n 次
{n, m}出现次数在 n~m 之间
{n, }至少出现 n 次
{, m}最多出现 m 次



例子很简单，一看就懂，不浪费时间。
&amp;quot;15284750845&amp;quot;.match(/1[34578]\d{9}/)
[&amp;quot;15284750845&amp;quot;, index: 0, input: &amp;quot;15284750845&amp;quot;, groups: undefined]


&amp;quot;15&amp;quot;.match(/1[34578]\d?/)
[&amp;quot;15&amp;quot;, index: 0, input: &amp;quot;15&amp;quot;, groups: undefined]


&amp;quot;152&amp;quot;.match(/1[34578]\d?/)
[&amp;quot;152&amp;quot;, index: 0, input: &amp;quot;152&amp;quot;, groups: undefined]


&amp;quot;152&amp;quot;.match(/1[34578]\d+/)
[&amp;quot;152&amp;quot;, index: 0, input: &amp;quot;152&amp;quot;, groups: undefined]


&amp;quot;15&amp;quot;.match(/1[34578]\d+/)
null

完整匹配
按照上面的写法会出现下面的问题。
&amp;quot;ya15284750845&amp;quot;.match(/1[34578]\d{9}/)
// 不是电话号码，也能匹配成功，需要进一步改进
[&amp;quot;15284750845&amp;quot;, index: 2, input: &amp;quot;ya15284750845&amp;quot;, groups: undefined]


^ ：在 [] 中代表取反，但在外面代表从开始匹配

&amp;quot;ya15284750845&amp;quot;.match(/^1[34578]\d{9}/)
// 现在就能从一开始匹配而且还得符合正则式才算匹配成功
null


// 但是依旧会出现下面的问题
&amp;quot;1528475084523255&amp;quot;.match(/^1[34578]\d{9}/)
// 不是电话号码也能匹配成功，还要改进
[&amp;quot;15284750845&amp;quot;, index: 0, input: &amp;quot;1528475084523255&amp;quot;, groups: undefined]


$ ：代表持续匹配到结束

&amp;quot;1528475084523255&amp;quot;.match(/^1[34578]\d{9}$/)
// 现在就能保证正确了，有^表示从开始匹配；
// 有$表示持续匹配到结束，即完全匹配
null

/*
需要注意的是，一个字符串从开始匹配和从结束匹配都没问题，
不代表整个字符串就没问题，比如 15284750845-15284750845
这个字符串从开始和从结束匹配都能成功，但实际上是错的
*/

特殊符号
到这里发现正则表达式确实很强大，仅仅几个简单的符号就能匹配字符串，但是如果我们要匹配的字符本身就是前面用到的符号怎么办呢？

匹配像$、^等特殊符号时，需要加转义字符\

&amp;quot;1.&amp;quot;.match(/./)
//因为.能匹配除换行的所有字符，所以匹配到1
//但实际上我们想匹配.这个字符
[&amp;quot;1&amp;quot;, index: 0, input: &amp;quot;1.&amp;quot;, groups: undefined]


&amp;quot;1.&amp;quot;.match(/\./)
// 只需要加一个转义字符就可以了，其他类似
[&amp;quot;.&amp;quot;, index: 1, input: &amp;quot;1.&amp;quot;, groups: undefined]

条件分支
比如现在想匹配图片的文件名，包括 jpg、png、jpeg、gif 等等，这是多个选项，所以需要像编程语言一样，应该具备条件分支结构。

| ：条件分支
() ：有两层含义

括号中的内容成为一个独立的整体
括号的内容可以进行分组，单独匹配，若不需要此功能，则( ?: )



&amp;quot;1.jpg&amp;quot;.match(/.+\.jpe?g|gif|png/)
// 这样就可以满足条件分支了,不过下面又出问题了
[&amp;quot;1.jpg&amp;quot;, index: 0, input: &amp;quot;1.jpg&amp;quot;, groups: undefined]


&amp;quot;1.png&amp;quot;.match(/.+\.jpe?g|gif|png/)
// 这里没有匹配到.和前面的文件名
[&amp;quot;png&amp;quot;, index: 2, input: &amp;quot;1.png&amp;quot;, groups: undefined]


/*
其实我们想告诉它的是，.和后面的每一个条件分支的值都是一个独立的整体
但是它把.+\.jpe?g、gif、png当成了各自独立的整体
我们并不想让它这样切分，所以我们来告诉它怎么分才是正确的
*/


&amp;quot;1.png&amp;quot;.match(/.+\.(jpe?g|gif|png)/)
// 现在可以匹配成功了，但是它多匹配了一个
// 因为括号的内容可以进行分组，单独匹配
(2) [&amp;quot;1.png&amp;quot;, &amp;quot;png&amp;quot;, index: 0, input: &amp;quot;1.png&amp;quot;, groups: undefined]


// 所以最终写法如下
&amp;quot;1.png&amp;quot;.match(/.+\.(?:jpe?g|gif|png)/)
[&amp;quot;1.png&amp;quot;, index: 0, input: &amp;quot;1.png&amp;quot;, groups: undefined]

贪婪与懒惰
// 首先看一个例子
&amp;quot;aabab&amp;quot;.match(/a.*b/)
[&amp;quot;aabab&amp;quot;, index: 0, input: &amp;quot;aabab&amp;quot;, groups: undefined]


/*
上面的匹配没有什么问题，但实际上aab也是可以的
也就是aab也是符合条件的，那又是为什么呢？
*/

因为在正则表达式中，默认是贪婪模式，尽可能多的匹配，可以在修饰数量的匹配符后面添加 ?，则代表懒惰。
// like this (^__^)
&amp;quot;aabab&amp;quot;.match(/a.*?b/)
[&amp;quot;aab&amp;quot;, index: 0, input: &amp;quot;aabab&amp;quot;, groups: undefined]

到这里应该就差不多了，再深入的，就自我查询知识了。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/CY4_BQLR4">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
            <a href="https://mengxiaoxu.github.io/page/4/" class="page-btn btn">上一页</a>
            
                
    </div>
    
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1578671811564)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji">小工具收集</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">Vue + TypeScript 项目起手式</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/2019-nian-zong-jie">2019 年个人总结</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men">MongoDB 聚合入门</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/yong-hu-guan-zhu-er-cheng-xu-yuan-bu-guan-zhu-de-shi">用户关注而程序员不关注的事</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>