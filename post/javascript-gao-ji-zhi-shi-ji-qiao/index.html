<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    JavaScript 高级知识技巧 | 刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1578407258539">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1578407258539" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            JavaScript 高级知识技巧
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2019-10-13</time>
                            
                                <a href="https://mengxiaoxu.github.io//tag/javascript" class="post-tag i-tag
                            i-tag-error">
                            #JavaScript
                        </a>
                                
                                <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz" class="post-tag i-tag
                            i-tag-error">
                            #前端
                        </a>
                                
                        </div>
                        
                            <div class="post-feature-image" style="background-image: url('https://mengxiaoxu.github.io//post-images/javascript-gao-ji-zhi-shi-ji-qiao.png')"></div>
                            
                                <div class="post-content">
                                    <h2 id="对象">对象</h2>
<p>Js 共有<code>number、string、boolean、null、undefined、object</code>六种主要类型，除了<code>object</code>的其它五中类型都属于基本类型，它们本身并不是对象。但是<code>null</code>有时会被当做对象处理，其原因在于不同的对象在底层都表示为二进制，在 js 中二进制前三位都为 0 的话就会被判定为<code>object</code>类型，而<code>null</code>的二进制表示全是 0， 所以使用<code>typeof</code>操作符会返回<code>object</code>，而后续的 Js 版本为了兼容前面埋下的坑，也就没有修复这个 bug。</p>
<p><code>&quot;I'm a string&quot;</code>本身是一个字面量，并且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度、访问某个字符等，那就需要将其转换为<code>String</code>类型，在必要的时候 js 会自动帮我们完成这种转换，也就是说我们并不需要用<code>new String('I'm a string')</code>来显示的创建一个对象。类似的像使用<code>42.359.toFixed(2)</code>时，引擎也会自动把数字转换为<code>Number</code>对象。</p>
<p><code>null</code>和<code>undefined</code>没有对应的构造形式，它们只有文字形式。相反，<code>Date</code>只有构造，没有文字形式。对于<code>Object、Array、Function</code>和<code>RegExp</code>（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</p>
<h2 id="array-类型">Array 类型</h2>
<p>数组类型有一套更加结构化的值存储机制，但是要记住的是，数组也是对象，所以有趣的是你也可以给数组添加属性。</p>
<pre><code class="language-javascript">var myArray = [&quot;foo&quot;, 42, &quot;bar&quot;];
myArray.baz = &quot;baz&quot;;
myArray.length; // 3
myArray.baz; // &quot;baz&quot;
</code></pre>
<p>数组类型的<code>length</code>属性是比较有特点的，它的特点在于不是只读的，也就是说你可以修改它的值。因此可以通过设置这个属性从数组末尾删除或添加新的项。</p>
<pre><code class="language-javascript">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
colors.length = 2;
console.info(colors[2]); // undefined
colors.length = 4;
console.info(colors[4]); // undefined
// 向后面追加元素
colors[colors.length] = &quot;black&quot;;
</code></pre>
<p>数组还有一些很方便的迭代方法，比如every()、filter()、forEach()、map()、some()，这些方法都不会修改数组中包含的值，传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、和数组对象本身。</p>
<h2 id="function-类型">Function 类型</h2>
<p>在 ECMAScript 中，每个函数都是<code>Function</code>类的实例，而且都与其它引用类型一样具有属性和方法。由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>在函数的内部有两个特殊的对象，<code>this</code>和<code>arguments</code>。<code>arguments</code>对象有<code>callee</code>和<code>caller</code>属性。<code>caller</code>用来指向调用它的<code>function</code>对象，若直接在全局环境下调用，则会返回<code>null</code>；<code>callee</code>用来指向当前执行函数，所以我们可以通过下面的方式来实现阶乘函数。</p>
<pre><code class="language-javascript">function factorial(num) {
    if (num &lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
</code></pre>
<p>每个函数都包含两个非继承而来的方法，<code>apply()</code>和<code>call()</code>，这两个方法都是在特定作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。首先，<code>apply()</code>方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是<code>Array</code>的实例，也可以是<code>arguments</code>对象。<code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅仅在于接收参数的方式不同，在使用<code>call()</code>方法时必须逐个列举出来。</p>
<pre><code class="language-javascript">window.color = &quot;red&quot;;
var o = {color: &quot;blue&quot;};
function sayColor() {
    console.info(this.color);
}
sayColor(); // red
sayColor.call(this); // red
sayColor.call(window); // red
sayColor.call(o); // blue
sayColor.apply(o); // blue
</code></pre>
<p>需要注意的是，在严格模式下未指定环境对象而调用函数，则<code>this</code>值不会转型为<code>window</code>，除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>。</p>
<h2 id="安全的类型检查">安全的类型检查</h2>
<p>Js 内置的类型检查机制并不是完全可靠的，比如在 Safari（第5版前），对正则表达式应用<code>typeof</code>操作符会返回<code>function</code>；像<code>instanceof</code>在存在多个全局作用域（包含 frame）的情况下，也会返回不可靠的结果；前文提到的 Js 一开始埋下的坑也会导致类型检查出错。</p>
<p>我们可以使用<code>toString()</code>方法来达到安全类型检查的目的，在任何值上调用<code>Object</code>原生的<code>toString()</code>方法都会返回一个<code>[object NativeConstructorName]</code>格式的字符串，下面以检查数组为例。</p>
<pre><code class="language-javascript">Object.prototype.toString.call([]); // &quot;[object Array]&quot;
function isArray(val) {
    return Object.prototype.toString.call(val) == &quot;[object Array]&quot;;
}

</code></pre>
<h2 id="作用域安全的构造函数">作用域安全的构造函数</h2>
<p>构造函数其实就是一个使用<code>new</code>操作符调用的函数，当使用<code>new</code>操作符调用时，构造函数内用到的<code>this</code>对象会指向新创建的对象实例，比如我们有下面的构造函数。</p>
<pre><code class="language-javascript">function Person(name, age) {
    this.name = name;
    this.age = age;
}
</code></pre>
<p>现在的问题在于，要是我们不使用<code>new</code>操作符呢？会发生什么！</p>
<pre><code class="language-javascript">let person = Person('name', 23);
console.info(window.name); // name
console.info(window.age); // 23
</code></pre>
<p>很明显，这里污染了全局作用域，原因就在于没有使用<code>new</code>操作符调用构造函数，此时它就会被当作一个普通的函数被调用，<code>this</code>就被解析成了<code>window</code>对象。我们需要将构造函数修改为先确认this是否是正确类型的实例，如果不是则创建新的实例并返回。</p>
<pre><code class="language-javascript">function Person(name, age) {
    if (this instanceof Person) {
        this.name = name;
        this.age = age;
    } else {
        return new Person(name, age);
    }
}
</code></pre>
<h2 id="高级定时器">高级定时器</h2>
<p>大部分人都知道使用<code>setTimeout()</code>和<code>setInterval()</code>可以方便的创建定时任务，看起来好像 Js 也是多线程的一样，实际上定时器仅仅是计划代码在未来的某个时间执行，但是执行时机是不能保证的。因为在页面的生命周期中，不同时间可能有其它代码控制着 JavaScript 进程。</p>
<p>这里需要注意一下<code>setInterval()</code>函数，仅当没有该定时器的任何其他代码实例时，Js 引起才会将定时器代码添加到队列中。这样可以避免定时器代码可能在代码再次被添加到队列之前还没有完成执行，进而导致定时器代码连续运行好几次的问题。但是这也导致了另外的问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。</p>
<p>假设某个<code>click</code>事件处理程序使用<code>setInterval()</code>设置了一个 200ms 间隔的重复定时器。如果这个事件处理程序花了 300ms 多的时间完成，同时定时器代码也花了差不多了的时间，就会同时出现跳过间隔切连续运行定时器代码的情况。</p>
<p>为了避免<code>setInterval()</code>的重复定时器的这两个缺点，我们可以使用如下模式的链式<code>setTimeout()</code>，代码一看就懂什么意思了。</p>
<pre><code class="language-javascript">setTimeout(function() {
    // 处理中
    setTimeout(arguements.callee, interval);
}, interval)
</code></pre>
<h2 id="消息队列与事件循环">消息队列与事件循环</h2>
<p>如下图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1570979103039.png" alt=""></figure>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。<br>
JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>来看个例子：执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt; 5s）后，再点击两下，整个过程的输出结果是什么？</p>
<pre><code class="language-javascript">setTimeout(function(){
    for(var i = 0; i &lt; 100000000; i++){}
    console.log('timer a');
}, 0)
for(var j = 0; j &lt; 5; j++){
    console.log(j);
}
setTimeout(function(){
    console.log('timer b');
}, 0)
function waitFiveSeconds(){
    var now = (new Date()).getTime();
    while(((new Date()).getTime() - now) &lt; 5000){}
    console.log('finished waiting');
}
document.addEventListener('click', function(){
    console.log('click');
})
console.log('click begin');
waitFiveSeconds();
</code></pre>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达 5s。然后，在 Js 引擎线程执行的时候，<code>'timer a'</code>对应的定时器产生的回调、<code>'timer b'</code>对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于 Js 引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务，最后，5s 后的两次 click 事件被放入消息队列，由于此时 Js 引擎线程空闲，便被立即执行了。因此会产生下面的输出顺序。</p>
<pre><code class="language-text">0
1
2
3
4
click begin
finished waiting
click
click
timer a
timer b
click
click
</code></pre>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://mengxiaoxu.github.io//post/jia-li-de-gou">
                                <h3 class="post-title">
                                    家里的狗
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a href="#array-%E7%B1%BB%E5%9E%8B">Array 类型</a></li>
<li><a href="#function-%E7%B1%BB%E5%9E%8B">Function 类型</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">安全的类型检查</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AE%89%E5%85%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">作用域安全的构造函数</a></li>
<li><a href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8">高级定时器</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">消息队列与事件循环</a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: '70b5a748b63425a6adfc',
            clientSecret: '35ad2482815fc609bacd858a7ff28cfd80a4e465',
            repo: 'mengxiaoxu.github.io',
            owner: 'mengxiaoxu',
            admin: ['mengxiaoxu'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>