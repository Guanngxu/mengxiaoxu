
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>浅析浏览器缓存机制 | 刘小绪同学的博客</title>
<meta name="description" content="正在学习写代码的码农">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1570898526797">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://mengxiaoxu.github.io/">
        <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1570898526797" alt="" width="32px" height="32px">
      </a>
      <a href="https://mengxiaoxu.github.io/">
        <h1 class="site-title">刘小绪同学的博客</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
            <div class="feature-container" style="background-image: url('https://mengxiaoxu.github.io//post-images/qCt13nLLT.jpg')">
            </div>
          
          <h2 class="post-title">浅析浏览器缓存机制</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-04-26</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://mengxiaoxu.github.io//tag/S57Vp3Suu">
                    计算机网络
                    
                      ，
                    
                  </a>
                
                  <a href="https://mengxiaoxu.github.io//tag/Cp4eHBEcz">
                    前端
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。</p>
<h4 id="http-报文">HTTP 报文</h4>
<p>HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。</p>
<h4 id="缓存概述">缓存概述</h4>
<p>浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://mengxiaoxu.github.io//post-images/1569414647062.png" alt=""></figure>
<p>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有<strong>强制缓存</strong>和<strong>协商缓存</strong>两类，也有人把协商缓存叫对比缓存。</p>
<h4 id="强制缓存">强制缓存</h4>
<p>我们先自己想一下，使用缓存是不是会有下面几种情况出现。</p>
<ul>
<li>
<p>存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；</p>
</li>
<li>
<p>存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；</p>
</li>
<li>
<p>不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。</p>
</li>
</ul>
<p>控制强制缓存的字段分别是<code>Expires</code>和<code>Cache-Control</code>，并且<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<h6 id="expires">Expires</h6>
<p><code>Expires</code>是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于<code>Expires</code>值，就直接使用缓存数据。到了 HTTP/1.1，<code>Expires</code>已经被<code>Cache-Control</code>替代了。</p>
<p><code>Expires</code>被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。</p>
<h6 id="cache-control">Cache-Control</h6>
<p><code>Cache-Control</code>是 HTTP/1.1 中最重要的规则，主要取值为：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public</code></td>
<td>所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与<code>private</code>一样。</td>
</tr>
<tr>
<td><code>private</code></td>
<td>所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认值。</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存内容将在 xxx 秒后失效</td>
</tr>
</tbody>
</table>
<p>我们可以看看下面这个例子，可以从截图中看到<code>Expires</code>是一个绝对值，而<code>Cache-Control</code>是一个相对值，此处为<code>max-age=3600</code>，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，<code>Cache-Control</code>相比于<code>Expires</code>是更好的选择，所以同时存在时只有<code>Cache-Control</code>生效。</p>
<figure data-type="image" tabindex="2"><img src="https://mengxiaoxu.github.io//post-images/1569414685538.png" alt=""></figure>
<h4 id="协商缓存">协商缓存</h4>
<p>协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。</p>
<figure data-type="image" tabindex="3"><img src="https://mengxiaoxu.github.io//post-images/1569414775602.png" alt=""></figure>
<p>上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，所以同时存在时只有<code>Etag / If-None-Match</code>生效。</p>
<h6 id="last-modified-if-modified-since">Last-Modified / If-Modified-Since</h6>
<p>你可以往上翻一翻，看一下那张响应报文截图，其中有一个<code>Last-Modified</code>字段，它的值是该资源文件在服务器最后被修改的时间。</p>
<p><code>If-Modified-Since</code>则是客户端再次发起该请求时，携带上次请求返回的<code>Last-Modified</code>值。服务器收到该请求后，发现该请求头有<code>If-Modified-Since</code>字段，则会将<code>If-Modified-Since</code>与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于<code>If-Modified-Since</code>的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<figure data-type="image" tabindex="4"><img src="https://mengxiaoxu.github.io//post-images/1569414811322.png" alt=""></figure>
<h6 id="etag-if-none-match">Etag / If-None-Match</h6>
<p><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。</p>
<p><code>If-None-Match</code>则是客户端再次发起该请求时，携带上次请求返回的唯一标识<code>Etag</code>值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有<code>If-None-Match</code>，则会根据<code>If-None-Match</code>的字段值与该资源在服务器的<code>Etag</code>值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，</p>
<figure data-type="image" tabindex="5"><img src="https://mengxiaoxu.github.io//post-images/1569414845179.png" alt=""></figure>
<h4 id="disk-cache-与-memory-cache">disk cache 与 memory cache</h4>
<p>我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？</p>
<figure data-type="image" tabindex="6"><img src="https://mengxiaoxu.github.io//post-images/1569414871028.png" alt=""></figure>
<p>猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。</p>
<p>内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。</p>
<p>浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。</p>
<h4 id="总结">总结</h4>
<p>到这里偷懒一下子了，找到人家画的一张图，看图就行了。</p>
<figure data-type="image" tabindex="7"><img src="https://mengxiaoxu.github.io//post-images/1569414915648.png" alt=""></figure>
<blockquote>
<p>参考内容：<br>
<a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">彻底理解浏览器的缓存机制</a><br>
<a href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
</blockquote>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://mengxiaoxu.github.io//post/git-jin-jie-ji-chang-yong-ming-ling">
              <h3 class="post-title">
                下一篇：Git 进阶及常用命令
              </h3>
            </a>
          </div>
          
      </div>

      
        
          <div id="gitalk-container"></div>
        

        
      

      <div class="site-footer">
  <div class="slogan">正在学习写代码的码农</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '70b5a748b63425a6adfc',
        clientSecret: '35ad2482815fc609bacd858a7ff28cfd80a4e465',
        repo: 'mengxiaoxu.github.io',
        owner: 'mengxiaoxu',
        admin: ['mengxiaoxu'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
