<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Linux | 刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1582119600627">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1582119600627" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        Linux</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                        Linux 中的零拷贝技术
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-18</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-other_2">
            #Linux
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-success">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/linux-zhong-de-ling-kao-bei-ji-zhu.png">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Two new system calls: splice() and sync_file_range()
Linux 中的零拷贝技术1
Linux 中的零拷贝技术2
Zero Copy I: User-Mode Perspective
Linux man-pages splice()

此前在Nginx 文件操作优化中有提到零拷贝技术，它可以有效的改善数据传输的性能，但是由于存储体系结构非常复杂，而且网络协议栈有时需要对数据进行必要的处理，所以零拷贝技术有可能会产生很多负面影响，甚至会导致零拷贝技术自身的优点完全丧失。
零拷贝就是一种避免 CPU 将一块存储拷贝到另一块存储的技术。它可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率，而且零拷贝技术也减少了内核态与用户态之间切换所带来的开销。进行大量的数据拷贝操作是一件简单的任务，从操作系统的角度来看，如果 CPU 一直被占用着去执行这项简单的任务，是极其浪费资源的。如果是高速网络环境下，很可能就出现这样的场景。
零拷贝技术分类
现在的零拷贝技术种类很多，也并没有一个适合于所有场景的零拷贝零拷贝技术，概括起来总共有下面几种：


直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统只是辅助数据传输，这类零拷贝技术可以让数据在应用程序空间和磁盘之间直接传输，不需要操作系统提供的页缓存支持。关于直接 I/O 可以参看Linux 中直接 I/O 机制的介绍。


避免数据在内核态与用户态之间传输：在一些场景中，应用程序在数据进行传输的过程中不需要对数据进行访问，那么将数据从页缓存拷贝到用户进程的缓冲区是完全没有必要的，Linux 中提供的类似系统调用主要有mmap()、sendfile()和splice()。


对数据在页缓存和用户进程之间的传输进行优化：这类零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统页缓存之间的拷贝操作，此类方法延续了传统的通信方式，但是更加灵活。在 Linux 中主要利用了「写时复制」技术。


前两类方法的目的主要是为了避免在用户态和内核态的缓冲区间拷贝数据，第三类方法则是对数据传输本身进行优化。我们知道硬件和软件之间可以通过 DMA 来解放 CPU，但是在用户空间和内核空间并没有这种工具，所以此类方法主要是改善数据在用户地址空间和操作系统内核地址空间之间传递的效率。
避免在内核与用户空间拷贝
Linux 主要提供了mmap()、sendfile()、splice()三个系统调用来避免数据在内核空间与用户空间进行不必要的拷贝，在Nginx 文件操作优化对sendfile()已经做了比较详细的介绍了，这里就不再赘述了，下面主要介绍mmap()和splice()。
mmap()
当调用mmap()之后，数据会先通过 DMA 拷贝到操作系统的缓冲区，然后应用程序和操作系统共享这个缓冲区，这样用户空间与内核空间就不需要任何数据拷贝了，当大量数据需要传输的时候，这样做就会有一个比较好的效率。
但是这种改进是需要代价的，当对文件进行了内存映射，然后调用write()系统调用，如果此时其它进程截断了这个文件，那么write()系统调用将会被总线错误信号SIGBUG中断，因为此时正在存储的是一个错误的存储访问，这个信号将会导致进程被杀死。
一般可以通过文件租借锁来解决这个问题，我们可以通过内核给文件加读或者写的租借锁，当另外一个进程尝试对用户正在进行传输的文件进行截断时，内核会给用户发一个实时RT_SIGNAL_LEASE信号，这个信号会告诉用户内核破坏了用户加在那个文件上的写或者读租借锁，write()系统调用就会被中断，并且进程会被SIGBUS信号杀死。需要注意的是文件租借锁需要在对文件进行内存映射之前设置。
splice()
和sendfile()类似，splice()也需要两个已经打开的文件描述符，并且其中的一个描述符必须是表示管道设备的描述符，它可以在操作系统地址空间中整块地移动数据，从而减少大多数数据拷贝操作。适用于可以确定数据传输路径的用户应用程序，不需要利用用户地址空间的缓冲区进行显示的数据传输操作。
splice()不局限于sendfile()的功能，也就是说sendfile()是splice()的一个子集，在 Linux 2.6.23 中，sendfile()这种机制的实现已经没有了，但是这个 API 以及相应的功能还存在，只不过内部已经使用了splice()这种机制来实现了。
写时复制
在某些情况下，Linux 操作系统内核中的页缓存可能会被多个应用程序所共享，操作系统有可能会将用户应用程序地址空间缓冲区中的页面映射到操作系统内核地址空间中去。如果某个应用程序想要对这共享的数据调用write()系统调用，那么它就可能破坏内核缓冲区中的共享数据，传统的write()系统调用并没有提供任何显示的加锁操作，Linux 中引入了写时复制这样一种技术用来保护数据。
写时复制的基本思想是如果有多个应用程序需要同时访问同一块数据，那么可以为这些应用程序分配指向这块数据的指针，在每一个应用程序看来，它们都拥有这块数据的一份数据拷贝，当其中一个应用程序需要对自己的这份数据拷贝进行修改的时候，就需要将数据真正地拷贝到该应用程序的地址空间中去，也就是说，该应用程序拥有了一份真正的私有数据拷贝，这样做是为了避免该应用程序对这块数据做的更改被其他应用程序看到。这个过程对于应用程序来说是透明的，如果应用程序永远不会对所访问的这块数据进行任何更改，那么就永远不需要将数据拷贝到应用程序自己的地址空间中去。这也是写时复制的最主要的优点。
写时复制的实现需要 MMU 的支持，MMU 需要知晓进程地址空间中哪些特殊的页面是只读的，当需要往这些页面中写数据的时候，MMU 就会发出一个异常给操作系统内核，操作系统内核就会分配新的物理存储空间，即将被写入数据的页面需要与新的物理存储位置相对应。它最大好处就是可以节约内存，不过对于操作系统内核来说，写时复制增加了其处理过程的复杂性。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/linux-zhong-de-ling-kao-bei-ji-zhu">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                        Vim 常用命令快速查询
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-01</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/vim" class="post-tag i-tag
                            i-tag-info">
            #Vim
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-other_2">
            #Linux
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/vim-chang-yong-ming-ling-kuai-su-cha-xun.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容
Learning Vim The Pragmatic Way
《鸟哥的 Linux 私房菜》

Vim 可以认为是 Vi 的高级版本，Vim 可以用颜色或下划线的方式来显示一些特殊信息，您可以认为 Vi 是一个文本处理工具，而 Vim 是一个程序开发工具，现在大部分 Linux 的发行版都以 Vim 替换 Vi 了。在 Linux 命令行模式下有很多编辑器，但是 Vi 文本编辑器是所有 Unix-like 系统都会内置的，因此学会 Vi/Vim 的使用时非常有必要的，对于 Vi 的三种模式（命令模式、编辑模式、命令行模式）这里就不在做说明了，下面是一些比较常用的命令。
一般命令模式下



命令
说明




h、j、k、l
与键盘的方向键一一对应，分别为左、下、上、右，在键盘上着几个字母是排在一起的


Ctrl+f、Ctrl+b
分别对应键盘的「Page Down」、「Page Up」，我更习惯于这两个键，而不是前面的组合键


0、$
分别对应键盘的「Home」、「End」，即移动到该行的最前面/后面字符处


n&amp;lt;Enter&amp;gt;
n 为数字，光标向下移动 n 行


/word、?word
向光标之上/下寻找一个字符串名称为 word 的字符串


n、N
如果我们刚刚执行了上面上面的 /word 或 ?word 查找操作，那么 n 则表示重复前一个查找操作，可以简单理解为向下继续查找下一个名称为 word 的字符串，N 则与 n 刚好相反


:n1,n2s/word1/word2/g
在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将这个字符串替换为 word2，如果前面的 n1,n2 使用 1,$ 代替则表示从第一行到最后一行，最后的 g 后面可以加个 c，即 :1,$s/word1/word2/gc，这样就会在替换钱显示提示字符给用户确认（confirm）


x、X
分别对应键盘的「Del」、「Backspace」键


dd、yy
删除/复制光标所在的那一整行


p、P
p 将已复制的数据在光标下一行粘贴，P 粘贴在光标上一行


u
恢复前一个操作，类似于 Windows 下的 Ctrl+Z


Ctrl+r
重做上一个操作


.
小数点，重复上一个操作



命令行模式下



命令
说明




:w
将编辑的数据写入硬盘中


:w!
若文件属性为只读，强制写入该文件，不过到底能不能写入，还是跟文件权限有关系


:q、:q!
与 w 一样，q 为关闭的意思


:r [filename]
在编辑的数据中读入另一个文件的数据，即将[filename]这个文件的内容追加到光标所在行的后面


:w [filename]
将编辑的数据保存为另一个文件


:set nu/nonu
显示/不显示行号



编辑模式下



组合键
作用




[ctrl]+x -&amp;gt; [ctrl]+n
通过目前正在编辑的这个文件的内容文字作为关键字，予以自动补全


[ctrl]+x -&amp;gt; [ctrl]+f
以当前目录内的文件名作为关键字补全


[ctrl]+x -&amp;gt; [ctrl]+o
以扩展名作为语法补充，以 Vim 内置的关键字予以补全



当我们在使用 Vim 编辑器的时候，Vim 会在与被编辑的文件目录下再建立一个名为.filename.swp的文件，我们对文件的操作都会记录到这个 swp 文件中去，如果系统因为某些原因掉线了，就可以利用这个 swp 文件来恢复内容。如果存在对应的 swp 文件，那么 Vim 就会主动判断当前这个文件可能有问题，会给出相应的提示。
我们也可以给 Vim 环境设置一些个性化的参数，虽然在命令行模式下可以使用:set来设置，但是这样每次设置实在是太麻烦，因此我们可以设置一些全局的参数。Vim 的整体设置值一般放在/etc/vimrc中，我们一般通过修改~/.vimrc这个文件（默认不存在）来设置一些自己的参数，比如：
&amp;quot; 该文件的双引号是注释
set nu &amp;quot;在每一行的最前面显示行号
set autoindent &amp;quot; 自动缩进
set ruler &amp;quot; 可显示最后一行的状态
set bg=dark &amp;quot; 显示不同的底色色调
syntax on &amp;quot;进行语法检验，颜色显示，比如 C 语言等

最后附上一张命令速查卡，此图来源于Learning Vim The Pragmatic Way，PDF 版下载链接在这里。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/vim-chang-yong-ming-ling-kuai-su-cha-xun">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">
                        Nginx 文件操作优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-19</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/nginx" class="post-tag i-tag
                            i-tag-info">
            #Nginx
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/linux" class="post-tag i-tag
                            i-tag-info">
            #Linux
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw" class="post-tag i-tag
                            i-tag-primary">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/nginx-wen-jian-cao-zuo-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Nginx AIO 机制与 sendfile 机制
sendfile 适用场景
扯淡 Nginx 的 sendfile 零拷贝的概念
浅析 Linux 中的零拷贝技术
Linux man-pages sendfile

今天在看 Nginx 配置的时候，看到了一个sendfile配置项，它可以配置在http、server、location三个块中，出于好奇就去查了一下sendfile的作用。
文件下载是服务器的基本功能，其基本流程就是循环的从磁盘读取文件内容到缓冲区，再将缓冲区内容发送到socket文件，程序员基本都会写出类似下面看起来比较高效的程序。
while((n = read(diskfd, buf, BUF_SIZE)) &amp;gt; 0)
    write(sockfd, buf , n);

上面程序中我们使用了read和write两个系统调用，看起来也已经没有什么优化空间了。这里的read和write屏蔽了系统内部的操作，我们并不知道操作系统做了什么，现实情况却是由于 Linux 的 I/O 操作默认是缓冲 I/O，上面的程序发生了多次不必要的数据拷贝与上下文切换。
上述两行代码执行流程大致可以描述如下：

系统调用read产生一个上下文切换，从用户态切换到内核态；
DMA 执行拷贝（现在都是 DMA 了吧！），把文件数据拷贝到内核缓冲区；
文件数据从内核缓冲区拷贝到用户缓冲区；
read调用返回，从内核态切换为用户态；
系统调用write产生一个上下文切换，从用户态切换到内核态；
把步骤 3 读到的数据从用户缓冲区拷贝到 Socket 缓冲区；
系统调用write返回，从内核态切换到用户态；
DMA 从 Socket 缓冲区把数据拷贝到协议栈。


可以看到两行程序共发生了 4 次拷贝和 4 次上下文切换，其中 DMA 进行的数据拷贝不需要 CPU 访问数据，所以整个过程需要 CPU 访问两次数据。很明显中间有些拷贝和上下文切换是不需要的，sendfile就是来解决这个问题的，它是从 2.1 版本内核开始引入的，这里放个 2.6 版本的源码。
系统调用sendfile是将in_fd的内容发送到out_fd，描述符out_fd在 Linux 2.6.33 之前，必须指向套接字文件，自 2.6.33 开始，out_fd可以是任何文件；in_fd只能是支持mmap的文件（mmap是一种内存映射方法，在被调用进程的虚拟地址空间中创建一个新的指定文件的映射）。
所以当 Nginx 是一个静态服务器时，开启sendfile配置项是可以大大提高 Nginx 性能的，但是当把 Nginx 作为一个反向代理服务器时，sendfile则没有什么用，因为当 Nginx 时反向代理服务器时，in_fd就是一个套接字，这不符合sendfile的参数要求。

可以看到现在我们只需要一次拷贝就可以完成功能了，但是能否把这一次拷贝也省略掉呢？我们可以借助硬件来实现，仅仅需要把缓冲区描述符和文件长度传过去，这样 DMA 直接将缓冲区的数据打包发送到网络中就可以了。
这样就实现了零拷贝技术，需要注意的是这里所说的零拷贝是相对操作系统而言的，即在内核空间不存在冗余数据。数据的实际走向是从硬盘到内存，再从内存到设备。
Nginx 中还有一个aio配置，它的作用是启用内核级别的异步 I/O 功能，要使aio生效需要将directio开启（directio对大文件的读取速度有优化作用），aio很适合大文件的传送。需要注意的是sendfile和aio是互斥的，不可同时兼得二者，因此我们可以设置一个文件大小限制，超过该阀值使用aio，低于该阀值使用sendfile。
location /video/ {
    sendfile on;
    sendfile_max_chunk 256k; 
    aio threads;
    directio 512k;
    output_buffers 1 128k;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/nginx-wen-jian-cao-zuo-you-hua">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1582119600627)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/liu-xiao-xu-tong-xue-sui-bi-2020-02-18">刘小绪同学随笔（2020-02-18）</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi">MySQL 架构与历史</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/qian-xi-zheng-ze-biao-da-shi-yuan-li">浅析正则表达式原理</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji">小工具收集</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/vue-typescript-xiang-mu-qi-shou-shi">Vue + TypeScript 项目起手式</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>