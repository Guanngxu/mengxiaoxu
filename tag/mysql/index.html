<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    MySQL | 刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1599920203510">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1599920203510" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        MySQL</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">
                        查询性能优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-info">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-other_4">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/cha-xun-xing-neng-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

在 Schema 与数据类型优化、MySQL 中的索引和高性能索引策略中已经介绍了如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说还是必不可少的，但这些依旧还不够，如果查询写的糟糕，那么再好的库表结构、索引再合适，也无法实现高性能。
本文将从查询设计的一些基本原则开始介绍一些查询优化技巧，尽可能的去发挥 MySQL 真正的优势，并且避开它的弱点。
为什么查询速度会慢
如果把一次查询看做一个任务，那么它则是由一系列更小的子任务构成，每个子任务都会消耗一定的时间，速度慢无非是其中一些子任务拖累了整个任务的进度，或者是执行了一些不必要的子任务。
MySQL 在执行查询时有哪些子任务？哪些子任务运行的时间很慢？这里很难给出完整的列表。完成这些子任务的时候，查询需要在不同的地方花费时间，比如网络、CPU 计算、生成执行计划、锁（互斥）等待等等操作。而这些操作又需要调用多少又会需要内存、CPU 操作、内存不足时导致的 I/O 操作、上下文切换和系统调用等等。
上面只列了一个查询生命周期的部分，我们要做的就是了解查询的生命周期，清楚查询的时间消耗情况，知道了这些才能帮助我们大大优化查询速度。
优化数据访问
查询性能低下最基本的原因是访问的数据太多，除了一些不可避免的需要筛选大量数据的查询外，大部分性能低下的查询都可以通过减少访问的数据量进行优化。一般可以考虑下面两个因素：

应用程序是否存在检索大量的超过需要的数据？一般意味着访问了太多的行或者太多的列；
MySQL 服务器层是否存在分析大量超过需要的数据行。

有一些查询会请求超过实际需要的数据，然后这些多余的数据又会被应用程序丢弃，这样会给 MySQL 服务器带来额外的负担，同时增加网络、内存、CPU 的开销。典型案例比如：查询不需要的记录；多表关联时返回全部的列；总是取出全部列；重复查询相同的数据。
我们以SELECT * FROM film_actor WHERE film_id = 1这个查询来简要说明「MySQL 为了返回结果是否需要扫描额外的记录」。在有film_id列有索引的时候，通过EXPLAIN会看到使用的访问类型是ref，并且只需要扫描 10 行数据。而如果将索引去掉，则访问类型变成了ALL，需要扫描全表数据。
如果发现需要扫描大量数据但只返回少数的行，我们一般可以通过三个技巧来优化。第一是使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表取对应行就可以返回结果了；第二是改变库表结构，比如使用单独的汇总表，这一点在 Schema 与数据类型优化中相关介绍；第三是重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询。
重构查询的方式
上文已经提到了通过重写查询来提高性能，那么我们可以用哪些技巧来重构查询呢？这里我们需要明白的是，查询的目标找到一个更优的方法获得实际需要的结果，而不一定总是需要从 MySQL 中获得一模一样的结果集。
在设计查询的时候需要考虑的一个重要问题是：是否需要将一个复杂的查询分成多个简单的查询。因为网络通信、查询解析和优化是代价高昂的事情，所以在传统实现中总是强调让数据库完成尽可能多的工作。但是这个法则不适用于 MySQL，因为 MySQL 从设计上就让连接和断开连接很轻量级，而且现在的网络基础设施也更完善，带宽、时延等等都已经变得不再那么重要。
有时候将一个大的查询分解为多个小查询是很有必要的，当然如果一个查询能够胜任时写成多个独立的查询还是不明智的，是否需要拆分需要自己衡量各方面的因素。下面举一个切分查询的例子。
在一些应用中需要定期的删除旧数据，如果一次使用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、沾满整个事务日志、耗尽系统资源、阻塞许多很小但重要的查询。比如DELETE FROM messages WHERE created &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)，这个查询会消耗很多的资源，而如果我们将它拆分为很多个小的查询，这样就能将服务器上原本一次性的压力分散到一个很长的时间段中，这样就可以大大降低对服务器的影响，也可以大大减少删除时锁的持有时间。如下所示：
rows_affected = 0
do {
rows_affected = do_query(
    &amp;quot;DELETE FROM messages WHERE created &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&amp;quot;)
} while rows_affected &amp;gt; 0

当然我们还可以通过分解关联查询的方法来重构查询，比如下文代码块中的例子乍一看好像没什么好处，实际上它的优势可不少。

让缓存的效率更高。因为许多应用程序可以方便的缓存单表查询对应的结果对象；
将查询分解后，执行单个查询可以减少锁的竞争；
在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展；
可以减少冗余记录的查询。在应用程序做关联意味着对应某条记录应用只需要查询一次，而在数据库访问则可能需要重复访问；
查询本身效率也可能会提升。比如例子中使用 IN() 代替关联查询，可以让 MySQL 按照 ID 顺序进行查询；
更进一步，这样做相当于在应用中实现了哈希关联，而不是 MySQL 的嵌套循环关联。

SELECT * FROM tag 
    JOIN tag_post ON tag_post.tag_id = tag.id
    JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = &#39;mysql&#39;


# 可以将上面的查询分解为下面的小查询

SELECT * FROM tag WHERE tag = &#39;mysql&#39;;
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE id in (123, 456, 567, 9098, 8904)


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">
                        高性能索引策略
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-error">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/gao-xing-neng-suo-yin-ce-lue.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

在 MySQL 中的索引中已经介绍了常见的两种索引类型和索引的优缺点。高效的选择和使用索引有很多种方式，下面介绍几种常见的方法。
独立的列
如果查询中的列不是独立的，则 MySQL 就不会使用索引，这里「独立的列」是指索引列不能是表达式的一部分，也不能是函数的参数。比如SELECT actor_id FROM actor WHERE actor_id + 1 = 5，凭肉眼都能看出来 WHERE 中的表达式其实等价于actor_id = 4，但是 MySQL 却无法自动解析这个表达式。因此我们应该养成简化 WHERE 条件的习惯，始终将索引列单独放在比较符号的一侧。
多列索引
一些所谓的专家建议把 WHERE 条件里面的列都建上索引，实际上这个建议是非常错误的，因为这样一来最好的情况下也只能是「一星」索引，其性能比起真正的最优的索引可能差几个数量级。

索引将相关的记录放到一起则获得「一星」；如果索引中的数据顺序和查找中的排列顺序一致则获得「二星」；如果索引中的列包含了查询中需要的全部列则获得「三星」。

MySQL5.0 之前只能使用某一个单列索引，在这种情况下没有哪一个独立的单列索引是有效的。比如表film_actor在字段film_id和actor_id上各有一个单列索引，但是对于下面这个查询的 WHERE 条件单列索引却不会生效，MySQL 对这个查询会使用全表扫描。因此在 5.0 之后的版本引进了「索引合并」的策略。
SELECT film_id, actor_id FROM film_actor WHERE actor_id = 1 OR film_id = 1

索引合并算法由三个变种：OR 条件的联合；AND 条件的相交；组合前两种情况的联合及相交，它的作用是同事使用单列索引进行扫描，并将结果进行合并。需要注意的是 MySQL 会使用这类技术优化复杂查询，更多的时候是说明了表上的索引建的很糟糕。比如当服务器对多个索引做相交操作时（通常有多个 AND 条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个单列索引。
选择合适的索引列顺序
索引列的顺序是容易引起困惑的问题，这一点可以参考 MySQL 中的索引中关于 B-Tree 的介绍，列顺序也决定了一个索引是否能够成为一个真正的三星索引。需要注意的是，本小节内容适用于 B-Tree 索引。
选择索引列的顺序有一个经验法则：将选择性最高的列放到索引最前列。但是这个法则在一些情况下没有避免随机 I/O 那么重要，这里想要说明的是这个法则不是放之四海皆准。
聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，「聚簇」表示数据行和相邻的键值紧凑地存储在一起。当然因为无法把数据行放在两个不同的地方，所以一个表只能有一个聚簇索引。因为是存储引擎负责实现索引，因此并不是所有的存储引擎都支持聚簇索引，而且它的具体细节也和实现方式有关。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">
                        MySQL 中的索引
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-08</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-banana">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-other_4">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mysql-zhong-de-suo-yin.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版）》

一说到「索引」这个词，不知道数据库的人可能首先联想到的就是一本书的索引，它的作用是方便读者快速查找书中的内容。数据库的索引也是这样的效果，是存储引擎用于快速找到记录的一种数据结构。
很明显索引会直接影响到查询的速度，从书籍中的索引可以联想到一些可能会存在的问题。不同的索引编排方式会有不同的查询速度，这对应于数据库使用不同数据结构来建立的索引；试想一下一本书的索引部分比内容部分还要厚，那索引就会起到反向的作用。
索引类型
就像上面提到的一样，索引有很多种不同的类型，不同的索引类型可以针对不同的场景提供更好的性能。需要注意的是 MySQL 的索引不是在服务层实现的，而是在存储引擎实现的，所以并没有统一的索引标准，甚至有的存储引擎都不支持索引，下面介绍两个常用的索引。
B-Tree 索引
我们常说的索引就是 B-Tree 索引，要注意的是我们使用「B-Tree」这个术语是因为 MySQL 在CREATE TABLE和其它语句中使用的也使用该关键字，而且其底层结构使用的并不一定是 B-树。
以前整理过关于「B-树」和「B+树」的资料，详细的资料可以查看以前写的从二叉树到 B+ 树索引。
值得注意的是 B-Tree 对索引列是顺序组织存储的，很适合查找范围数据，例如下面数据表的索引会按照图示的方式去存储。
CREATE TABLE people (
	last_name varchar(50) not null,
	first_name varchar(50) not null,
	dob date not null,
	gender enum(‘m’, ‘f’) not null,
	key(last_name, first_name, dob)
);


因此这样的索引也就会有它自己的限制。1、如果不是按照索引的最左侧列开始查找，则无法使用索引；2、不能跳过索引中的列，也就是说上述索引无法用于查找 last_name 为 Smith 并且生日在某个特定日期的人；3、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。例如WHERE last_name=‘Smith’ AND first_name LIKE ‘%J’ AND dob = ‘1976-12-23’，这个查询就只能使用索引的前两列，因为这里的 LIKE 是一个范围条件。
哈希索引
如果你的数据结构没有忘的话，那么我想「哈希索引」对你来说应该是见名知意的，它只有精确匹配索引所有列的查询才有效。对每一行数据存储引擎都会对所有的索引列计算出一个哈希码。
既然是基于哈希表实现，那么就不可避免需要考虑哈希冲突的情况。一般避免哈希冲突的方式都是将槽变成一个链表，只要哈希函数选的好，能够让数据均匀的分到各个桶里面就不会出现很要命的性能问题。
因为哈希索引需要计算哈希值，所以不宜选择 MD5、SHA1 等较复杂的哈希函数；当然哈希值也不宜过长或者过短，过长索引值会占用较大的存储空间，过短太容易造成哈希冲突。哈希索引的存储非常的紧凑，所以查询速度会很快，但它也有自己的局限性：
1、哈希索引只包含哈希索值和行指针，而不存储字段值，所以不能使用哈希索引中的值来避免读取行；2、哈希索引数据并不是按照索引值顺序存储的，所以也不能用于排序；3、哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值；4、哈希索引只支持等值比较查询，不支持任何范围查询；5、如果哈希冲突很多的话，一些索引维护操作的代价会很高。
以SELECT id FROM url WHERE url_crc=CRC32(&amp;quot;http://www.mysql.com&amp;quot;)为例，一旦出现了哈希冲突，即另一个字符串的哈希值和http://www.mysql.com是一样的，那么这个语句就无法正常的工作，需要在 WHERE 子句中包含常量值才能正常工作，比如加入AND url=&amp;quot;http://www.mysql.com&amp;quot;。
索引的优点
「索引」这个主题深入讲完完全全值得写一本书了，要深入理解这部分知识可以查阅相关资料。需要注意的是，即便我们使用了对象关系映射（ORM）工具，仍然需要关心索引，即便是查询优化技术专家也很难兼顾到各种情况，更别说各种 ORM 了。总结下来索引有如下三个优点：

索引大大减少了服务器需要扫描的数据量；
索引可以帮助服务器避免排序和临时表；
索引可以将随机 I/O 变为顺序 I/O。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">
                        Schema 与数据类型优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-23</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-banana">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-other_1">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/schema-yu-shu-ju-lei-xing-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

选择优化的数据类型
世面上常见的数据库大多支持了多种多样的数据类型，选择正确的数据类型对于获得高性能至关重要，一般都需要遵循如下的几个原则：
1、更小的通常更好：更小的通常更快，因为占用着更少的磁盘、内存和 CPU，并且处理时需要的 CPU 周期也更少；
2、简单就好：简单数据类型的操作通常需要更少的 CPU 周期；
3、尽量避免 NULL：如果查询中包含可为 NULL 的列，就会使得索引、索引统计和值比较变得复杂，因此在设计表是最好指定列为 NOT NULL。

整数类型
在 MYSQL 中可以为整数类型指定宽度，例如INT(11)，但是这对大多数应用是没有意义的，它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具（如 MySQL 命令行客户端）用来显示字符的个数。对于存储和计算来说INT(1)和INT(20)是相同的。
字符串类型
需要注意的是当 MySQL 存储 CHAR 值时，它会删掉所有的末尾空格，因为 CHAR 值会根据需要采用空格进行填充以方便比较，这导致的问题就是你使用 CHAR 存储的&#39;string &#39;会变成&#39;string&#39;。CHAR 的好处在于它是定长的，很适合存储像 MD5 值一样的定长值，定长值的 CHAR 类型不易产生碎片，而且对于非常短的列 CHAR 也会比 VERCHAR 好，比如CHAR(1)只需要一个字节，而VERCHAR(1)则需要两个字节，因为它还需要一个字节来存长度。
VERCHAR 类型在存储可变长字符串时，会比 CHAR 更节省空间，它需要使用 1 或者 2 个额外的字节记录字符串的长度。但由于行是变长的，当一个行占用的空间增长，并且在页内没有更多的可用空间可以存储，就容易产生碎片。
使用枚举代替字符串
有时候可以使用枚举列代替常用的字符串类型，枚举列可以把一些不重复的字符串存储成一个预定义的集合，而且 MySQL 在存储枚举时非常紧凑，会根据列的数量压缩到一个或两个字节。比如下面的例子：
CREATE TABLE enum_test(
    e ENUM(&#39;fish&#39;, &#39;apple&#39;, &#39;dog&#39;) NOT NULL
);

INSERT INTO enum_test(e) VALUES(&#39;fish&#39;), (&#39;dog&#39;), (&#39;apple&#39;);

SELECT e+0 FROM enum_test;

# result
+-----+
| e+0 |
+-----+
|   1 |
|   2 |
|   3 |
+-----+

可以看到使用枚举类型后，上面三行数据实际上存储为了整数，而不是字符串，而且还有一个让人吃惊的地方：枚举字段是按照内部存储的整数而不是定义的字符串进行排序的，这一点需要特别注意，不然在写程序时容易中犯错。当然你也可以在查询时使用FIELD()函数显式地指定排序顺序。
可以看到上面
范式和反范式
关系型数据库有设计范式的概念，这一点在大学的数据库课程中肯定都会提及。因为有比较高的范式，那么就只有很少或者没有重复的数据，因此在 UPDATE 时只需要修改更少的数据；高范式的表通常也更小，因此占用的内存也会更小，操作起来也会更快......
但是高范式也带来了另一个缺点，比较好的范式通常意味着需要关联，稍微复杂一点的查询就需要使用 JOIN，关联的代价是昂贵的，甚至让一些索引策略失效；而如果不需要关联，即使某个查询需要全表扫描，当数据比内存大时可能会比关联查询快的多。所以一般都会根据实际情况将范式与反范式混用，完全的范式化和完全的反范式化都是实验室才有的东西。
缓存表和汇总表
这里的「缓存表」和「汇总表」并没有什么标准的含义。我们用「缓存表」来存储那些可以从其他表获取，但是获取的速度很慢的数据；而「汇总表」则用来保存那些使用 GROUP BY 语句聚合数据的表。毫无疑问，我们存这些冗余数据也是为了性能。
比如近两年各种应用流行的年终报告，每次网易云音乐的年终报告都会把朋友圈撑满，其它类似于缓存一个用户的朋友数、一个文件的下载次数等等。这些数据实时计算的开销是很大的，而且多数情况下用户也等不起实时计算的时间，一般的解决方案都是通过增加计数器表（缓存表）来解决这个问题。
计算机科学中总是伴随着双面性，上面的计数器表带来性能提升的同时也带来了并发问题。网站的每一次点击都会导致对计数器的更新，对于任何想要更新这一行的事务来说，这条记录都有一个全局的互斥锁，这会使得这些事务只能串行的进行。每一次点击都会触发下面的语句，但大量的点击伴随着该行数据的互斥锁，想想性能也不会提升到哪里去吧。
UPDATE hit_counter SET cnt = cnt + 1;

大多数应用都是读查询居多，为了提升读查询的速度，经常会需要增加一些额外的索引，增加冗余列、汇总表、缓存表等等。但是不要忘了这些技巧也会增加写查询的负担，还会增加开发难度，因此应该根据实际应用场景来做权衡。
加快 ALTER TABLE 表的速度
MySQL 执行大部分修改表结构的方法都是用新的结构创建一个空表，然后从旧表中查出所有数据插入到新表，然后删除旧表。在内存不足、表很大、索引多的情况下会花费很长的时间。一个很严重的缺点是大部分 ALTER TABLE 操作将导致 MySQL 服务中断。
对于常见的场景我们有两种技巧避免服务中断。一种是先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换；另一种技巧是「影子拷贝」，即用要求的表结构创建一张和源表无关的新表，然后通过重命名和删除表的操作交换两张表。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">
                        MySQL 架构与历史
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-16</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-info">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-info">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mysql-jia-gou-yu-li-shi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》
码农翻身知识星球
数据库村的旺财和小强

存储引擎
 Writing a Custom Storage Engine / Overview 中说存储引擎负责管理 MySQL 的数据存储和索引，MySQL 服务器通过已经定义好的 API 与存储引擎进行通信。
不同的存储引擎都有各自的优势和劣势，存储引擎相互之间不会通信，除了 InnoDB 外其它引擎都不会解析 SQL，API 屏蔽了存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎 API 包含了几十个底层函数，下面列举了其中的一小部分函数，如果你要自己实现一个存储引擎，那所做的工作就是把这些接口函数实现。
//创建一个表
virtual int create(const char *name, TABLE *form, HA_CREATE_INFO *info)=0;

//打开一个表
int open(const char *name, int mode, int test_if_locked);

//写入一行数据
int write_row(byte *buf);

//更新一行
int update_row(const byte *old_data, byte *new_data);

//删除一行
int delete_row(const byte *buf);

//开始一个事务
int  start_stmt(THD *thd, thr_lock_type lock_type);

//提交一个事务
int (*commit)(THD *thd, bool all);

//回滚一个事务
int (*rollback)(THD *thd, bool all);

// ......

MySQL 内建了很多存储引擎，除此之外还有很多社区版的第三方引擎，对于这么多引擎我们应该怎么选择呢？这里可以归结为一句话「除非需要用到某些 InnoDB 不具备的特性，并且没有其它办法可以代替，否则都应该选择 InnoDB 引擎」。例如，如果要用到全文索引，建议优先考虑 InnoDB 加上 Sphinx 组合，而不是使用支持全文索引的 MyISAM。当然，如果不需要用到 InnoDB 的特性，同时其它引擎的特性能够更好的满足需求，也可以考虑一下其它引擎。
除非万不得已，否则不要混合使用多种存储引擎。如果应用需要不同的存储引擎，你至少应该考虑「事务」、「备份」、「崩溃恢复」、「特有的特性」几个因素。
并发控制
数据库需要大量的磁盘读写操作，自然而然就会产生并发控制的问题。我们可以简单的使用读写锁来解决解决并发控制问题。读锁是共享的，多个客户可以在同一时刻读取同一个资源；写锁是排他的，一个写锁会阻塞其它写锁和读锁，只有这样才能在同一时间内只有一个用户能执行写入，并防止其它用户读取正在写入的同一资源。
上一段内容只说了锁，但是没有讨论锁的粒度，锁定资源时是直接锁定整个数据库还是仅锁定具体的表，亦或是只锁定要操作的那几行记录？首先我们需要明白的是任何时候，在给定的资源上，锁定的数据量越少则系统的并发程度越高，只要相互之间不冲突即可。
但是我们还忘了另一件事，加锁本身也是需要消耗资源的，获得锁、检查锁的解除、释放锁等等都会增加系统的开销，如果系统花费大量的时间来管理锁，而不是管理数据，那么系统的并发程度同样会受到影响。因此锁策略就是在锁的开销和数据的安全性之间寻求平衡。
大多数商业数据库在锁策略上并没有提供更多的选择，一般都是在表上施加行级锁。MySQL 则提供了多种选择，每种 MySQL 引擎都可以实现自己的锁策略和锁粒度，比较重要的两种锁策略是「表锁」和「行级锁」。
多版本并发控制
刘大在数据库村的旺财和小强中把「事务的隔离级别」和「多版本并发控制（MVCC）」讲的已经比较透彻了，此处我仅借助文字描述来加深我自己的理解。
MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因为避免了加锁的这些开销，所以 MVCC 能够提升并发性能。包括 Oracle、PostgreSQL、MySQL 等等数据库都实现了 MVCC，只是各自的实现机制不一样，因为 MVCC 没有一个统一的实现标准，比较典型的实现方式有「乐观并发控制」和「悲观并发控制」。
MVCC 是通过保存数据在某个时间点的快照来实现的（这难道不是一个版本控制器吗）。以 InnoDB 为例，它是通过在每行记录后面保存两个隐藏的列来实现，一个保存了行的创建时间，另一个则保存了行的过期（删除）时间。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录记录的版本号做比较。
因此根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。因为同一条记录在存储器中拥有多个版本，每个事务也有自己的版本号，只要把事务和记录的版本号做对比即可知道需要取哪个版本的记录了。一言以蔽之，MVCC 是一个借助空间来换取时间的策略。
小知识点
MySQL 使用文件系统的目录和文件来保存数据库和表的定义，所以大小写敏感就和具体的平台密切相关，在 Windows 中大小写不敏感，而在 Linux 等类 Unix 中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但是表的定义则是在 MySQL 服务层统一处理的，my_table表的定义保存会被保存在my_table.frm中。
如果表在创建并导入数据后，不会再对该表进行修改操作，那么这样的表比较适合 MyISAM 压缩表，而且压缩表也支持索引。可以使用myisampack对 MyISAM 表进行压缩，压缩后的表是不能进行修改的，但是可以极大的减少磁盘的空间占用，因此也可以减少磁盘 I/O，这无疑是一种提升查询性能的方法。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1599920203510)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/dian-shang-ling-yu-tao-li-an-li/">拼多多（淘宝）空手套利案例分享</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">查询性能优化</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">高性能索引策略</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">MySQL 中的索引</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">Schema 与数据类型优化</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>