<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    数据库 | 刘小绪同学的博客
</title>
<link rel="shortcut icon" href="https://mengxiaoxu.github.io//favicon.ico?v=1597851616006">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://lexrus.com/fontdiao/fontdiao/css/fontdiao.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mengxiaoxu.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mengxiaoxu.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148716803-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-148716803-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mengxiaoxu.github.io/">
                <img class="avatar" src="https://mengxiaoxu.github.io//images/avatar.png?v=1597851616006" alt="">
            </a>
            <div class="site-title">
                <h1>
                    刘小绪同学的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io//post/gao-zhi-liang-zhong-wen-du-li-bo-ke/" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://mengxiaoxu.github.io/post/xiao-gong-ju-shou-ji" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        数据库</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">
                        查询性能优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-info">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-success">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/cha-xun-xing-neng-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

在 Schema 与数据类型优化、MySQL 中的索引和高性能索引策略中已经介绍了如何设计最优的库表结构、如何建立最好的索引，这些对于高性能来说还是必不可少的，但这些依旧还不够，如果查询写的糟糕，那么再好的库表结构、索引再合适，也无法实现高性能。
本文将从查询设计的一些基本原则开始介绍一些查询优化技巧，尽可能的去发挥 MySQL 真正的优势，并且避开它的弱点。
为什么查询速度会慢
如果把一次查询看做一个任务，那么它则是由一系列更小的子任务构成，每个子任务都会消耗一定的时间，速度慢无非是其中一些子任务拖累了整个任务的进度，或者是执行了一些不必要的子任务。
MySQL 在执行查询时有哪些子任务？哪些子任务运行的时间很慢？这里很难给出完整的列表。完成这些子任务的时候，查询需要在不同的地方花费时间，比如网络、CPU 计算、生成执行计划、锁（互斥）等待等等操作。而这些操作又需要调用多少又会需要内存、CPU 操作、内存不足时导致的 I/O 操作、上下文切换和系统调用等等。
上面只列了一个查询生命周期的部分，我们要做的就是了解查询的生命周期，清楚查询的时间消耗情况，知道了这些才能帮助我们大大优化查询速度。
优化数据访问
查询性能低下最基本的原因是访问的数据太多，除了一些不可避免的需要筛选大量数据的查询外，大部分性能低下的查询都可以通过减少访问的数据量进行优化。一般可以考虑下面两个因素：

应用程序是否存在检索大量的超过需要的数据？一般意味着访问了太多的行或者太多的列；
MySQL 服务器层是否存在分析大量超过需要的数据行。

有一些查询会请求超过实际需要的数据，然后这些多余的数据又会被应用程序丢弃，这样会给 MySQL 服务器带来额外的负担，同时增加网络、内存、CPU 的开销。典型案例比如：查询不需要的记录；多表关联时返回全部的列；总是取出全部列；重复查询相同的数据。
我们以SELECT * FROM film_actor WHERE film_id = 1这个查询来简要说明「MySQL 为了返回结果是否需要扫描额外的记录」。在有film_id列有索引的时候，通过EXPLAIN会看到使用的访问类型是ref，并且只需要扫描 10 行数据。而如果将索引去掉，则访问类型变成了ALL，需要扫描全表数据。
如果发现需要扫描大量数据但只返回少数的行，我们一般可以通过三个技巧来优化。第一是使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表取对应行就可以返回结果了；第二是改变库表结构，比如使用单独的汇总表，这一点在 Schema 与数据类型优化中相关介绍；第三是重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询。
重构查询的方式
上文已经提到了通过重写查询来提高性能，那么我们可以用哪些技巧来重构查询呢？这里我们需要明白的是，查询的目标找到一个更优的方法获得实际需要的结果，而不一定总是需要从 MySQL 中获得一模一样的结果集。
在设计查询的时候需要考虑的一个重要问题是：是否需要将一个复杂的查询分成多个简单的查询。因为网络通信、查询解析和优化是代价高昂的事情，所以在传统实现中总是强调让数据库完成尽可能多的工作。但是这个法则不适用于 MySQL，因为 MySQL 从设计上就让连接和断开连接很轻量级，而且现在的网络基础设施也更完善，带宽、时延等等都已经变得不再那么重要。
有时候将一个大的查询分解为多个小查询是很有必要的，当然如果一个查询能够胜任时写成多个独立的查询还是不明智的，是否需要拆分需要自己衡量各方面的因素。下面举一个切分查询的例子。
在一些应用中需要定期的删除旧数据，如果一次使用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、沾满整个事务日志、耗尽系统资源、阻塞许多很小但重要的查询。比如DELETE FROM messages WHERE created &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH)，这个查询会消耗很多的资源，而如果我们将它拆分为很多个小的查询，这样就能将服务器上原本一次性的压力分散到一个很长的时间段中，这样就可以大大降低对服务器的影响，也可以大大减少删除时锁的持有时间。如下所示：
rows_affected = 0
do {
rows_affected = do_query(
    &amp;quot;DELETE FROM messages WHERE created &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&amp;quot;)
} while rows_affected &amp;gt; 0

当然我们还可以通过分解关联查询的方法来重构查询，比如下文代码块中的例子乍一看好像没什么好处，实际上它的优势可不少。

让缓存的效率更高。因为许多应用程序可以方便的缓存单表查询对应的结果对象；
将查询分解后，执行单个查询可以减少锁的竞争；
在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展；
可以减少冗余记录的查询。在应用程序做关联意味着对应某条记录应用只需要查询一次，而在数据库访问则可能需要重复访问；
查询本身效率也可能会提升。比如例子中使用 IN() 代替关联查询，可以让 MySQL 按照 ID 顺序进行查询；
更进一步，这样做相当于在应用中实现了哈希关联，而不是 MySQL 的嵌套循环关联。

SELECT * FROM tag 
    JOIN tag_post ON tag_post.tag_id = tag.id
    JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = &#39;mysql&#39;


# 可以将上面的查询分解为下面的小查询

SELECT * FROM tag WHERE tag = &#39;mysql&#39;;
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE id in (123, 456, 567, 9098, 8904)


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">
                        高性能索引策略
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-15</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-other_2">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-banana">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/gao-xing-neng-suo-yin-ce-lue.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

在 MySQL 中的索引中已经介绍了常见的两种索引类型和索引的优缺点。高效的选择和使用索引有很多种方式，下面介绍几种常见的方法。
独立的列
如果查询中的列不是独立的，则 MySQL 就不会使用索引，这里「独立的列」是指索引列不能是表达式的一部分，也不能是函数的参数。比如SELECT actor_id FROM actor WHERE actor_id + 1 = 5，凭肉眼都能看出来 WHERE 中的表达式其实等价于actor_id = 4，但是 MySQL 却无法自动解析这个表达式。因此我们应该养成简化 WHERE 条件的习惯，始终将索引列单独放在比较符号的一侧。
多列索引
一些所谓的专家建议把 WHERE 条件里面的列都建上索引，实际上这个建议是非常错误的，因为这样一来最好的情况下也只能是「一星」索引，其性能比起真正的最优的索引可能差几个数量级。

索引将相关的记录放到一起则获得「一星」；如果索引中的数据顺序和查找中的排列顺序一致则获得「二星」；如果索引中的列包含了查询中需要的全部列则获得「三星」。

MySQL5.0 之前只能使用某一个单列索引，在这种情况下没有哪一个独立的单列索引是有效的。比如表film_actor在字段film_id和actor_id上各有一个单列索引，但是对于下面这个查询的 WHERE 条件单列索引却不会生效，MySQL 对这个查询会使用全表扫描。因此在 5.0 之后的版本引进了「索引合并」的策略。
SELECT film_id, actor_id FROM film_actor WHERE actor_id = 1 OR film_id = 1

索引合并算法由三个变种：OR 条件的联合；AND 条件的相交；组合前两种情况的联合及相交，它的作用是同事使用单列索引进行扫描，并将结果进行合并。需要注意的是 MySQL 会使用这类技术优化复杂查询，更多的时候是说明了表上的索引建的很糟糕。比如当服务器对多个索引做相交操作时（通常有多个 AND 条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个单列索引。
选择合适的索引列顺序
索引列的顺序是容易引起困惑的问题，这一点可以参考 MySQL 中的索引中关于 B-Tree 的介绍，列顺序也决定了一个索引是否能够成为一个真正的三星索引。需要注意的是，本小节内容适用于 B-Tree 索引。
选择索引列的顺序有一个经验法则：将选择性最高的列放到索引最前列。但是这个法则在一些情况下没有避免随机 I/O 那么重要，这里想要说明的是这个法则不是放之四海皆准。
聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，「聚簇」表示数据行和相邻的键值紧凑地存储在一起。当然因为无法把数据行放在两个不同的地方，所以一个表只能有一个聚簇索引。因为是存储引擎负责实现索引，因此并不是所有的存储引擎都支持聚簇索引，而且它的具体细节也和实现方式有关。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">
                        MySQL 中的索引
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-03-08</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-other_1">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mysql-zhong-de-suo-yin.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版）》

一说到「索引」这个词，不知道数据库的人可能首先联想到的就是一本书的索引，它的作用是方便读者快速查找书中的内容。数据库的索引也是这样的效果，是存储引擎用于快速找到记录的一种数据结构。
很明显索引会直接影响到查询的速度，从书籍中的索引可以联想到一些可能会存在的问题。不同的索引编排方式会有不同的查询速度，这对应于数据库使用不同数据结构来建立的索引；试想一下一本书的索引部分比内容部分还要厚，那索引就会起到反向的作用。
索引类型
就像上面提到的一样，索引有很多种不同的类型，不同的索引类型可以针对不同的场景提供更好的性能。需要注意的是 MySQL 的索引不是在服务层实现的，而是在存储引擎实现的，所以并没有统一的索引标准，甚至有的存储引擎都不支持索引，下面介绍两个常用的索引。
B-Tree 索引
我们常说的索引就是 B-Tree 索引，要注意的是我们使用「B-Tree」这个术语是因为 MySQL 在CREATE TABLE和其它语句中使用的也使用该关键字，而且其底层结构使用的并不一定是 B-树。
以前整理过关于「B-树」和「B+树」的资料，详细的资料可以查看以前写的从二叉树到 B+ 树索引。
值得注意的是 B-Tree 对索引列是顺序组织存储的，很适合查找范围数据，例如下面数据表的索引会按照图示的方式去存储。
CREATE TABLE people (
	last_name varchar(50) not null,
	first_name varchar(50) not null,
	dob date not null,
	gender enum(‘m’, ‘f’) not null,
	key(last_name, first_name, dob)
);


因此这样的索引也就会有它自己的限制。1、如果不是按照索引的最左侧列开始查找，则无法使用索引；2、不能跳过索引中的列，也就是说上述索引无法用于查找 last_name 为 Smith 并且生日在某个特定日期的人；3、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。例如WHERE last_name=‘Smith’ AND first_name LIKE ‘%J’ AND dob = ‘1976-12-23’，这个查询就只能使用索引的前两列，因为这里的 LIKE 是一个范围条件。
哈希索引
如果你的数据结构没有忘的话，那么我想「哈希索引」对你来说应该是见名知意的，它只有精确匹配索引所有列的查询才有效。对每一行数据存储引擎都会对所有的索引列计算出一个哈希码。
既然是基于哈希表实现，那么就不可避免需要考虑哈希冲突的情况。一般避免哈希冲突的方式都是将槽变成一个链表，只要哈希函数选的好，能够让数据均匀的分到各个桶里面就不会出现很要命的性能问题。
因为哈希索引需要计算哈希值，所以不宜选择 MD5、SHA1 等较复杂的哈希函数；当然哈希值也不宜过长或者过短，过长索引值会占用较大的存储空间，过短太容易造成哈希冲突。哈希索引的存储非常的紧凑，所以查询速度会很快，但它也有自己的局限性：
1、哈希索引只包含哈希索值和行指针，而不存储字段值，所以不能使用哈希索引中的值来避免读取行；2、哈希索引数据并不是按照索引值顺序存储的，所以也不能用于排序；3、哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值；4、哈希索引只支持等值比较查询，不支持任何范围查询；5、如果哈希冲突很多的话，一些索引维护操作的代价会很高。
以SELECT id FROM url WHERE url_crc=CRC32(&amp;quot;http://www.mysql.com&amp;quot;)为例，一旦出现了哈希冲突，即另一个字符串的哈希值和http://www.mysql.com是一样的，那么这个语句就无法正常的工作，需要在 WHERE 子句中包含常量值才能正常工作，比如加入AND url=&amp;quot;http://www.mysql.com&amp;quot;。
索引的优点
「索引」这个主题深入讲完完全全值得写一本书了，要深入理解这部分知识可以查阅相关资料。需要注意的是，即便我们使用了对象关系映射（ORM）工具，仍然需要关心索引，即便是查询优化技术专家也很难兼顾到各种情况，更别说各种 ORM 了。总结下来索引有如下三个优点：

索引大大减少了服务器需要扫描的数据量；
索引可以帮助服务器避免排序和临时表；
索引可以将随机 I/O 变为顺序 I/O。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">
                        Schema 与数据类型优化
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-23</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-primary">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-info">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/schema-yu-shu-ju-lei-xing-you-hua.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》

选择优化的数据类型
世面上常见的数据库大多支持了多种多样的数据类型，选择正确的数据类型对于获得高性能至关重要，一般都需要遵循如下的几个原则：
1、更小的通常更好：更小的通常更快，因为占用着更少的磁盘、内存和 CPU，并且处理时需要的 CPU 周期也更少；
2、简单就好：简单数据类型的操作通常需要更少的 CPU 周期；
3、尽量避免 NULL：如果查询中包含可为 NULL 的列，就会使得索引、索引统计和值比较变得复杂，因此在设计表是最好指定列为 NOT NULL。

整数类型
在 MYSQL 中可以为整数类型指定宽度，例如INT(11)，但是这对大多数应用是没有意义的，它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具（如 MySQL 命令行客户端）用来显示字符的个数。对于存储和计算来说INT(1)和INT(20)是相同的。
字符串类型
需要注意的是当 MySQL 存储 CHAR 值时，它会删掉所有的末尾空格，因为 CHAR 值会根据需要采用空格进行填充以方便比较，这导致的问题就是你使用 CHAR 存储的&#39;string &#39;会变成&#39;string&#39;。CHAR 的好处在于它是定长的，很适合存储像 MD5 值一样的定长值，定长值的 CHAR 类型不易产生碎片，而且对于非常短的列 CHAR 也会比 VERCHAR 好，比如CHAR(1)只需要一个字节，而VERCHAR(1)则需要两个字节，因为它还需要一个字节来存长度。
VERCHAR 类型在存储可变长字符串时，会比 CHAR 更节省空间，它需要使用 1 或者 2 个额外的字节记录字符串的长度。但由于行是变长的，当一个行占用的空间增长，并且在页内没有更多的可用空间可以存储，就容易产生碎片。
使用枚举代替字符串
有时候可以使用枚举列代替常用的字符串类型，枚举列可以把一些不重复的字符串存储成一个预定义的集合，而且 MySQL 在存储枚举时非常紧凑，会根据列的数量压缩到一个或两个字节。比如下面的例子：
CREATE TABLE enum_test(
    e ENUM(&#39;fish&#39;, &#39;apple&#39;, &#39;dog&#39;) NOT NULL
);

INSERT INTO enum_test(e) VALUES(&#39;fish&#39;), (&#39;dog&#39;), (&#39;apple&#39;);

SELECT e+0 FROM enum_test;

# result
+-----+
| e+0 |
+-----+
|   1 |
|   2 |
|   3 |
+-----+

可以看到使用枚举类型后，上面三行数据实际上存储为了整数，而不是字符串，而且还有一个让人吃惊的地方：枚举字段是按照内部存储的整数而不是定义的字符串进行排序的，这一点需要特别注意，不然在写程序时容易中犯错。当然你也可以在查询时使用FIELD()函数显式地指定排序顺序。
可以看到上面
范式和反范式
关系型数据库有设计范式的概念，这一点在大学的数据库课程中肯定都会提及。因为有比较高的范式，那么就只有很少或者没有重复的数据，因此在 UPDATE 时只需要修改更少的数据；高范式的表通常也更小，因此占用的内存也会更小，操作起来也会更快......
但是高范式也带来了另一个缺点，比较好的范式通常意味着需要关联，稍微复杂一点的查询就需要使用 JOIN，关联的代价是昂贵的，甚至让一些索引策略失效；而如果不需要关联，即使某个查询需要全表扫描，当数据比内存大时可能会比关联查询快的多。所以一般都会根据实际情况将范式与反范式混用，完全的范式化和完全的反范式化都是实验室才有的东西。
缓存表和汇总表
这里的「缓存表」和「汇总表」并没有什么标准的含义。我们用「缓存表」来存储那些可以从其他表获取，但是获取的速度很慢的数据；而「汇总表」则用来保存那些使用 GROUP BY 语句聚合数据的表。毫无疑问，我们存这些冗余数据也是为了性能。
比如近两年各种应用流行的年终报告，每次网易云音乐的年终报告都会把朋友圈撑满，其它类似于缓存一个用户的朋友数、一个文件的下载次数等等。这些数据实时计算的开销是很大的，而且多数情况下用户也等不起实时计算的时间，一般的解决方案都是通过增加计数器表（缓存表）来解决这个问题。
计算机科学中总是伴随着双面性，上面的计数器表带来性能提升的同时也带来了并发问题。网站的每一次点击都会导致对计数器的更新，对于任何想要更新这一行的事务来说，这条记录都有一个全局的互斥锁，这会使得这些事务只能串行的进行。每一次点击都会触发下面的语句，但大量的点击伴随着该行数据的互斥锁，想想性能也不会提升到哪里去吧。
UPDATE hit_counter SET cnt = cnt + 1;

大多数应用都是读查询居多，为了提升读查询的速度，经常会需要增加一些额外的索引，增加冗余列、汇总表、缓存表等等。但是不要忘了这些技巧也会增加写查询的负担，还会增加开发难度，因此应该根据实际应用场景来做权衡。
加快 ALTER TABLE 表的速度
MySQL 执行大部分修改表结构的方法都是用新的结构创建一个空表，然后从旧表中查出所有数据插入到新表，然后删除旧表。在内存不足、表很大、索引多的情况下会花费很长的时间。一个很严重的缺点是大部分 ALTER TABLE 操作将导致 MySQL 服务中断。
对于常见的场景我们有两种技巧避免服务中断。一种是先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换；另一种技巧是「影子拷贝」，即用要求的表结构创建一张和源表无关的新表，然后通过重命名和删除表的操作交换两张表。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">
                        MySQL 架构与历史
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-16</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/mysql/" class="post-tag i-tag
                            i-tag-warning">
            #MySQL
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-error">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mysql-jia-gou-yu-li-shi.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
《高性能 MySQL（第三版））》
码农翻身知识星球
数据库村的旺财和小强

存储引擎
 Writing a Custom Storage Engine / Overview 中说存储引擎负责管理 MySQL 的数据存储和索引，MySQL 服务器通过已经定义好的 API 与存储引擎进行通信。
不同的存储引擎都有各自的优势和劣势，存储引擎相互之间不会通信，除了 InnoDB 外其它引擎都不会解析 SQL，API 屏蔽了存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎 API 包含了几十个底层函数，下面列举了其中的一小部分函数，如果你要自己实现一个存储引擎，那所做的工作就是把这些接口函数实现。
//创建一个表
virtual int create(const char *name, TABLE *form, HA_CREATE_INFO *info)=0;

//打开一个表
int open(const char *name, int mode, int test_if_locked);

//写入一行数据
int write_row(byte *buf);

//更新一行
int update_row(const byte *old_data, byte *new_data);

//删除一行
int delete_row(const byte *buf);

//开始一个事务
int  start_stmt(THD *thd, thr_lock_type lock_type);

//提交一个事务
int (*commit)(THD *thd, bool all);

//回滚一个事务
int (*rollback)(THD *thd, bool all);

// ......

MySQL 内建了很多存储引擎，除此之外还有很多社区版的第三方引擎，对于这么多引擎我们应该怎么选择呢？这里可以归结为一句话「除非需要用到某些 InnoDB 不具备的特性，并且没有其它办法可以代替，否则都应该选择 InnoDB 引擎」。例如，如果要用到全文索引，建议优先考虑 InnoDB 加上 Sphinx 组合，而不是使用支持全文索引的 MyISAM。当然，如果不需要用到 InnoDB 的特性，同时其它引擎的特性能够更好的满足需求，也可以考虑一下其它引擎。
除非万不得已，否则不要混合使用多种存储引擎。如果应用需要不同的存储引擎，你至少应该考虑「事务」、「备份」、「崩溃恢复」、「特有的特性」几个因素。
并发控制
数据库需要大量的磁盘读写操作，自然而然就会产生并发控制的问题。我们可以简单的使用读写锁来解决解决并发控制问题。读锁是共享的，多个客户可以在同一时刻读取同一个资源；写锁是排他的，一个写锁会阻塞其它写锁和读锁，只有这样才能在同一时间内只有一个用户能执行写入，并防止其它用户读取正在写入的同一资源。
上一段内容只说了锁，但是没有讨论锁的粒度，锁定资源时是直接锁定整个数据库还是仅锁定具体的表，亦或是只锁定要操作的那几行记录？首先我们需要明白的是任何时候，在给定的资源上，锁定的数据量越少则系统的并发程度越高，只要相互之间不冲突即可。
但是我们还忘了另一件事，加锁本身也是需要消耗资源的，获得锁、检查锁的解除、释放锁等等都会增加系统的开销，如果系统花费大量的时间来管理锁，而不是管理数据，那么系统的并发程度同样会受到影响。因此锁策略就是在锁的开销和数据的安全性之间寻求平衡。
大多数商业数据库在锁策略上并没有提供更多的选择，一般都是在表上施加行级锁。MySQL 则提供了多种选择，每种 MySQL 引擎都可以实现自己的锁策略和锁粒度，比较重要的两种锁策略是「表锁」和「行级锁」。
多版本并发控制
刘大在数据库村的旺财和小强中把「事务的隔离级别」和「多版本并发控制（MVCC）」讲的已经比较透彻了，此处我仅借助文字描述来加深我自己的理解。
MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因为避免了加锁的这些开销，所以 MVCC 能够提升并发性能。包括 Oracle、PostgreSQL、MySQL 等等数据库都实现了 MVCC，只是各自的实现机制不一样，因为 MVCC 没有一个统一的实现标准，比较典型的实现方式有「乐观并发控制」和「悲观并发控制」。
MVCC 是通过保存数据在某个时间点的快照来实现的（这难道不是一个版本控制器吗）。以 InnoDB 为例，它是通过在每行记录后面保存两个隐藏的列来实现，一个保存了行的创建时间，另一个则保存了行的过期（删除）时间。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录记录的版本号做比较。
因此根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。因为同一条记录在存储器中拥有多个版本，每个事务也有自己的版本号，只要把事务和记录的版本号做对比即可知道需要取哪个版本的记录了。一言以蔽之，MVCC 是一个借助空间来换取时间的策略。
小知识点
MySQL 使用文件系统的目录和文件来保存数据库和表的定义，所以大小写敏感就和具体的平台密切相关，在 Windows 中大小写不敏感，而在 Linux 等类 Unix 中则是敏感的。不同的存储引擎保存数据和索引的方式是不同的，但是表的定义则是在 MySQL 服务层统一处理的，my_table表的定义保存会被保存在my_table.frm中。
如果表在创建并导入数据后，不会再对该表进行修改操作，那么这样的表比较适合 MyISAM 压缩表，而且压缩表也支持索引。可以使用myisampack对 MyISAM 表进行压缩，压缩后的表是不能进行修改的，但是可以极大的减少磁盘的空间占用，因此也可以减少磁盘 I/O，这无疑是一种提升查询性能的方法。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mysql-jia-gou-yu-li-shi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men/">
                        MongoDB 聚合入门
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-04</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-other_3">
            #数据库
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/mongodb-ju-he-ru-men.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            MongoDB 聚合官方文档
聚合管道是一个基于数据处理管道概念建模的数据聚合框架，文档进入一个多阶段的处理管道，该管道最终将其转换为聚合后的结果。
下面的例子来源于官方文档。第一阶段，$match按status字段来过滤文档，并把status字段值为A的文档传递到下一阶段；第二阶段，$group将文档按cust_id进行分组，并针对每一组数据对amount进行求和。
db.orders.aggregate([
   { $match: { status: &amp;quot;A&amp;quot; } },
   { $group: { _id: &amp;quot;$cust_id&amp;quot;, total: { $sum: &amp;quot;$amount&amp;quot; } } }
])

管道

聚合管道包含很多步骤，每一步都会将输入的文档进行转换，但并不是每个阶段都一定需要对每个输入文档生成一个输出文档，比如某些阶段可能生成新的文档或者过滤掉文档。
除了$out、$merge、$geoNear外，其它的阶段都可以在管道中多次出现，更加详细的内容可以查看 Aggregation Pipeline Stages。

管道表达式
一些管道阶段采用表达式作为操作元，管道表达式指定了要应用到输入文档的转换，表达式自己是一个文档结构（JSON），表达式也可以包含其它的表达式。
表达式仅提供文档在内存中的转换，即管道表达式只能对管道中的当前文档进行操作，不能引用来自其他文档的数据。
写聚合表达式式建议直接参考官方文档，下面列出一些我收集的案例，供深入理解使用。
案例一：将对象数组转换为单个文档
// 转换前
{
    &amp;quot;_id&amp;quot;: &amp;quot;10217941&amp;quot;,
    &amp;quot;data&amp;quot;: [
        {
            &amp;quot;count&amp;quot;: 2,
            &amp;quot;score&amp;quot;: &amp;quot;0.5&amp;quot;
        },
        {
            &amp;quot;count&amp;quot;: 6,
            &amp;quot;score&amp;quot;: &amp;quot;0.3&amp;quot;
        },
        {
            &amp;quot;count&amp;quot;: 5,
            &amp;quot;score&amp;quot;: &amp;quot;0.8&amp;quot;
        }
    ]
}

// 转换后
{
    &amp;quot;_id&amp;quot;: &amp;quot;10217941&amp;quot;,
    &amp;quot;0.3&amp;quot;: 6,
    &amp;quot;0.5&amp;quot;: 2,
    &amp;quot;0.8&amp;quot;: 5
}

需要说明的是，如果上面data属性中的数据格式为{&amp;quot;k&amp;quot;: &amp;quot;0.6&amp;quot;, &amp;quot;v&amp;quot;: 5}，那么下面的聚合表达式就不需要$map，这一点可以查看 $arrayToObject。这个案例的难点在于score中有小数点，这个小数点会让聚合表达式懵逼的。
db.collection.aggregate([
    {
        &amp;quot;$addFields&amp;quot;: {
            &amp;quot;data&amp;quot;: {
                &amp;quot;$arrayToObject&amp;quot;: {
                    &amp;quot;$map&amp;quot;: {
                        &amp;quot;input&amp;quot;: &amp;quot;$data&amp;quot;,
                        &amp;quot;as&amp;quot;: &amp;quot;item&amp;quot;,
                        &amp;quot;in&amp;quot;: {
                            &amp;quot;k&amp;quot;: &amp;quot;$$item.score&amp;quot;,
                            &amp;quot;v&amp;quot;: &amp;quot;$$item.count&amp;quot;
                        }
                    }
                }
            }
        }
    },
    {
        &amp;quot;$addFields&amp;quot;: {
            &amp;quot;data._id&amp;quot;: &amp;quot;$_id&amp;quot;
        }
    },
    {
        &amp;quot;$replaceRoot&amp;quot;: {
            &amp;quot;newRoot&amp;quot;: &amp;quot;$data&amp;quot;
        }
    }
]);


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/mongodb-ju-he-ru-men/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou/">
                        简单理解磁盘结构
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-04-24</time>
                    
                        <a href="https://mengxiaoxu.github.io/tag/shu-ju-ku/" class="post-tag i-tag
                            i-tag-info">
            #数据库
        </a>
                        
                        <a href="https://mengxiaoxu.github.io/tag/kvSwja8aw/" class="post-tag i-tag
                            i-tag-error">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou/">
                            <img class="post-feature-image" src="https://mengxiaoxu.github.io//post-images/jian-dan-li-jie-ci-pan-jie-gou.jpg">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            数据库系统总会涉及到辅助存储（大多都是磁盘），因为它们能够存储大量需要长期保存的数据，因此我们有必要先了解了解磁盘的相关知识。
根据机械原理，存储器的容量越大其速度就越慢。但是速度越快的存储器，其单位字节的价格就越贵。现代计算机系统可以包含几个不同的可以存储数据的部件，就形成了存储器的层次结构，但是需要注意的是「虚拟内存」是操作系统与操作系统运用机器硬件的产物，它不是存储器的层次之一。
磁盘结构
传统的硬盘盘结构是像下面这个样子的，它有一个或多个盘片，用于存储数据。盘片多采用铝合金材料；中间有一个主轴，所有的盘片都绕着这个主轴转动。一个组合臂上面有多个磁头臂，每个磁头臂上面都有一个磁头，负责读写数据。

磁盘一般有一个或多个盘片。每个盘片可以有两面，即第一个盘片的正面为0面，反面为 1 面；第二个盘片的正面为 2 面......依次类推。磁头的编号也和盘面的编号是一样的，因此有多少个盘面就有多少个磁头。盘面正视图如下图，磁头的传动臂只能在盘片的内外磁道之间移动。因此不管开机还是关机，磁头总是在盘片上面。关机时，磁头停在盘片上面，抖动容易划伤盘面造成数据损失，为了避免这样的情况，所以磁头都是停留在起停区的，起停区是没有数据的。

每个盘片的盘面被划分成多个狭窄的同心圆环，数据就存储在这样的同心圆环上面，我们将这样的圆环称为磁道 (Track)。每个盘面可以划分多个磁道，最外圈的磁道是0号磁道，向圆心增长依次为1磁道、2磁道......磁盘的数据存放就是从最外圈开始的。

根据硬盘的规格不同，磁道数可以从几百到成千上万不等。每个磁道可以存储数 Kb 的数据，但是计算机不必要每次都读写这么多数据。因此，再把每个磁道划分为若干个弧段，每个弧段就是一个扇区 (Sector)。扇区是硬盘上存储的物理单位，现在每个扇区可存储 512 字节数据已经成了业界的约定。也就是说，即使计算机只需要某一个字节的数据，但是也得把这个 512 个字节的数据全部读入内存，再选择所需要的那个字节。

柱面是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为柱面 ，即各盘面上面相同位置磁道的集合。需要注意的是，磁盘读写数据是按柱面进行的，磁头读写数据时首先在同一柱面内从 0 磁头开始进行操作，依次向下在同一柱面的不同盘面(即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面。因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。数据的读写是按柱面进行的，而不是按盘面进行，所以把数据存到同一个柱面是很有价值的。
磁盘被磁盘控制器所控制（可控制一个或多个），它是一个小处理器，可以完成一些特定的工作。比如将磁头定位到一个特定的半径位置；从磁头所在的柱面选择一个扇区；读取数据等。

现代硬盘寻道都是采用CHS(Cylinder Head Sector)的方式，硬盘读取数据时，读写磁头沿径向移动，移到要读取的扇区所在磁道的上方，这段时间称为寻道时间(seek time)。因读写磁头的起始位置与目标位置之间的距离不同，寻道时间也不同。磁头到达指定磁道后，然后通过盘片的旋转，使得要读取的扇区转到读写磁头的下方，这段时间称为旋转延迟时间(rotational latencytime)。然后再读写数据，读写数据也需要时间，这段时间称为传输时间（transfer time）。
根据上文的信息，我们可以得出磁盘容量的计算公式为：
硬盘容量 = 盘面数 × 柱面数 × 扇区数 × 512字节

笔试题实战
下面的题目是腾讯某一年校招笔试中的一个题目，题干信息描述为：数据存储在磁盘上的排列方式会影响I/O服务的性能，一个圆环磁道上有10个物理块，10个数据记录R1~R10存放在这个磁道上，记录的安排顺序如下表所示。



物理块
1
2
3
4
5
6
7
8
9
10




逻辑记录
R1
R2
R3
R4
R5
R6
R7
R8
R9
R10



假设磁盘的旋转速度为20ms，磁盘当前处在R1的开头处，若系统顺序扫描后将数据放入单缓冲区内，处理数据的时间为4ms（然后再读取下个记录），则处理这10个记录的最长时间是多少？

答案：磁盘会一直朝某个方向旋转，不会因为处理数据而停止。本题要求顺序处理 R1 到 R10，起始位置在 R1，一周是 20ms，共 10 个记录，所以每个记录的读取时间为 2ms。首先读 R1 并处理 R1，读 R1 花 2ms，读好后磁盘处于 R1 的末尾或 R2 的开头，此时处理 R1，需要 4ms，因为磁盘一直旋转，所以 R1 处理好了后磁盘已经转到 R4 的开始了，这时花的时间为 2+4=6ms。这时候要处理 R2，需要等待磁盘从 R5 一直转到 R2 的开始才行，磁盘转动不可反向，所以要经过 8*2ms 才能转到 R1 的末尾，读取 R2 需要 2ms，再处理 R2 需要 4ms，处理结束后磁盘已经转到 R5 的开头了，这时花的时间为 2*8+2+4=22ms。等待磁盘再转到 R3 又要 8*2ms，加上 R3 自身 2ms 的读取时间和 4ms 的处理时间，花的时间也为 22ms，此时磁盘已经转到 R6 的开头了，写到这里，就可以看到规律了，读取并处理后序记录都为 22ms，所以总时间为 6+22*9=204ms。

如何加速对磁盘的访问
对于理解数据库系统系统特别重要的是磁盘被划分为磁盘块（或像操作系统一样称之为页），每个块的大小是 4~64KB。磁盘访问一个磁盘块平均要用 10ms，但是这并不表示某一应用程序将数据请求发送到磁盘控制器后，需要等 10ms 才能得到数据。如果只有一个磁盘，在最坏的情况下，磁盘访问请求的到达个数超过 10ms 一次，那么这些请求就会被无限的阻塞，调度延迟将会变的非常大。因此，我们有必要做一些事情来减少磁盘的平均访问时间。
按柱面组织数据：前这一点在前文已经提到过了。因为寻道时间占平均块访问时间的一半，如果我们选择在一个柱面上连续的读取所有块，那么我们只需要考虑一次寻道时间，而忽略其它时间。这样，从磁盘上读写数据的速度就接近于理论上的传输速率。
使用多个磁盘：如果我们使用多个磁盘来替代一个磁盘，只要磁盘控制器、总线和内存能以 n 倍速率处理数据传输，则使用 n 个磁盘的效果近似于 1 个磁盘执行了 n 次操作。因此使用多个磁盘可以提高系统的性能。
磁盘调度：提高磁盘系统吞吐率的另一个有效方法是让磁盘控制器在若干个请求中选择一个来首先执行，调度大量块请求的一个简单而有效的方法就是电梯算法。回忆一下电梯的运行方式，它并不是严格按先来后到的顺序为乘客服务，而是从建筑物的底层到顶层，然后再返回来。同样，我们把磁盘看作是在做横跨磁盘的扫描，从柱面最内圈到最外圈，然后再返回来，正如电梯做垂直运动一样。
预取数据：在一些应用中，我们是可以预测从磁盘请求块的顺序的。因此我们就可以在需要这些块之前就将它们装入主存。这样做的好处是我们能较好的调度磁盘，比如采用前文的电梯算法来减少访问块所需要的平均时间。
磁盘故障
如果事情都像我们一开始设计的那样进行，那世界肯定会变得特别无聊。磁盘偶尔也会耍耍小脾气，甚至是罢工不干了。比如在读写某个扇区一次尝试没有成功，但是反复尝试后有成功读写了，我们称之为间歇性故障。
一种更为严重的故障形式是，一个或多个二进制位永久的损坏了，所以不管我们尝试多少次都不可能成功，这种故障称之为介质损坏。
另一种相关的错误类型称之为写故障，当我们企图写一个扇区时，既不能正确的写，也不能检索先前写入的扇区，发生这种情况的一种可能原因就是在写过程中断电了。
当然肯定最严重的就是磁盘崩溃，这种故障中，整个磁盘都变为永久不可读，这是多么可怕的事情。
既然会出现上面所述的各种大小故障，那么我们就必须要采取各种措施去应对大大小小的变故，保证系统能正常运行。
规避故障
我们尝试读一个磁盘块，但是该磁盘块的正确内容没有被传送到磁盘控制器中，就是一个间歇性故障发生了。那么问题是控制器如何能判断传入的内容是否正确呢？答案就是使用校验和，即在每个扇区使用若干个附加位。在读出时如果我们发现校验和对数据位不合适，那么我们就知道有错误；如果校验和正确，磁盘读取仍然有很小的可能是不正确的，但是我们可以通过增加趣多校验位来降低读取不正确发生的概率。
此处我们使用奇偶校验来举例，通过设置一个校验位使得二进制集合中 1 的个数总是偶数。比如某个扇区的二进制位序列是 01101000，那么就有奇数个 1，所以奇偶位是 1，这个序列加上它后面的奇偶位，就有 011010001；而如果所给的序列是 11101110，那么奇偶位就是 0。所以每一个加上了奇偶位构成的 9 位序列都有偶数奇偶性。
尽管校验和几乎能正确检测出介质故障或读写故障的存在，但是它却不能帮助我们纠正错误。为了处理这个问题，我们可以在一个或多个磁盘中执行一个被称为稳定存储的策略。通常的思想是，扇区时成对的，每一对代表一个扇区内容 X。我们把代表 X 的扇区对分别称为左拷贝 XL和右拷贝XR。这样实际上就是每个扇区的内容都存储了两份，操作XL失败，那么去操作XR就可以了，更何况我们还在每个扇区中有校验和，把错误的概率就大大降低了。
到现在为止，我们讨论的都是简单的故障，但是如果发生了磁盘崩溃，其中的数据被永久破坏。而且数据没有备份到另一种介质中，对于银行金融系统这将是巨大的灾难，遇到这种情况我们应该怎么办呢？
数据恢复
应对磁盘故障最简单的方式就是镜像磁盘，即我们常说的备份。回忆一下写毕业论文时的做法，那时候大部分同学还不会用版本控制器，所以基本采用每天备份一次数据，并且在文件名称中标注日期，以此来达到备份的效果。
第二种方式是使用奇偶块，比如一个系统中有 3 个磁盘，那么我们再加一个磁盘作为冗余盘。在冗余盘中，第 i 块由所有数据盘的第 i 块奇偶校验位组成。也就是说，所有第 I 块的第 j 位，包括数据盘和冗余盘，在它们中间必须有偶数个 1，冗余盘的作用就是让这个条件为真。
我们举个简单例子，假设快仅由一个字节组成，我们有三个数据盘和一个冗余盘，对应的位序列如下。其中 盘4 为冗余盘，它的位序列是根据前面三个盘计算出来的。
盘 1：11110000
盘 2：10101010
盘 3：00111000
盘 4：01100010

假设现在某个盘崩溃了，那么我们就能根据上面的序列来恢复数据，只需要让每一列 1 的个数为偶数就可以了，但是这种冗余方式也存在很大的不足。
第一个缺陷是，如果是两个盘同时崩溃了，那数据也恢复不出来了。第二个问题在于，虽然读数据只需要一次 I/O 操作即可，但是写数据时就不一样了，因为需要根据其他数据盘来计算冗余盘中的位序列，假设共有 n 个盘，其中一个为冗余盘，所以每次写数据时，都需要进行 n+1 次 I/O 操作（读不被写入的 n-1 个盘，被重写数据盘的一次写，冗余盘的一次写），而 I/O操作又是非常耗时的操作，所以这种方法会大大拖慢系统性能。
另一种方案是没有明显的冗余盘，而是把每个磁盘作为某些块的冗余盘来处理。比如现在有 4 个盘，0 号磁盘将作为编号为 4、8、12 等柱面的冗余，而 1 号磁盘作为编号为 1、5、9 等块的冗余......
一种更为先进的方式使用海明码来帮助从故障中恢复数据，它在多个磁盘崩溃的情况下也能恢复出数据，也是 RAID 的最高等级，由于本人水平有限，用文字表达不清楚，就不作介绍了，嘿嘿。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mengxiaoxu.github.io/post/jian-dan-li-jie-ci-pan-jie-gou/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mengxiaoxu.github.io//images/avatar.png?v=1597851616006)">
        </div>
        <h1 class="id_card-title">
            刘小绪同学的博客
        </h1>
        <h2 class="id_card-description">
            正在学习写代码的码农
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/mengxiaoxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/SlmpbWm59SPreqb" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                            <a href="https://www.douban.com/people/189583084" target="_blank" rel="noopener noreferrer"><i
                    class="icon-douban"></i></a>

        </div>
    </div>

    <div class="id_card i-card">
        <h1 class="id_card-title">
            最新文章
        </h1>
        <div class="new-aticles">
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/dian-shang-ling-yu-tao-li-an-li/">拼多多（淘宝）空手套利案例分享</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/cha-xun-xing-neng-you-hua/">查询性能优化</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/gao-xing-neng-suo-yin-ce-lue/">高性能索引策略</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/mysql-zhong-de-suo-yin/">MySQL 中的索引</a>
                </h3>
            
            
            
                <h3>
                    <a href="https://mengxiaoxu.github.io/post/schema-yu-shu-ju-lei-xing-you-hua/">Schema 与数据类型优化</a>
                </h3>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mengxiaoxu.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>